[{
    "title": "設定 ssh 金鑰登入遠端主機",
    "date": "",
    "description": "使用 ssh key 登入遠端主機而不使用密碼登入",
    "body": "一般登入伺服器是使用帳號與密碼進行登入，但是密碼可能會因為抄錄或是傳遞給人而外洩\n安全性的程度會比較沒有像SSH key 那麼安全，而且使用SSH key 登入可以就不用每次手動輸入密碼\n建立登入端的 ssh key 使用者端建立 ssh key，使用指令 ssh-keygen  注意：ssh key 要是 RSA 的格式，如果是 OPENSSH 會不斷的報錯\n參考資料：mac majave 10.14.1 ssh-keygen 金鑰格式問題\n 預設會產生在 .ssh/ 路徑下\n如果是用複製別人的 id_rsa 和 id_rsa.pub 的話需要重新設定權限，否則會報錯\nchmod 600 id_rsa chmod 644 id_rsa.pub 權限說明 -rw------- (600) -- 只有屬主有讀寫權限。 -rw-r--r-- (644) -- 只有屬主有讀寫權限；而屬組用戶和其他用戶只有讀權限。 -rwx------ (700) -- 只有屬主有讀、寫、執行權限。 -rwxr-xr-x (755) -- 屬主有讀、寫、執行權限；而屬組用戶和其他用戶只有讀、執行權限。 -rwx--x--x (711) -- 屬主有讀、寫、執行權限；而屬組用戶和其他用戶只有執行權限。 -rw-rw-rw- (666) -- 所有用戶都有文件讀、寫權限。這種做法不可取。 -rwxrwxrwx (777) -- 所有用戶都有讀、寫、執行權限。更不可取的做法。 以下是對目錄的兩個普通設定： drwx------ (700) - 只有擁有者可在目錄中讀、寫。 drwxr-xr-x (755) - 所有用戶可讀該目錄，但只有擁有者才能改變目錄中的內容 遠端主機設定 登入遠端主機之後，檢查使用者家目錄是否存在 ./ssh/authorized_keys 檔案\n若沒有則自行建立，並設定權限 chmod 600 authorized_keys\n檔案內容為剛剛產生的 id_res.pub 的內容\n範例：\nssh-rsa AABAB3NzaC1yc2Gmy80/{...中略...}/UD9CBSzNAya7r6w== 補充 讓雲端主機可以存取版本庫  建立 GCP 使用者後，依照上面做法產生 ssh key 把 public key 加到版本庫的 ssh key 列表中 ",
    "ref": "/blog/202104-use-ssh-key-login-remote-server/"
  },{
    "title": "雲端主機啟動 Docker 服務",
    "date": "",
    "description": "介紹如何在雲端主機啟用 docker 服務",
    "body": "新開主機啟用 docker 與 docker-compose 服務的操作步驟\n安裝 Docker sudo apt-get install docker.io sudo apt install docker.io 將使用者加入群組 此操作可以讓使用者不需要 sudo 就執行 docker 指令，為非必要步驟\nsudo usermod -a -G docker {ec2-user} ref: Ubuntu Linux 安裝 Docker 步驟與使用教學\n也有人直接將使用者加入 sudoer 群組中，有一樣的結果\n安裝 docker-compose sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose ref: Install Docker Compose\n 如此就可以在新開的雲端主機進行 Docker 容器的操作\n",
    "ref": "/blog/202103-enable-docker-service-in-remote-server/"
  },{
    "title": "PostgreSQL 資料庫建置 - 使用 Docker",
    "date": "",
    "description": "介紹如何使用 Docker 建置 PostgreSQL 資料庫",
    "body": "使用 Docker 來建置一個 PostgreSQL 資料庫\n包含 資料庫建置、資料持久化、使用 GUI 操作資料庫\nPostgreSQL 基礎教學：後端前進PostgreSQL 系列\n環境建置 - 使用 Docker-compose 使用的映像檔：postgres: alpine\n參考文章：Getting Started with PostgreSQL using Docker-Compose\ndocker-compose.yml version: \u0026#39;3\u0026#39; services: postgres: container_name: postgres ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:alpine\u0026#34; volumes: - database-data:/var/lib/postgresql/data # persist data even if container shuts down restart: always environment: POSTGRES_USER: superuser POSTGRES_PASSWORD: superpassword POSTGRES_DB: demo_db volumes: database-data: # named volumes can be managed easier using docker-compose 啟動容器：\ndocker-compose up  GUI 安裝 因為 sequel ace 不支援 PostgreSQL 所以另外裝一個 GUI 來用\n安裝 DBeaver\n會需要安裝 JAVA 包\nbrew install --cask dbeaver-community 存取在遠端的 PostgreSQL container 取得該遠端的對外 ip 作為 host 之後連線到指定的 port (5432)\n就可以在其他機器上存取 PostgreSQL container\n 資料持久化 (persist data) 官方文件說明\n使用docker-compose啟動服務時，初始化資料庫和資料(以Mysql為例)\nDifferent Types of Volumes\nnamed volume：  docker-compose up 啟動容器 docker volume ls 確認有建立 volume docker-compose stop 停止容器 docker-compose up，使用 GUI 連線容器確認資料有被重新掛載 docker-compose down，移除容器 docker ps -a 確認容器確實被移除 docker-compose up，volume 成功掛載回去  host volume 調整容器內 volume 目標資料夾位置到本機特定資料夾下\n如果有多台容器需要一起掛載同一份資料：官方文件\n這個做法使用 docker volume ls 就不會有結果，要自己去看指定的路徑。因為管理 volume 已經不是透過 docker\nversion: \u0026#39;3\u0026#39; services: postgres: container_name: postgres ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:alpine\u0026#34; volumes: - ./database_data:/var/lib/postgresql/data # persist data even if container shuts down restart: always environment: POSTGRES_USER: superuser POSTGRES_PASSWORD: superpassword POSTGRES_DB: trp  調整 yml 檔 service 內 volumes，改為指定路徑 docker-compose up 啟動容器 使用路徑管理 volume 後 docker volume ls 不會有反應 查看指定路徑 ./database_data，volume 檔案成功寫入 docker-compose up，使用 GUI 連線容器確認資料有被重新掛載 docker-compose down，用 docker ps -a 確認 container 確實被移除 docker-compose up，volume 成功掛載回去  補充 如果在同一台機器上想要啟用多個 PostgreSQL 容器\n則 5432 port 會被佔用，當然可以將外部 port 改為不衝突的 port\n但是內部 port 使用的依然是 5432 如果在容器網路內直接溝通，例如 Laravel 的 .env 設定的 port\n當透過容器外部網路線連線時使用調整後錯開的 port 連線正常\n但是當執行 php artisan migrate 之類指令，執行者是容器時\n要使用的卻是內部的 5432 port，如此在管理上會十分麻煩\n此情境下可以透啟動容器時指定內部運行的 port 來解決\npostgre: container_name: trp_stage_postgre ports: - \u0026#34;5430:5430\u0026#34; image: \u0026#34;postgres:12.6\u0026#34; volumes: - /trp/database/stage/database_data:/var/lib/postgresql/data # persist data even if container shuts down command: -p 5430 environment: POSTGRES_USER: ${TRP_DB_USER} POSTGRES_PASSWORD: ${TRP_DB_PASSWORD} POSTGRES_DB: ${TRP_DB_NAME} restart: always 如上面的設定中 command: -p 5430 指定了內部 postgres 使用的 port\n所以在 ports: 設定中就直接將外部 port 5430 指定給內部的 port 5430\n這樣不管在容器內或外部都可以使用一樣的 port 來進行連線\n",
    "ref": "/blog/202103-build-postgresql-database-useing-docker/"
  },{
    "title": "反向代理 - 在 Docker 環境建置",
    "date": "",
    "description": "介紹基本反向代理以及在 Docker 環境中建置",
    "body": "反向代理的基本說明，以及在 Docker 容器中如何建立反向代理\n反向代理 系統設計 - 正向代理跟反向代理\n不同實體主機 使用 nginx proxy-pass 目標  使用者造訪指定網頁路徑 /new_path 或是整個跳轉 / 設定測試機 nginx proxy_pass 使其跳轉到其他主機專案相同路徑下 確認使用者 IP 沒有被變成為代理伺服器的 IP 確認在代理目標的專案可以讀取 Cookie 確認 Post 請求的 payload 也會被轉送過去  設定 nginx config 第一台主機的 nginx 設定 # 把所有前往 domain/new_path 的請求反向代理到另一台主機上 location /new_path { # 要代理到哪個網址 proxy_pass http://laravel55.test.com; # 傳送使用者真實 IP 到目標主機 proxy_set_header X-Real-IP $remote_addr; # 設定伺服器為代理前的伺服器，否則 HTTP_HOST 會變成 proxy 那台代理伺服器的位址 proxy_set_header Host $host; # 設定 cookie 轉發 proxy_set_header Cookie $http_cookie; # 用來確認最初的用戶端原始 ip 位置 proxy_set_header X-Forwarded-Host $host; # 記錄從使用者端出來經過的每個代理 X-Forwarded-For: \u0026lt;client\u0026gt;, \u0026lt;proxy1\u0026gt;, \u0026lt;proxy2\u0026gt; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 識別網路連線協定 proxy_set_header X-Forwarded-Proto $scheme; # 隱藏伺服器資訊 proxy_hide_header Server; proxy_hide_header X-Powered-By; # 因為自行加大 header 所以把空間也加大 proxy_headers_hash_bucket_size 128; proxy_headers_hash_max_size 512; } 第二台主機的 nginx 設定 server { listen 80; server_name ray200; root /home/toc/www/laravel55/public; access_log /var/log/nginx/www/laravel55.access.log; error_log /var/log/nginx/www/laravel55.error.log; index index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~* \\.(jpg|jpeg|gif|css|png|js|ico|html|svg|ttf|woff|woff2|eotD)$ { access_log off; expires max; } location ~ \\.php$ { include snippets/fastcgi-php.conf; # php-fpm 的位置 fastcgi_pass 127.0.0.1:9000; } } 注意事項  server_name 必須要是 proxy_pass 過來那台的 domain，如果不這樣設定，proxy_pass 過來會進到預設的 server_name 下 在程式中判斷真實 IP 的方法要改成讀讀取 header 中的 x-real-ip 才是真實使用者 ip 位置  確認 cookie 可以讀取 如果設定 nginx 有設定 proxy_set_header Cookie $http_cookie;\n那 dump($_COOKIE); 可以取得 cookie，但是 Laravel 內建的 request()-\u0026gt;cookie(); 卻沒有取到值\n解決方案 Laravel 預設的 web middleware \\App\\Http\\Middleware\\EncryptCookies::class, 會要求 cookie 是加密過後的，如果沒有加密當然就讀不到。\n解決方案一個是在 EncryptCookies 這個 class 中的 $except 加入要排除的 cookie 名稱，另一個就是直接把 middleware 註解掉。\n 使用 Docker 架構示意圖 參考資料：How to set up NGINX Docker Reverse Proxy?\n步驟 1. 手動建立 network  反向代理會根據載入的設定檔把請求導向到指定的容器名稱內\n故代理的目標容器必須在同一網路內，才能直接使用容器名稱做代理目標\n 因為不想讓 network 前面帶上 prefix，還有避免依賴，所以手動建立 network\ndocker network create nginx-network 這個情境屬於來自外部的 nginx-proxy，要多給一個 external network 有需要連接到這個 network 裡面的服務都要設定\nnetworks: default: external: name: nginx-network 如此就可以讓不同 docker-compose.yml 中的服務互相溝通：官方說明\n2. 建立測試用的服務 因為懶得建太複雜的服務，所以抓現成的 portainer 服務來做為 proxy 的目標\n只是為了要有一個只要 docker-compose up 就可以運行的服務，也可以換成自己比較熟的映像檔\n為了測試從 80 port poxy 到其他 port，所以這邊開在 8080 port\n服務啟動之後可以先去 localhost:8080 查看 portainer 服務有沒有啟動\nversion: '3' networks: default: external: name: nginx-network services: portainer: container_name: nginx_test_portainer image: portainer/portainer-ce command: -H unix:///var/run/docker.sock restart: always ports: - 8080:9000 volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data volumes: portainer_data: 3. Nginx 的 proxy 設定 3.1 設定 docker-compose.yml version: '3' networks: default: external: name: nginx-network services: nginx: container_name: test_nginx image: nginx:1.18 ports: - \u0026quot;80:80\u0026quot; - \u0026quot;443:443\u0026quot; volumes: - ./conf.d/:/etc/nginx/conf.d/ - ./ssl/:/ssl/ 3.2 設定 mount 進去給反向代理伺服器使用的 nginx config 可以看到底下設定中，我們把所有發往 test.example 網址的請求都轉到\nhttp://nginx_test_portainer:9000 在容器中使用的模式是\n http://{container_name}:{port}\n 可以看到 container_name 對應了上面建立測試服務時候使用的容器名稱\n而 port 對應到了容器的內部 port！\n這邊特別把上面的容器內外使用的 port 區隔開來顯示差別，我們代理的目標是內部的 9000 port\n而不是對外的 8080 port\nserver { listen 80; listen [::]:80; server_name test.example; return 301 https://$host$request_uri; } server { listen 443 ssl; listen [::]:443 ssl; server_name test.example; ssl_certificate /ssl/ssl.crt; ssl_certificate_key /ssl/ssl.key; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { proxy_set_header Host $host; proxy_set_header Cookie $http_cookie; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $host; proxy_pass http://trp_portainer:9000; } } 要特別注意的是，這邊 proxy_pass 的目標網址中，http:// 不可以省略\n如果轉址過去的網址有自己的 https 證書驗證(例如另一個 nginx 環境)，則必須改成 https:// 開頭\n參考資料：What value should I use for Nginx proxy_pass running in Docker?\n3.3 編輯 etc/hosts 127.0.0.1 test.example 接著啟動 nginx 服務，用瀏覽器開啟剛剛設定的 test.example\n正確設定的話，監聽 80 port 的 nginx 服務應該會把所有目標是 test.example 的請求利用 proxy_pass 送到 portainer 容器的指定 port\n所以畫面上會顯示 portainer 服務的畫面\n 要在所有服務都啟動之後再啟動反向代理服務，否則會報錯指出被代理的容器目標不存在\n 注意事項 如果要把全部沒有匹配到的 server_name 請求統一處理\n可以在指定的 nginx config 加上 default_server 定義\n如果沒有定義 default_server，則第一個 server 會被預設成 default server \nserver { listen 8080 ssl default_server; listen [::]:8080 ssl default_server; ssl_certificate /ssl/ssl.crt; ssl_certificate_key /ssl/ssl.key; # Virtual Host Domain server_name _; # where code is root /var/trp/dev/www/trp_backend/public; index index.php index.html index.htm; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri /index.php =404; fastcgi_pass trp_dev_php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ /\\.ht { deny all; } } 因為要處理沒有被其他 server_name 捕獲的請求\n所以 server_name 就不是什麼重點，可以用 _, __, ___ 都可以\n這個情境會發生在當前端的 API 設定檔使用的路徑網址是指定後端容器名稱的時候 因為不是使用網址經過反向代理轉發，而是直接將請求發至容器\n而這個 nginx 容器中又有多個 server config 設定\n所以 nginx 沒有 server_name 可以判斷要使用哪個 config 設定\n案例說明 同一個 nginx 容器(dev_nginx) 裡面有多個 server config\n alex_backend john_backend dev_backend  如果現在有一個在同樣 docker network 的前端容器要打 API 到 dev_backend\n他會在設定檔指定網址是 dev_nginx\n這時候問題就來了，當 dev_nginx 收到這個請求會不知道是發給誰的\n如果沒有設定 default_server，就會把請求派發給第一個 server，也就是 alex_backend\n這不是我們要的結果\n所以會把 dev_backend 設定為 default_server\n如此之後，只要是送進這個容器的請求\n若沒有被其他設定檔捕獲，就會被送進 dev_backend 處理\n",
    "ref": "/blog/202102-reverse-proxy-in-docker-service/"
  },{
    "title": "Laravel 執行環境建置",
    "date": "",
    "description": "介紹 Laravel 執行環境所需要的環境設定，包含 composer 安裝",
    "body": "開發 Laravel 專案所需要做的設定與套件安裝，不論是在遠端主機或是本機都適用\n更新套件包 sudo apt-get update 安裝 composer php -r \u0026#34;copy(\u0026#39;https://getcomposer.org/installer\u0026#39;, \u0026#39;composer-setup.php\u0026#39;);\u0026#34; php -r \u0026#34;if (hash_file(\u0026#39;sha384\u0026#39;, \u0026#39;composer-setup.php\u0026#39;) === \u0026#39;756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3\u0026#39;) { echo \u0026#39;Installer verified\u0026#39;; } else { echo \u0026#39;Installer corrupt\u0026#39;; unlink(\u0026#39;composer-setup.php\u0026#39;); } echo PHP_EOL;\u0026#34; php composer-setup.php php -r \u0026#34;unlink(\u0026#39;composer-setup.php\u0026#39;);\u0026#34; 執行結果 Composer (version 2.0.12) successfully installed to: //composer.phar Use it: php composer.phar 將指令改成全域 執行後可以直接使用 composer 指令操作\n很方便，建議要執行這個步驟\nmv composer.phar /usr/local/bin/composer 安裝 PHP extension 以 PHP 版本 7.4 的主機為例\n要在容器外運行 composer install，需要安裝以下 extension\n php7.4-mbstring php7.4-cli php7.4-gd ext-dom(php-xml) zip unzip php7.4-zip  apt install php7.4-cli apt-get install mbstring ext-dom zip unzip php7.4-zip php7.4-mbstring php-xml php7.4-gd 安裝資料庫對應的 extension 依照專案使用的資料庫自行安裝\n例如：\n php7.4-pgsql php7.4-mysql  php artisan 必要套件 php artisan 要在 php 指令介面(php Command Line Interface) 下執行\n所以必須依照自身 php 版本安裝 cli 套件\napt install php7.4-cli  以上就是建置 Laravel 環境所需要的最基本設定\n若是容器化的使用者，在打包 php 映像檔的時候一併執行即可\n",
    "ref": "/blog/202102-laravel-environment-basic-settings/"
  },{
    "title": "Ngrok 讓 localhost 可以被外部連線",
    "date": "",
    "description": "Ngrok 開發測試 webhook 的利器",
    "body": "ngrok 做為一個轉發的伺服器，他可以把外界的請求轉發到你指定的 Port\n使用的背景原理是連接到 ngrok 雲端伺服器將你本機指定的地址公開\n再將由 ngrok 一串公開的網址來存取內容\n他的優點是快速而且還提供了 https 的服務讓你使用上更安全，甚至你還可以設置密碼保護\n官方文件與載點：https://ngrok.com/download\n安裝 Mac brew install ngrok Linux 確認自己的主機硬體架構\ncat /proc/cpuinfo 再去官網下載指定檔案依照官網安裝 或是直接使用 snap 安裝\nsudo apt update sudo apt install snapd sudo snap install ngrok 使用 啟動並監聽 8080 Port\nngrok http 8080 就可以看到對外開放的網址\n註冊 ngrok 不註冊的話過一段時間就會被斷線，開發階段使用免費版本就足夠了\nNgrok authtoken 頁面 複製 Authtoken 之後到 terminal 輸入\nngrok authtoken {Your Authtoken} 看到以下訊息代表認證完成\nAuthtoken saved to configuration file: /Users/user_name/.ngrok2/ngrok.yml ",
    "ref": "/blog/202102-ngrok-share-your-local-development-site/"
  },{
    "title": "Portainer - 視覺化管理 Docker 的工具",
    "date": "",
    "description": "介紹如何使用 Portainer 視覺化管理 Docker 服務",
    "body": "本機開發大部分使用指令操作，或是使用 Docker 本身的 GUI 介面管理服務\nPortainer 是一個 open-source 的 UI tool\n可以查看 docker image, container，並執行 start, stop, restart, remove 等動作\n也可查看每個 container 的 log 及 error\n在雲端主機上啟動服務的話，即使沒有 Docker 執行權限的人也可以透過帳號密碼登入\n使用視覺化的介面進行 Docker 服務的各種管理\nDockerhub image: portainer/portainer-ce\ndocker-compose.yml version: \u0026#39;3\u0026#39; services: portainer: image: portainer/portainer-ce command: -H unix:///var/run/docker.sock restart: always ports: - 9000:9000 - 8000:8000 volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data volumes: portainer_data: 為了 edge agent 而開啟 8000 port：文件說明\n 補充 如果遠端主機不想開放 port 造成任意使用者都有機會開啟後台畫面\n可以使用超外道的連線方式：How to Create SSH Tunneling or Port Forwarding in Linux\nssh -i ~/.ssh/id_rsa -L 8081:localhost:9000 ray@{你的遠端主機 IP} 在容器啟動後可以在本機終端機執行\n接著就可以在本機 localhost:8081 看到我們在遠端主機的 9000 port\n原理是透過 ssh 連線將本機 8081 port 的請求轉發到遠端主機的 9000 port\n這個方法不論遠端防火牆有沒有開放該 port 都可以執行，十分不講武德\n也不限於 Portainer 服務才能使用\n",
    "ref": "/blog/202101-portainer-open-source-container-management-gui/"
  },{
    "title": "Docker 筆記 3 - docker-compose",
    "date": "",
    "description": "介紹如何使用 docker-compose 管理多個容器",
    "body": "如果同時要管理彼此是有關連的多個 docker 容器，單純使用 docker 指令必須要自行記得容器之間的關聯\n而使用 docker-compose，則可以輕鬆定義多容器服務\n簡介  Docker for Mac 預設 python 所寫成的工具 由yaml定義 設定檔為 docker-compose.yml 依賴 docker 版本  官方文件：docker-compose\n設定檔構成 docker-compose.yml 由兩個部分所構成\n version（版本要字串） services  key -\u0026gt; DNS name(hostname)    docker-compose 範例\n其他工具 docker-swarm  看成 kubernetes 的分身 落地方便（kubernetes 準備工作很多） 高可用性 HA 價格便宜  組成（Node）\n 分兩個節點。  Manager：  分派任務給 worker node 同時也是 worker node 控制整個 Docker Swarm 的部署 主控制節點 如果死掉，整個 docker swarm 就死掉了 可以有多台 manager，但只有一台 \u0026amp;*$%^^#???   Worker：  被分派任務 不會主動分派任務 不知道其他 worker node     可以隨時 rolling update。 在所有 node 底下：  Service：  一個Service包含一種container Service啟動不代表container啟動 可以對container進行health check Service可以啟動複數個container(replicas)   Task  主要是由Service帶起來的 代表在docker container內執行的指令 task會在node上到執行結束為止     ",
    "ref": "/blog/202101-docker-note-3-introduce-docker-compose/"
  },{
    "title": "Docker 筆記 2 - 基本使用",
    "date": "",
    "description": "Docker 的基本使用方法",
    "body": "容器化可以隔離不同環境，將環境打包後工程師可以專注開發，不用花過多心力在開發環境安裝上\n而 Docker 是目前非常成熟且流行的一個容器化技術\n玩轉docker指令 查看容器資訊 docker ps 列出所有運行中的容器 docker ps -a 列出所有存在的容器 看 log docker logs [CONTAINER] 印出 log docker logs -f [CONTAINER] 持續印出最新 log 執行容器 從本地環境的 image 建立 container\n如果不存在從 repository 訪問，private repo 必須要有「登入」行為\nimage的格式可以為[IMAGE NAME]:[TAG]\ndocker run 範例： # 執行nginxdocker run -idt nginx# 執行nginx並且暴露port為8080docker run -idt -p 8080:80 nginx# 執行nginx在8080，在失敗的時候會自動重啟動docker run -idt -p 8080:80 --restart on-failure nginx# 執行nginx，結束後移除docker run --rm -idt nginx常用到的 flag  -d detach 將 container 置於背景執行 -i interactive 維持 STDIN，可互動 -t 提供 tty 允許 container 使用 tty -p expose socket 對外:對內 port (ex -p 8080:80) -p Host Port:Docker Port --restart 失敗重啟(always-default, none, on-failure) --rm 關閉後 container 自動消滅，若不刪可能會不斷累積，即使已經死掉了  常用指令 進入運行中的容器，並開啟終端機指令介面\ndocker exec -ti [CONTAINER] bash 取得 container 或是 image 的 Metadata\ndocker inspect [CONTAINER] 刪除 docker container\ndocker rm [CONTAINER] 刪除 docker image\ndocker rmi [IMAGE] 查看容器運行 process\ndocker top [CONTAINER] 其他指令 使用 Dockerfile 建立 docker image\n-f 手動指定 Dockerfile 名稱\n# 在目前的資料夾建立image，來源是Dockerfile docker build . -t image-name # 在目前的資料夾建立image，來源是Dockerfile-alt docker build . -t image-name -f Dockerfile-alt 將 docker image 從 repository 上拉/推上去\n要先登入 docker login\ndocker push / pull 登入 docker repository\ndocker login 怎麼寫自己的dockerfile  先註冊 Docker Hub Alpine Linux  體積非常的小 (5MB) 有完整的Linux架構 豐富的元件支援    常見 Dockerfile 命令 基本  FROM：指定基底 image，不指定版本的話預設都是 latest RUN：  docker build 時候執行命令，裝一些相依套件。 每一個 RUN 都是獨立事件   ARG：  container docker build 時的建置參數 無法在 container 中被使用   ENV：  printenv 容器內使用的環境變數 格式：ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; 或是 ENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt;    檔案複製  COPY：  複製「來源文件\\目錄」到的容器中的「文件\\目錄」中 COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;source path\u0026gt;... \u0026lt;dist path\u0026gt; dist path 可以是 Container 內的絕對路徑，也可以是相對於 WORKDIR 的相對路徑 會保留來源數據的各種屬性   ADD：  強化版的 COPY ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;source path\u0026gt;... \u0026lt;dist path\u0026gt; 允許 source path 是一個 URL 文件權限自動設置為 600    執行指令  ENTRYPOINT：  Container 起來預設會執行的指令 最後指令，啟動時要保持在前景的指令   CMD：  container起來預設會執行的指令（或參數） ENTRYPOINT, CMD 同時存在 CMD 當參數使用   WORKDIR(cd + mkdir):  初始容器內工作目錄    指令差異 ARG vs ENV ARG 由建立 image 的時候帶入\ndocker build . --build-arg FOO=bar ENV是在docker container內作為環境變數使用\nCMD vs ENTRYPOINT ENTRYPOINT 在 container 啟動時預設執行 CMD 在 ENTRYPOINT 存在時作為參數使用\nFROM ubuntu ENTRYPOINY [\u0026#34;ping\u0026#34;] CMD [\u0026#34;localhost\u0026#34;] COPY vs ADD COPY 適用在將本地端的檔案複製到container內\nADD 適用將遠端的檔案複製到container內\n除錯  docker: Got permission denied\n 這個錯誤是因為當前使用者的權限不足\n可以將使用者提升至 root 保證權限\n但是比較安全且正確的做法應該是\n 建立 docker 執行群組 將使用者加入 docker 群組  指令如下，需要退出重新登錄後才會生效！\nsudo groupadd docker sudo usermod -aG docker user_name ",
    "ref": "/blog/202101-docker-note-2-basic-usage/"
  },{
    "title": "Docker 筆記 1 - 認識 Docker",
    "date": "",
    "description": "介紹什麼是 Docker，以及容器化技術",
    "body": "容器化可以隔離不同環境，將環境打包後工程師可以專注開發，不用花過多心力在開發環境安裝上\n而 Docker 是目前非常成熟且流行的一個容器化技術\n將OS做為 Application 化\n所有 container 只能允許一個指令執行\n預設權限都會是 root\n商業來說\n 方便部署 可攜性  容器進化史 What is a Container?\n名詞介紹  Stateful Stateless：在未設的前提之下，每次建立時會消除舊的資料 Repository  就像是 apt、brew 或是 yum 的來源一樣 存了很多 image (Package)   Image  相當於 Package 產生特殊的 cache，本地有 cache 的話，就不需再從 Respository (如 Docker hub) 抓   Container  由 image 建立而成 相當於一個一個的程式，可以持續執行 必須要有一個 foreground 在跑的程式   Network  none：沒有網路 bridge：區網 overlay：不同網段 container：Docker 預設的網路連線, 無法由外部直接進來 host：與本機共用網路介面   Volume  Docker 內的持久化(Stateful)空間，可以 stateful 的秘密(空間) 等同本機空間    架構 生命週期  client 呼叫 docker daemon docker daemon 與 host network / host cgroups 溝通 判斷 docker container 是否存在 從 local image 將 layer 解開 如果 local image 不存在的話從 repository 拿 建立 docker container  學習資源 線上練習環境：Play with Docker\nDocker 基本觀念與使用教學：自行建立 Docker 影像檔 - G. T. Wang\n鸟瞰Docker\n30 天與鯨魚先生做好朋友\n",
    "ref": "/blog/202101-docker-note-1-what-is-docker/"
  },{
    "title": "[Express+Vue 搭建電商網站] 12 在 Vuex 使用 Mutation 管理狀態",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 在 Vuex 使用 Mutation 管理狀態",
    "body": "透過 Mutation 管理 Vuex中的狀態\n使用 Mutation 在 Vuex 中 Mutation 是修改 Vuex store 內容的唯一方法\nMutation 是定義在 Vuex store 物件中 mutations 屬性的一系列函數\n長得會像\nACTION_NAME(state, payload) { return state++; } 其中 ACTION_NAME 就是組件發出的事件或動作的名稱\n這個函數接收兩個參數 state 和 payload。state 就是在 Vuex store 裡面儲存的 state\npayload 則是跟著呼叫的事件或是動作一起傳來的參數\n然後就可以對現有的 state 做操作而回傳新的 state，透過這種方式我們可以輕鬆的管理所有狀態\n初始化 mutations 狀態 打開 src/store/index.js 檔案，修改其中的 state\n並加入 mutations，這邊我們先把資料寫死，未來會接上先前寫的後端 API\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [ { _id: \u0026#39;1\u0026#39;, name: \u0026#39;iPhone 11\u0026#39;, description: \u0026#39;全新雙相機系統，捕捉所見所愛，範圍更多更廣。智慧型手機歷來最快速的晶片，加上滿足一天的電池續航力，讓你完成更多事，充電更少次。而智慧型手機中最高的影片畫質，讓你的點滴回憶，看起來比過去更加動人精彩。\u0026#39;, image: \u0026#39;https://i.gadgets360cdn.com/large/iPhone11_leak_1567592422045.jpg\u0026#39;, price: 44000, manufacturer: \u0026#39;Apple Inc\u0026#39; }, { _id: \u0026#39;2\u0026#39;, name: \u0026#39;Pixel 4\u0026#39;, description: \u0026#39;只要用Pixel 4 拍照，不用進工作室後製編輯，也能拍出相同品質的相片！Pixel 4 是第一支能夠拍下銀河的手機，只要輕輕一點，就能拍下美麗星空。\u0026#39;, image: \u0026#39;https://pgw.udn.com.tw/gw/photo.php?u=https://uc.udn.com.tw/photo/2019/10/16/realtime/6946830.jpg\u0026#39;, price: 24990, manufacturer: \u0026#39;Google\u0026#39; }, { _id: \u0026#39;3\u0026#39;, name: \u0026#39;Xperia 1 II\u0026#39;, description: \u0026#39;由於 Sony 先前整合了 Mobile 手機部門到 Sony 本家消費性電子產品部門的緣故，所以這次以這樣的命名方式出現也不讓人意外。\u0026#39;, image: \u0026#39;https://timgm.eprice.com.tw/tw/mobile/img/2020-02/24/5484360/innocences_1_a8c4b844f3c0c83646b79e366c3d8111.jpg\u0026#39;, price: 29000, manufacturer: \u0026#39;SONY\u0026#39; }, { _id: \u0026#39;4\u0026#39;, name: \u0026#39;V30S\u0026#39;, description: \u0026#39;LG V30 S ThinQ 最大的改變是 Vision AI 功能的加入，拍照的同時相機會自動識別畫面中的場景，準確的設定場景模式。\u0026#39;, image: \u0026#39;https://img.eprice.com.tw/img/mobile/5858/large.png\u0026#39;, price: 12500, manufacturer: \u0026#39;LG\u0026#39; }, { _id: \u0026#39;5\u0026#39;, name: \u0026#39;Galaxy Note 9\u0026#39;, description: \u0026#39;做為三星每年下半年度的旗艦手機，Note 系列從 2011 年的第一代 Galaxy Note 起，就以 S Pen 做為最大賣點，並且帶動大螢幕智慧手機的風潮直到今日。\u0026#39;, image: \u0026#39;https://timgm.eprice.com.tw/tw/mobile/img/2018-08/09/5115231/hat7029_1_77763a4f06a1fba43ab32e66d90bcba1.jpg\u0026#39;, price: 18900, manufacturer: \u0026#39;Samsung\u0026#39; } ], // all manufacturers  manufacturers: [], }, mutations: { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) } } }); 除了 state 中暫時寫死的商品內容外，我們加了兩個 mutations 屬性下的方法\n分別代表組件中「將商品加入購物車」以及「從購物車移除移出商品」的動作\nProductList 組件 接著要新建「商品列表」的組件，用來展示商品詳細資訊\n新建 /src/components/products/ProductList.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;This is ProductList\u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in products\u0026#34;\u0026gt; \u0026lt;div :key=\u0026#34;product._id\u0026#34; class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;產品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;addToCart(product)\u0026#34;\u0026gt;加入購物車\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;product-list\u0026#34;, computed: { // a computed getter  products() { return this.$store.state.products; } }, methods: { addToCart(product) { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product }); } } }; \u0026lt;/script\u0026gt; 在 \u0026lt;script\u0026gt; 中定義了一個 computed 作為商品資料的預處理\n這樣在模板渲染時就只需要使用 {products} 就可以取得在 Vuex store 中的 products 資料\n然後定義了一個點擊事件 addToCart 來處理加入購物車按鈕的點擊\n會通過 this.$store.commit 方法\n將目前商品物件 {product} 當作 payload 來操作 Vux store 中 mutation 所定義的 ADD_TO_CART 方法做狀態修改\n組件建立完之後要在畫面引入才能使用\n修改首頁 src/pages/Home.vue 把剛剛建立的 ProductList.vue 組件加入畫面\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;In Stock\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-list\u0026gt;\u0026lt;/product-list\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductList from \u0026#39;@/components/products/ProductList.vue\u0026#39;; export default { name: \u0026#39;home\u0026#39;, data () { return { msg: \u0026#39;Welcome to Your Vue.js App\u0026#39; }; }, components: { \u0026#39;product-list\u0026#39;: ProductList } } \u0026lt;/script\u0026gt; 購物車 接著要修改購物車頁面 /src/views/Cart.vue 將商品資訊顯示出來。\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in cart\u0026#34;\u0026gt; \u0026lt;div :key=\u0026#34;product._id\u0026#34; class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;產品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;removeFromCart(product._id)\u0026#34;\u0026gt;從購物車中移除\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;home\u0026#34;, data() { return { msg: \u0026#34;Welcome to the Cart Page\u0026#34; }; }, computed: { cart() { return this.$store.state.cart; } }, methods: { removeFromCart(productId) { this.$store.commit(\u0026#34;REMOVE_FROM_CART\u0026#34;, { productId }); } } }; \u0026lt;/script\u0026gt; 同樣的加入 computed 對商品做預處理\n這邊接收的是 this.$store.state.cart 也就是購物車中的商品列表\n寫好觸發 Vuex mutation 中移出購物車的按鈕方法 removeFromCart\n接著就可以開啟瀏覽器預覽執行結果\n一開始購物車是空的，我們隨便加了幾款手機進購物車後，在購物車頁面可以看見剛剛有選中的商品！\n而在購物車頁面可以將商品從購物車移除。\n",
    "ref": "/blog/202009-express-vue-build-ecommerce-12-vuex-mutation/"
  },{
    "title": "[Express+Vue 搭建電商網站] 11 認識 vuex",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 認識 vuex",
    "body": "vuex 來協助我們集中管理組件狀態，就不用到處維護狀態\n使得組件只需要專注於渲染頁面，而前端狀態都保留在 vuex 中建立的狀態庫中\n所謂狀態庫，其實也就是一個 Javascript 物件\n安裝 vuex 可以使用指令\nnpm install vuex --save 或是依然使用 vue ui 來安裝\n如果是使用 vue ui 安裝，會發現專案下多了一個檔案：/src/store/index.js，先用以下內容取代原本的檔案\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [ { name: \u0026#39;產品 1\u0026#39;, } ], // all manufacturers  manufacturers: [], } }) 上面我們做了一些事情\n 導入了 Vue 和 Vuex 調用 Vue.use 方法宣告使用 Vuex，聽起來和 vue-router 的時候一樣 最後導出 Vuex.Store 物件，並傳入 strict 和 state 參數\nstrict 宣告我們必須使用 Vuex 的 Mutation 函數來改變 state，否則會報錯（這部分會在之後的章節說明）\n而 state 參數儲存全域的狀態，比如在這邊定義了 cart、showLoader 等屬性\n都是後面我們操作會使用到的資料  整合 Vuex 和 Vue 當我們建立了 Vuex 的 store 物件後就可以使用它了，打開 src/main.js\n在開頭導入之前建立的 store，並且將 store 添加到 Vue 初始化的參數列表裡\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; Vue.config.productionTip = false new Vue({ router, store, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 如果你是使用 Vue ui 安裝，打開檔案可以見到程式已經幫我們完成了以上的內容\n當我們將 store 導入到了 Vue 中進行初始化後，Vue 會將 store 裡面的 state 注入到所有的組件中\n這樣所有的 Vue 組件就共享了一個全域的 state\n而所有的狀態變化都是針對這個 javascript 物件進行操作，然後觸發組件的重新渲染\n同時也避免了組件嵌套層級過多時，組件之間傳遞屬性的複雜性，便於大型程式與團隊合作\n查看結果 在整合好 Vuex 和 Vue 之後，馬上來看看 Vuex 帶來的變化。打開 src/pages/admin/Products.vue 修改成以下內容\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt;{{ product.name }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { computed: { product() { return this.$store.state.products[0]; } } }; \u0026lt;/script\u0026gt; 可以在 \u0026lt;script\u0026gt; 中看到一個沒見過的東西 computed，先來了解一下這是什麼\nComputed 如果在前端模板內加入太多的邏輯運算，不但可讀性差也難以維護，這問題在後端套版時常常發生，很難一眼看出它到底要渲染什麼\n而 計算屬性 (computed) 有點類似於 method，但 method 需要括號來觸發\n而且 method 不管相依的資料有沒有改變，都會重新計算。computed 則是在相依的資料有改變時才做計算並渲染\n所以需要每次更新的行為用 method，在意效能的話使用 computed\n講完了 computed 屬性，回頭來看剛剛的改動，我們在 computed 定義了一個 product 屬性\n會去 Vuex 也就是 store 中的 state 中 products 的第一個元素\n然後在頁面上使用剛剛取到的內容中的 name 屬性渲染\n於是我們知道可以使用 this.$store.state 來取得 Vuex store 中保存的 state\n",
    "ref": "/blog/202009-express-vue-build-ecommerce-11-install_vuex/"
  },{
    "title": "[Express+Vue 搭建電商網站] 10 用 vue 建立一個表單",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 用 vue 建立一個表單",
    "body": "後端的 API 上次已經開了出來，接著來建立前端使用的表單\n這次的目標是建立新增商品時所用的表單，會使用到基本的 Vue 知識，如果沒看過文件的可以先了解一下官方文件\n架構規劃 之前我們建立了 /src/views/admin/New.vue 這個模板做為網址 /admin/new 的顯示頁面\n在這節中會建立一個表單，然後讓他作為頁面組件顯示在 New.vue 中\n程式實作 建立一個新的檔案 /src/components/products/ProductForm.vue 作為表單的組件\n可以看到我們在這邊的存放位置不再是 /src/views/ 因為他是組件\n好好的放在「components」內是比較好的架構方式\n\u0026lt;template\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;saveProduct\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-5 col-md-5 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Name\u0026#34; v-model=\u0026#34;model.name\u0026#34; name=\u0026#34;name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Price\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Price\u0026#34; v-model=\u0026#34;model.price\u0026#34; name=\u0026#34;price\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Manufacturer\u0026lt;/label\u0026gt; \u0026lt;select type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; v-model=\u0026#34;model.manufacturer\u0026#34; name=\u0026#34;manufacturer\u0026#34;\u0026gt; \u0026lt;template v-for=\u0026#34;manufacturer in manufacturers\u0026#34;\u0026gt; \u0026lt;option :key=\u0026#34;manufacturer._id\u0026#34; :value=\u0026#34;manufacturer._id\u0026#34; :selected=\u0026#34;manufacturer._id == (model.manufacturer \u0026amp;\u0026amp; model.manufacturer._id)\u0026#34; \u0026gt;{{manufacturer.name}}\u0026lt;/option\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-lg-4 col-md-4 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Image\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; lass=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Image\u0026#34; v-model=\u0026#34;model.image\u0026#34; name=\u0026#34;image\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Description\u0026lt;/label\u0026gt; \u0026lt;textarea class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Description\u0026#34; rows=\u0026#34;5\u0026#34; v-model=\u0026#34;model.description\u0026#34; name=\u0026#34;description\u0026#34; \u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group new-button\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-pencil\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;!-- Conditional rendering for input text --\u0026gt; \u0026lt;span v-if=\u0026#34;isEditing\u0026#34;\u0026gt;Update Product\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;Add Product\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;model\u0026#34;, \u0026#34;manufacturers\u0026#34;, \u0026#34;isEditing\u0026#34;], methods: { saveProduct() { this.$emit(\u0026#34;save-product\u0026#34;, this.model); } } }; \u0026lt;/script\u0026gt; 程式說明 於是我們來看看這段看起來很長很嚇人的東西在做什麼？\n分為兩部分來理解\nscript 部分 props 主要接收父組件傳來的三個參數 model、manufacturers、isEditing\n然後在 methods 定義了一個方法 saveProduct，當使用者填完送出後按下送出會觸發這個方法\n而在 saveProduct 內部調用了一個 save-product 方法，這個方法稍後會在父組件建立\n除了調用父組件方法，在送出的同事還會把 this.model 內容傳遞給父組件\ntemplate 部分 淺而易見的 template 就是一個表單，其中的 submit 事件使用 @submit.prevent 禁用預設的送出行為\n並使用 saveProduct 替換\n接著寫了好幾個 class=\u0026quot;form-group\u0026quot; 的區塊，代表要填寫的商品資料\n其中前兩個區塊使用了 v-model 綁定 model 的 name、price 兩個屬性\n第三個區塊先對 select 標籤雙向綁定了 model.manufacturer 屬性\n代表在內部做的行為都會影響對應的 model.manufacturer\n接著使用迴圈把 script 中接收到的父組件 manufacturers 資料一個一個設為 option 標籤內容\n並且把個別設定 manufacturer 的屬性\n以及如果 model.manufacturer._id 和當前的 manufacturer._id 一致\n就把 selected 屬性設為 true\n接著第四個 form-group 開始，依然是使用 v-model 綁定 model.image 和 model.description 屬性\n最後一個 form-group 使用 v-if 判斷式來判斷 isEditing 來渲染不同的按鈕文字\n 完成了子組件之後，就要引入父組件內。所以重新打開 New.vue 這個檔案，引入剛剛建立的表單組件\n\u0026lt;template\u0026gt; \u0026lt;product-form @save-product=\u0026#34;addProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; \u0026gt; \u0026lt;/product-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#39;@/components/products/ProductForm.vue\u0026#39;; export default { data() { return { model: {}, manufacturers: [ { _id: \u0026#39;sam\u0026#39;, name: \u0026#39;Samsung\u0026#39;, }, { _id: \u0026#39;apple\u0026#39;, name: \u0026#39;Apple\u0026#39;, }, ], }; }, methods: { addProduct(model) { console.log(\u0026#39;model\u0026#39;, model); }, }, components: { \u0026#39;product-form\u0026#39;: ProductForm } } \u0026lt;/script\u0026gt; 當要在一個組件中使用另一個組件時，需要在父組件的 components 中註冊\n在我們的 New.vue 中就將 ProductForm 註冊為 product-form\n於是我們就可以在 \u0026lt;template\u0026gt; 區塊中使用 \u0026lt;product-form /\u0026gt; 來使用組件。\n同時在 data 中定義了 model 和 manufacturers；methods 中定義了 addProduct 方法\n並且綁定成 @save-product=\u0026quot;saveProduct\u0026quot; 事件傳遞給子組件使用\n儲存之後，重新開啟前端網頁，進入新建商品的頁面就可以看到子組件已經被加入 New.vue 的畫面上\n目前為止我們學會了\n 使用 vue-router 進行多頁面的跳轉與路由 使用嵌套路由有組織的管理前端路由 基礎的 Vue 使用 學會建立 Vue 的組件並在父組件中使用 ",
    "ref": "/blog/202009-express-vue-build-ecommerce-10-new-product-page/"
  },{
    "title": "[Express+Vue 搭建電商網站] 09 API 測試",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 測試",
    "body": "在上一篇中完成了第一個 API，這一篇要來測試 API 是不是正常工作\n測試 API 經過上一篇的流程，我們的 API 應該已經建好了，現在透過常用的 API 測試軟體：Postman 來測試\nmanufacturers   POST /api/v1/manufacturers\n首先先建立供應商的資料，測試新建一個供應商「Google」\n  GET /api/v1/manufacturers\n查看供應商，因為我原本就有寫入了一個供應商「Apple」所以會有兩筆資料\n  PUT /api/v1/manufacturers/:id\n接著更新「APPLE」為「Apple」\n  DELETE /api/v1/manufacturers/:id\n最後我特別建立了一個叫做「samsung」的供應商用來測試刪除功能\n  products 最後來測試新建產品資料\n  POST /api/v1/products\n建立一個產品「iPhone 11」並且把他的供應商（manufacturer）指定給剛剛看過的「Apple」\n  GET /api/v1/products 新增完之後，使用 GET 方法取得資料查看會發現，iPhone 11 這筆資料的外部鍵值 manufacturer\n屬性的確是對應到當初在 model 設定中指定的 manufacturer Model 的 ObjectId 資料內容\n在這個範例中就是「Apple」。如此我們就建立了一款 Apple 出的手機：iPhone 11\n  結論 到這邊我們就已經建立好了 API 的服務\n在這幾個章節中我們學到了\n 了解 Express 路由以及如何使用 mongoose 連接 monogoDB 資料庫 編寫路由、Controller 和 Model 使用 Postman 測試 API  目前我們對於 Node 和 Express 搭建後端 API 有了基本的了解，就繼續前進吧！\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-09-test-api/"
  },{
    "title": "[Express+Vue 搭建電商網站] 08 API 建立",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 建立",
    "body": "在上一篇中建立了 Router，這一篇要做的就是將 Controller 完成，如此就完成了第一個 API\n建立 API 建立 Controller 接著就來建立兩個 Controller productController 和 manufacturerController\ncontrollers/manufacturer.js 這個 Controller 管理製造商（manufacturers）資料的操作，回頭看看上面路由中的方法是不是都找到了呢？\n開頭導入了之前在 Model 中定義過的 ManufacturerModel，這是 mongoose 提供給我們操作資料庫的介面\n通過 Model 上定義的一系列指令來對 Manufacturer 做資料操作\nconst Model = require(\u0026#39;../model\u0026#39;); const { Manufacturer } = Model; const manufacturerController = { all(req, res) { Manufacturer.find({}) .exec((err, manfacturers) =\u0026gt; res.json(manfacturers)) }, byId(req, res) { const idParams = req.params.id; Manufacturer .findOne({ _id: idParams }) .exec((err, manufacturer) =\u0026gt; res.json(manufacturer)); }, create(req, res) { const requestBody = req.body; const newManufacturer = new Manufacturer(requestBody); newManufacturer.save((err, saved) =\u0026gt; { Manufacturer .findOne({ _id: newManufacturer._id }) .exec((err, manfacturer) =\u0026gt; res.json(manfacturer)) }) }, update(req, res) { const idParams = req.params.id; let manufacturer = req.body; Manufacturer.updateOne({ _id: idParams }, { ...manufacturer }, (err, updated) =\u0026gt; { res.json(updated); }) }, remove(req, res) { const idParams = req.params.id; Manufacturer.findOne({ _id: idParams }).remove( (err, removed) =\u0026gt; res.json(idParams) ) } } module.exports = manufacturerController; controllers/product.js 而在 productController 中基本上與上方 manufacturerController 概念一致\nconst Model = require(\u0026#39;../model\u0026#39;); const { Product } = Model; const productController = { all(req, res) { Product.find({}) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, products) =\u0026gt; res.json(products)) }, byId(req, res) { const idParams = req.params.id; Product .findOne({ _id: idParams }) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, product) =\u0026gt; res.json(product)); }, create(req, res) { const requestBody = req.body; const newProduct = new Product(requestBody); newProduct.save((err, saved) =\u0026gt; { Product .findOne({ _id: newProduct._id }) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, product) =\u0026gt; res.json(product)) }) }, update(req, res) { const idParams = req.params.id; const product = req.body; console.log(\u0026#39;idParams\u0026#39;, idParams); console.log(\u0026#39;product\u0026#39;, product); Product.updateOne({ _id: idParams }, { ...product }, (err, updated) =\u0026gt; { res.json(updated); }) }, remove(req, res) { const idParams = req.params.id; Product.findOne({ _id: idParams }).remove( (err, removed) =\u0026gt; res.json(idParams) ) } } module.exports = productController; 完成後存擋，在終端機執行 npm start\n要先先確定是你的 mongoDB 要是開著的，可以使用指令\nmongo 看能不能進入 mongo 的指令列中，如果忘記怎麼開啟可以回到前面：連接 MongoDB 章節複習\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-08-build-api/"
  },{
    "title": "[Express+Vue 搭建電商網站] 07 API 路由建立",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 路由建立",
    "body": "在上一篇中建立了 Model，這一篇要做的就是將路由完成，讓請求可以送到指定的 Controller\nAPI 路由建立 新增路由並設定路由群組 打開 app.js 引入我們要使用的 api 路由\nconst api = require(\u0026#39;./routes/api\u0026#39;); 路徑就設定成 /api/v1 吧\napp.use(\u0026#39;/api/v1\u0026#39;, api); 這下子所有進入 /api/v1/ 以及底下路徑的所有請求都會進入 /routes/api 這個路由內\n建立新路由 我們建立一個檔案 /routes/api/index.js\nconst express = require(\u0026#39;express\u0026#39;); const router = express.Router(); const productController = require(\u0026#39;../../controllers/product\u0026#39;); const manufacturerController = require(\u0026#39;../../controllers/manufacturer\u0026#39;); router.get(\u0026#39;/manufacturers\u0026#39;, manufacturerController.all); router.get(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.byId); router.post(\u0026#39;/manufacturers\u0026#39;, manufacturerController.create); router.put(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.update); router.delete(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.remove); router.get(\u0026#39;/products\u0026#39;, productController.all); router.get(\u0026#39;/products/:id\u0026#39;, productController.byId); router.post(\u0026#39;/products\u0026#39;, productController.create); router.put(\u0026#39;/products/:id\u0026#39;, productController.update); router.delete(\u0026#39;/products/:id\u0026#39;, productController.remove); module.exports = router; 我們在上一步建立了路由群組，而這個步驟中我們照著經典的 RESTful API 規則來撰寫路由規則\n get：取得資源 post：建立新資源 put：更新資源 delete：刪除資源  在這個路由群組中不難發現，我們引用了 productController、manufacturerController\n這兩個尚未建立的檔案，而這兩個檔案就是我們 MVC 中的 Controller\n而 router 物件接了各種路徑的請求方法，並指定給所屬的 Controller 方法\n下個章節會建立 Controller 並且測試 API 是否成功運行\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-07-api-routes/"
  },{
    "title": "[Express+Vue 搭建電商網站] 06 - 資料庫設計",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 資料庫設計",
    "body": "先前我們安裝好了 mongoDB 以及開啟了 CORS，這一篇要來建立資料庫架構以及 MVC 架構中的 Model 部分\n資料庫設計 Schema 在 Express 中，資料庫的 Schema 是建立在 model/index.js 中的，如果沒有 model 資料夾就自己建一個\nconst mongoose = require(\u0026#39;mongoose\u0026#39;); const Schema = mongoose.Schema; const model = mongoose.model.bind(mongoose); const ObjectId = mongoose.Schema.Types.ObjectId; const productSchema = Schema({ id: ObjectId, name: String, image: String, price: Number, description: String, manufacturer: { type: ObjectId, ref: \u0026#39;Manufacturer\u0026#39; } }); const manufacturerSchema = Schema({ id: ObjectId, name: String, }); const Product = model(\u0026#39;Product\u0026#39;, productSchema); const Manufacturer = model(\u0026#39;Manufacturer\u0026#39;, manufacturerSchema); module.exports = { Product, Manufacturer }; 在下方兩個 model 的常數定義中 Schema 接收一個物件來定義資料結構以及對應的類型\n除了常見的 String, Number 外，比較特別的是：ObjectId 代表 MongoDB 中資料的主鍵，具有唯一性\n並且在 productSchema 中具有一個特別的屬性：manufacturer\n這個物件定義了一個 ref 屬性，對應到 Manufacturer 這個 model\n這是 MongoDB 的外部鍵值，與之對應的是 Manufacturer 中的 ObjectId 屬性的資料\n這就是我們習慣的 MVC 架構中的「Model」部分\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-06-db-schemas-and-models/"
  },{
    "title": "[Express+Vue 搭建電商網站] 05 - 連接 MongoDB 與 CORS",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 連接 MongoDB 與 CORS",
    "body": "資料庫使用 MongoDB，這篇中我們會簡單介紹基本連線方式，以及跨來源資源共(CORS)\n連接 MongoDB 接著我們要安裝 mongoose 套件：Mongoose\nMongoose 是一個 MongoDB 對象建模工具，用於在異步環境中工作\n是時下最流行的 ODM(Object Document Mapping)，要比直接操作底層 MongoDB Node 更方便\nnpm install mongoose 接著回到 app.js 中導入剛剛安裝的 mongoose\nconst mongoose = require(\u0026#39;mongoose\u0026#39;) 並透過套件提供的方法連上我們的 MongoDB 資料庫\nmongoose.connect(`mongodb://localhost:27017/test`); 雖然現在看不出效果，但我們等等會嘗試操作資料庫來測試連線的有效性\n但現在我們先做點額外的事情，儘管目前看來沒什麼用處但卻是必要的一環\n那就是開啟跨來源資源共用 CORS\n跨來源資源共用 CORS CORS 是基於 同源政策 的限制\n當關閉時限制了程式碼和不同網域資源間的互動，來自不同網域的資源請求會被無情拒絕！\n讓我們回到 app.js，在剛剛的資料庫連線下一行加入以下程式碼\n// CORS config here app.all(\u0026#39;/*\u0026#39;, function(req, res, next) { // CORS headers  res.header(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); // restrict it to the required domain  res.header(\u0026#39;Access-Control-Allow-Methods\u0026#39;, \u0026#39;GET,PUT,POST,DELETE,OPTIONS\u0026#39;); // Set custom headers for CORS  res.header(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;Content-type,Accept,X-Access-Token,X-Key\u0026#39;); if (req.method == \u0026#39;OPTIONS\u0026#39;) { res.status(200).end(); } else { next(); } }); 通常來說會使用 npm 套件 cors 解決，但這邊先用簡單暴力的方式解決\n未來如果有進行優化會再回頭安裝\n",
    "ref": "/blog/202007-express-vue-build-ecommerce-05-mongodb-connect-and-cors/"
  },{
    "title": "[Express+Vue 搭建電商網站] 04 - 進入 MongoDB 的世界",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 進入 MongoDB 的世界",
    "body": "資料庫使用 MongoDB，這篇中我們會簡單介紹基本指令及安裝。\n安裝 MongoDB 因為使用的是 mac 筆電，所以最愛用 Homebrew 安裝東西\n除了 node.js！這東西用 brew 裝會把你搞到懷疑人生，並且連官網都不建議這麼做\n但是 MongoDB 官方有釋出：使用 Homebrew 的安裝方法，我們就這個做看看吧\n至於不會使用 Homebrew 或是使用其他作業系統的人，可以使用：官方的下載中心進行安裝\n安裝好之後有兩種啟動的方法\n 作為背景執行：mongod --config /usr/local/etc/mongod.conf --fork 使用 brew 管理  這邊推薦使用 brew 來操作的原因是容易操作，簡單幾個指令就可以\n 啟動服務：brew services start mongodb-community 重新啟動：brew services restart mongodb-community 停止服務：brew services stop mongodb-community  執行之後繼續輸入 mongo 指令，應該會進到 mongoDB 的指令列中\n到這邊就代表已經 mongoDB 服務就安裝並且啟動了\n",
    "ref": "/blog/202007-express-vue-build-ecommerce-04-hello-mongodb/"
  },{
    "title": "[Express+Vue 搭建電商網站] 03 - 認識 Express",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 認識 Express",
    "body": "後端使用的是 node.js 的後端框架 - express，這篇中我們會建立新專案。\n建立 Express 專案 使用 express-generator 來建立專案\nnpm install -g express-generator 安裝完成後可以使用以下指令查看版本是否有安裝成功\nexpress --version 接著初始化建立新專案\nexpress backend 建立之後運行看看初始樣貌\ncd backend npm install npm start 打開瀏覽器 http://localhost:3000/ 應該會看到以下畫面\n打開看看 Express 專案的資料夾架構\n app.js：Express Web Application 原型 routes/index.js：路由設定主要檔案 views/：放 View 的檔案 public/：放靜態檔案  和其它文章不同的是，這次使用 express-generator 建立的專案中並沒有把所有路由給寫在 app.js 中\n而是根據不同的應用做拆分，這和前端使用 vue-router 的嵌套路由是相同的概念\napp.js 在 app.js 中一開始先對於會用到的資源進行導入，例如 routes/index 和 routes/users 兩個路由\n也定義了專案使用的前端模板類型。但因為我們後端是作為 API 使用，所以沒什麼差\nroutes/index.js 而在 routes/index.js 中定義了進入這個路由之後對於不同請求可以做的回應方式\n這就是主要我們需要先了解的部分\n",
    "ref": "/blog/202007-express-vue-build-ecommerce-03-hello-express/"
  },{
    "title": "[Express+Vue 搭建電商網站] 02 - vue-router 的使用",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - vue-router 的使用",
    "body": "在接下來的內容中會學習 vue-router 的使用方法與學習路由基礎知識\n並使用 vue-router 來進行多個頁面的跳轉\n建立新組件 首先我們要先建立新的頁面組件，新建一個 src/components/Home.vue 檔案\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;home\u0026#39;, data () { return { msg: \u0026#39;Welcome to Your Vue.js App\u0026#39; }; }, } \u0026lt;/script\u0026gt; 看起來跟一開始預設的 HelloWorld.vue 有 87% 像，但是這邊先不對樣式做糾結，之後再去找 UI 庫套用\n設定 vue-router 在安裝了 vue-router 之後，會發現專案中多了一個資料夾 /src/router/index.js\n這就是 vue-router 的設定檔\n藉由以下這段我們發現，路徑 '/' 使用的是 Home 這個組件\nconst routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;About\u0026#39;, // route level code-splitting  // this generates a separate chunk (about.[hash].js) for this route  // which is lazy-loaded when the route is visited.  component: () =\u0026gt; import(/* webpackChunkName: \u0026#34;about\u0026#34; */ \u0026#39;../views/About.vue\u0026#39;) } ] 順著邏輯往上找會發現 Home 這個組件的引用來源\nimport Home from \u0026#39;../views/Home.vue\u0026#39; 接著打開 /views/Home.vue，原來這引入了 HelloWorld 組件\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;../assets/logo.png\u0026#34;\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // @ is an alias to /src import HelloWorld from \u0026#39;@/components/HelloWorld.vue\u0026#39; export default { name: \u0026#39;Home\u0026#39;, components: { HelloWorld } } \u0026lt;/script\u0026gt; 知道原理之後呢，就把 /views/Home.vue 內部目前沒有用到的部分刪除，並且換成我們上面建立的 Home 組件\n\u0026lt;script\u0026gt; // @ is an alias to /src import Home from \u0026#39;@/components/Home.vue\u0026#39; export default { name: \u0026#39;Home\u0026#39;, components: { Home } } \u0026lt;/script\u0026gt; 這時候使用瀏覽器開啟專案首頁，應該就會看到首頁已經變成 Home.vue 的內容\n加入頁面上方導航超連結 打開 App.vue 檔案，在 id=\u0026quot;app\u0026quot; 中加入三個 router-link 標籤的超連結，這是 Vue Router 的 API\n根據官網說明 \u0026lt;router-link\u0026gt; 比起寫死的 \u0026lt;a href=\u0026quot;...\u0026quot;\u0026gt; 會好一些\n 無論是 HTML5 history 模式還是 hash 模式，它的表現行為一致，所以，當你要切換路由模式，或者在 IE9 降級使用 hash 模式，無須作任何變動。 在 HTML5 history 模式下，router-link 會守衛點擊事件，讓瀏覽器不再重新加載頁面。 當你在 HTML5 history 模式下使用 base 選項之後，所有的 to 屬性都不需要寫 (基路徑) 了。  \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;nav__left\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;Admin\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/cart\u0026#34;\u0026gt;Cart\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 看到上面的程式碼內容，聰明的你一定知道接著我們要建立三個頁面\n admin 後台管理 購物車頁面  剛剛示範了怎麼在 /views/Home.vue 中引入 src/components/Home.vue\n但在這邊先簡單一點，直接在 /views/ 目錄下建立如同 src/components/Home.vue 內容的檔案\n這時候 /views/ 資料夾應該會長得像這樣\n這時候其實可以把剛剛的 Home.vue 搬移進 /views/ 中，我們原本的引用在這邊有點多此一舉了\n但是在搬移過後會發現瀏覽器提示我們發生了一些問題，原來是 Home.vue 找不到檔案，但是為什麼呢？\n我們不是在 vue-router 裡面指定路徑 \u0026lsquo;/‘ 要到 Home.vue 嗎？\n首先復原程式碼，來看看在哪裡使用到了 src/components/Home.vue？\n哈！原來是一開始我們創建新組建時候把 App.vue 裡面的初始頁面 import 設定成 Home\n這也就說明了為什麼在 admin 以及 Cart 頁面中 Home.vue 的內容還是陰魂不散\n在刪除 import 的內容之後一切就正常了\n新建立的頁面加入路由 接著把剛剛新建的頁面加入路由設定檔案 /src/router/index.js 中\nimport Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import Home from \u0026#39;@/views/Home.vue\u0026#39; import Admin from \u0026#39;@/views/Admin\u0026#39;; import Cart from \u0026#39;@/views/Cart\u0026#39;; Vue.use(Router) const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: Home }, { path: \u0026#39;/admin\u0026#39;, name: \u0026#39;Admin\u0026#39;, component: Admin }, { path: \u0026#39;/cart\u0026#39;, name: \u0026#39;Cart\u0026#39;, component: Cart, }, ] const router = new Router({ routes }) export default router 好像有些什麼東西怪怪的？為什麼可以用 @ 引用東西呢？代表什麼意思？\n在我深入研究後發這是一個 webpack 的設定\n存在於 \\node_modules\\@vue\\cli-service\\lib\\config\\base.js\n進入檔案之後可以發現有設定了一個 alias set('@', api.resolve('src')) 這代表告訴了 vue\n 看到路徑用 @ 開頭的，就從 src 這個目錄開始操作\n 這樣做可以大幅度的減少我們使用 ../ 這種作法造成目錄結構變換就專案大爆炸，或是為了存取深層的檔案，畫面被一堆點點斜線佔滿\n在完成了以上動作之後，打開瀏覽器預覽一下\n看來我們剛剛完成了一個簡單的基於 Vue 的多頁面網站了！\n嵌套路由 有點經驗的工程師就知道，路由絕對不是這麼簡單的\n當頁面少的時候可以全塞在一支檔案裡面，但當頁面開始多這樣就會顯得很亂，並且無法一眼看出彼此之間的階層關聯\n還好 vue-router 提供了嵌套路由的功能，讓我們可以組織化的管理相關聯的頁面\n在後台頁面中會使用到很多操作的頁面，例如新增、修改商品，下面就藉由嵌套路由的方法來管理這些路由\n在引入的地方加入我們之後要增加的頁面，這邊只是先聲明，之後會一步一步的完成頁面\n// Admin Components import Index from \u0026#39;@/views/admin/Index\u0026#39; import New from \u0026#39;@/views/admin/New\u0026#39; import Products from \u0026#39;@/views/admin/Products\u0026#39; import Edit from \u0026#39;@/views/admin/Edit\u0026#39; 路由常數中加入嵌套路由，會發現 Admin 下有四個組件（component）\n而嵌套路由會為相關連的子路由設置一個入口頁面\n然後把這些頁面都放到 children 定義中的陣列中\n{ path: \u0026#39;/admin\u0026#39;, name: \u0026#39;Admin\u0026#39;, component: Index, children: [ { path: \u0026#39;\u0026#39;, name: \u0026#39;Products\u0026#39;, component: Products, }, { path: \u0026#39;new\u0026#39;, name: \u0026#39;New\u0026#39;, component: New, }, { path: \u0026#39;edit/:id\u0026#39;, name: \u0026#39;Edit\u0026#39;, component: Edit, }, ] }, 接著回到 /src/views/admin 建立\n Index.vue Edit.vue New.vue Products.vue  Index.vue Index 是我們上面提到的入口組件，也就是渲染 path = /admin 的基礎組件\n其餘的組件藉由 children 陣列宣告為嵌套的子路由。在子路由內的路由，前端都必須加上父層的路徑\n而在上方的定義中，我們把 /admin/ 的渲染子組件定義給了 Products\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;admin-new\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-3 col-md-3 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;admin-menu\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;View Products\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/new\u0026#34;\u0026gt;New Products\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 是用來渲染子路由的組件，比如說我們進入了 admin/new\n那麼 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 內部會被替換成 New.vue 組件的內容\n因為我們在上面路由定義中定義 \u0026lsquo;/new\u0026rsquo; 的路由渲染組件是 New.vue\nEdit.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit/{{$route.params.id}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Edit 這個路由在剛剛路由定義的時候有點不一樣，他的路徑是 edit/:id 這種寫法被稱作動態路由\n:id 會接收任意的內容作為一個參數傳入。例如我們進入 /admin/edit/banana 頁面\n那麼就可以在 Edit.vue 這個組件上使用\n{{$route.params.id}} 來呼叫到 :id 接收到的值，在上面的例子中就是「banana」\nNew.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/New\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Products.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 建立完成之後就完成了嵌套路由的應用\n",
    "ref": "/blog/202007-express-vue-build-ecommerce-02-vue-router/"
  },{
    "title": "[Express+Vue 搭建電商網站] 01- 初始設定",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 初始設定",
    "body": "本篇將使用 vue-ui 建立專案，並且安裝 vue-router\n安裝所需要的環境 在這個練習中我們首先需要的是安裝 npm 以及node\n這部分教學太多了，總之就先去裝起來吧！裝好後使用\nnpm -v # 確定安裝結果 node -v 接著要安裝我們前端所要使用的 vue\nnpm install -g vue-cli 安裝完成後在 terminal 確認安裝結果\nvue --version 新建 vue 專案 這次嘗試使用 Vue-cli 新出的 vue ui 來建立專案，在終端機輸入\nvue ui 就可以起動，根據提示我們開啟 vue-ui 的畫面 按下新增之後選擇指定的位置，根據畫面上提示來建立新專案\n接著就是等待他執行完成，在終端機進到剛剛建立專案的資料夾下會發現一個 vue 專案已經被建立\n根據 README 的說明執行以下指令後，可以打開 http://localhost:8080/ 來預覽執行結果\nnpm install npm run serve 安裝 vue-router 接著還要安裝一個我們會用上的東西：vue-router\n可以選擇下指令，或是同樣的使用 vue-ui 來完成，既然剛剛使用 vue-ui 建立專案，這邊繼續使用 vue-ui 安裝 vue-router\n打開 vue-ui 頁面，最上方搜尋欄的左邊看「新增 vue-router」給他按下去就會開始安裝了 安裝好之後可以進入 main.js 查看，友善的自動安裝已經幫我們引入了呢！\n如此就完成了我們前端 vue 專案的初始設定\n",
    "ref": "/blog/202006-express-vue-build-ecommerce-01-basic-settings/"
  },{
    "title": "About",
    "date": "",
    "description": "關於我",
    "body": "對我來說程式是一種具名的創作，同時也是一個工程師態度的表現\n你寫出怎麼樣的程式碼，別人就怎麼評價你\n Your name shall speak for yourself.\n 喜歡進行技術交流，對社群充滿熱情，積極地參與相關聚會吸收他人的經驗\n同時也樂於分享自身故事，在這條路上接受過太多幫助，也樂於伸出援手成為別人的英雄\n相信透過分享可以讓自己成為更好的人\n",
    "ref": "/about/"
  }]
