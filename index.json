[{
    "title": "Golang 中 Struct 內型別用指針和值的差異和時機",
    "date": "",
    "description": "用範例說明 Struct 中型別用指針和值的差異和時機",
    "body": "之前一直有個疑問「Struct 定義的時候，Type 什麼時候要傳值？什麼時候傳址？」\n網路上看了許多不同專案似乎都有不同的做法，直到最近遇到的問題讓我有了一點想法\n在專案中我們常常先定義 Request 傳入的 Struct\n再利用json.Unmarshal將傳入的 json 轉換成 Struct，以利後續的操作\n以前的 Struct 欄位需要的的預設值都是 false 所以 Type 都是直接傳值\n這次的情境是遇到一個欄位預設值 是 true 就出意外了\n直接用先看程式碼和執行結果\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type John struct { Name string `json:\u0026#34;name\u0026#34;` CanRun bool `json:\u0026#34;canRun\u0026#34;` CanFly bool `json:\u0026#34;canFly\u0026#34;` } type Doe struct { Name string `json:\u0026#34;name\u0026#34;` CanRun *bool `json:\u0026#34;canRun\u0026#34;` CanFly *bool `json:\u0026#34;canFly\u0026#34;` } func main() { var param = []byte(`{\u0026#34;Name\u0026#34;:\u0026#34;John Doe\u0026#34;, \u0026#34;canRun\u0026#34;:true}`) defult := true var john = new(John) json.Unmarshal(param, \u0026amp;john) jsondata, _ := json.Marshal(john) fmt.Println(string(jsondata)) var doe = new(Doe) json.Unmarshal(param, \u0026amp;doe) doejsondata, _ := json.Marshal(doe) fmt.Println(string(doejsondata)) if doe.CanFly == nil { doe.CanFly = \u0026amp;defult } doejsondata, _ = json.Marshal(doe) fmt.Println(string(doejsondata)) } 在範例中有兩個 Struct\n分別是 Type 為布林傳值的 John 和 Type 為布林指標的 Doe\n若CanFly這個欄位是「可選的」，並且預設值是「true」\n範例程式碼中的param模擬當使用者沒有傳入資料時的 Request\n分別指派型別為 John 和 Doe 的變數 使用json.Unmarshal將傳入的 json 字串轉成 Struct 透過json.Marshal轉成 json 字串方便閱讀並列印在畫面上 輸出結果第一行是在結構體中 Type 使用布林值的 John\n當new(John)的時候會自動帶入所謂的 zero value ，布林的預設 zero value 是 false\n而Name和CanRnu都因為有傳入的關係，所以 zero value 被覆寫了\n但是因為CanFly是選填，而使用者未傳入所以依然是 false\n我們無法在後續程式中判斷究竟是 user 傳入 false 還是那是 zero value\n若是在 Struct 中使用「指針」做為型別，則可以看到輸出結果第二行CanFly是 null\n如此就可以在後續使用條件判斷式將預設值設定成「true」\n這就是這次學習到在將 json 字串轉換成 Struct 時會遇到的預設值問題，以及如何用指標來解決這個問題\n",
    "ref": "/blog/202306-different-between-pointer-and-value-for-struct-type-in-golang/"
  },{
    "title": "透過 FFmpeg 轉換影片格式",
    "date": "",
    "description": "轉換 .ts 影片檔案成 .mp4 格式",
    "body": "有時候會透過某些方法把 .M3U8 檔下載回來後會整合成一隻 .ts 為副檔名的檔案\n而電腦通常不能直接播放這種格式，我們可以透過 FFmpeg 轉成常見的 .mp4 檔案便於播放\n安裝 首先我們要下載 FFmpeg，如果是 Mac 使用者可以透過 Homebrew 來安裝\nbrew install ffmpeg 要檢查安裝是否成功，可以使用指令\nffmpeg -version 轉檔 安裝好了之後就是轉檔\n使用以下指令，並且將來源的 .ts 檔案以及轉檔後的儲存位置替換成自己的目標路徑即可\nffmpeg -i /source_path/vedio.ts -acodec copy -vcodec copy -f mp4 /target_path/new_vedio.mp4 執行完就可以在目標路徑看到轉檔好的檔案了！\n再也不需要另外安裝軟體，或是使用線上轉檔服務了\n",
    "ref": "/blog/202301-ffmpeg-video-convert/"
  },{
    "title": "[AWS 101] 什麼是 SNS 和 SQS",
    "date": "",
    "description": "簡單筆記一下 AWS SNS 和 SQS 服務在幹嘛，還有使用情境",
    "body": "Amazon Simple Queue Service (SQS) 和 Amazon Simple Notification Service (SNS) 看起來很像，實際上又不太一樣\n為了更好釐清兩者，就把兩個服務的筆記放在一起比較\nAWS SNS 全名是：Amazon Simple Notification Service\n發佈者系統可以透過 Topics 將事件訊息分散發送至大量訂閱者系統以進行平行處理\n訂閱者包含：\nAmazon SQS 佇列 AWS Lambda 函數 HTTPS 端點 Amazon Kinesis Data Firehose 架構看起來像這樣\n特點 發送即時性的 message 給所有訂閱者 不保存已發送的 message 遵守為發佈/訂閱模式 (Publish/Subscribe Pattern a.k.a Pub/Sub) 模式 AWS SQS 全名是：Amazon Simple Queue Service (SQS)\n是全受管訊息佇列服務，訊息通通送進 Queue 再看後續誰去抓來執行\n屬於一種 Serverless 解決方案\n但執行者可以是 Lambda 也可以是 Laravel 這種非 Serverless 的專案\n類型 針對不同的應用程式需求提供兩種佇列類型\nStandard Queue 應用程式可以處理抵達超過一次且未照順序排列的訊息\n無限輸送量：標準佇列支援每個 API 動作每秒近乎無限個交易數 (TPS) 至少傳遞一次：一個訊息至少傳遞一次，但偶爾會傳遞一個以上的訊息副本 盡力按順序傳遞：訊息偶爾不會按照傳送順序傳遞 FIFO 佇列 當操作和事件的順序很重要或者不能接受重複項目時\n高輸送量：根據預設，FIFO 佇列支援高達每秒 300 個訊息 (每秒 300 次傳送、接收或刪除操作) 恰好處理一次：訊息只會傳遞一次並保持可用狀態，直到消費者(consumer)處理訊息並將之刪除 先入先出傳送：嚴格保持訊息傳送和接收的順序 (First In First Out) Poll Short polling 詢問之後會馬上取得結果，即使 queue 裡沒東西也會告訴你沒東西\n需要不斷詢問才能保證取得最新的狀態\n這種方式就像是好像有人一直問你有沒有工作可以做？有沒有工作可以做？有沒有工作可以做\nLong polling 詢問之後除非 timeout 或是 queue 裡面有訊息，否則不會立即取得 response\n減少額外的輪詢以盡量降低成本，同時以最快的速度接收新訊息\n佇列處於空的狀態時，長輪詢請求下一則訊息最多等待 20 秒\n特點 由接收端主動去 poll message 一個 queue 只能對應到一個 consumer consumer 回應 queue 完成處理程序後，才會刪掉message SNS 和 SQS 差異 SNS 新內容更新時發布事件通知給所有訂閱者\n是 Push-Based 的架構，訊息會自動推播給訂閱者\n簡單來說就是廣播通知 SQS 將 Queue 任務從程式碼中分離\n是 Pull-Based 的架構，消費者 (consumer) 要自己去 Queue 中抓訊息下來處理\n簡單來說就是 Queue 組合範例 1. 建立 SNS Topic 和 SQS 的方法 進入 SNS 服務，建立 SNS Topic 進入 SQS 服務並建立 SQS 將剛建立的 SQS 訂閱剛建立的 SNS Topic，藉此取得 podcast 內容 在 SQS Dashboard 勾選目標 SQS 後 點選上方Action下拉選單後選擇Subscribe to Amazon SNS topic 選擇剛剛建立的 Topic，並按下Save 2. 模擬 SNS 發送訊息 到 SNS Topic 頁面並選擇 Topic 後，點選右上角Publish message 輸入測試用的內容，並按下Publish message 3. 確認是否收到訂閱訊息 在 SNS Publish message 後，理論上有訂閱 Topic 的全部端點都會收到\n開啟 SQS 頁面, 選擇有訂閱 Topic 的 SQS 點選Send and receive message 往下拉到 Receive messages 區塊並選擇Poll for Messages 成功後就可看到訊息清單出現在下面，並且可以點進去看詳細內容 參考來源：傳送散發事件通知 ",
    "ref": "/blog/202210-aws101-what-is-sns-and-sqs/"
  },{
    "title": "Serverless 簡介",
    "date": "",
    "description": "使用 AWS 服務簡單介紹什麼是 Serverless",
    "body": "因為公司的服務都是基於 AWS，且大量使用各種無伺服器運算服務\n以前完全沒摸過這部分，這系列算筆記整理，內容未來可能會隨時修正\n雖然叫做「無伺服器」但是實際上伺服器還是存在，只是交給雲端平台部署與維運\n對使用者來說只要撰寫程式碼即可！而不用折騰伺服器調校\n後端工程師常常都要兼職管理伺服器，都懂這有多痛苦\n而透過 Serverless 的架構\n只需要寫好設定檔（並掏出老闆的神奇小卡）就可以把基礎設施管理交給雲端服務商\n常見的雲端服務商都有各自的 Serverless 服務\nAWS：Lambda Microsoft Azure：Functions Google：Cloud Functions 而 AWS 提供的 Serverless 相關服務大致上分成這些\nServerless ≠ Lambda Function 這是一個很常見的誤會\n除了 Lambda Function 外，Serverless 也包含事件來源及其他資源的組合\n如 API、資料庫和事件來源對應，以共同執行任務\n而 AWS 提供了 AWS Serverless Application Model(AWS SAM） 是一個用於建置無伺服器應用程式的開源架構\n優點 基本上就是把基礎建設外包給雲端服務商幫你解決\n高可用性：透過自動擴展和負載平衡增加程式的流量彈性與穩定性 減少伺服器閒置效能：依使用量收費，用多少收多少而不用一直開著主機 降低伺服器建置維護人力成本 安全性：不需要顧慮伺服器整體的安全性 缺點 主要來自沒有主機一直在運轉而衍伸出來的問題\ndebug 會有點麻煩，需要用到 log 處理機制：Cloud Watch 無法處理 Schedule job =\u0026gt; Lambda 非 always running 會有啟動時間 Request 無法保證運行在同一個 Lambda 上 =\u0026gt; 是 stateless 的，必須透過其他服務同步狀態 程式架構 透過 lambda 撰寫不同 function 取代原有虛擬主機的一整包集合式程式碼\n可以視為一種 FaaS(Function as a Service)的實作\n大致上的流程是\n來源事件 -\u0026gt; Lambda 函式 -\u0026gt; 服務 以簡單的代辦事項應用程式來說，若是使用 Serverless 的系統架構圖大概就會長這樣\n主要可以關注圖的右邊ToDo App那塊虛線的部分\n該部分符合上面提到的來源事件 -\u0026gt; Lambda 函式 -\u0026gt; 服務流程\n",
    "ref": "/blog/202210-what-is-serverless/"
  },{
    "title": "使用 Golang 和智能合約互動",
    "date": "",
    "description": "藉由 abigen 產出能與智能合約互動的 Go package 來操作合約",
    "body": "之前都是透過 PHP 去呼叫 Smart Contract，這引發兩個問題\n一個是慢，另一個是套件不維護了。而 Golang 有官方套件可以用，速度又快，恰好解決了這兩個問題\n這篇主要是說明如何透過工具把既有的 Smart Contract abi 轉成 Go package 來操作合約\n前置作業 在 mac 環境中要先透過 Homebrew 安裝以下套件\nbrew update brew tap ethereum/ethereum brew install ethereum brew install solidity brew install protobuf 否則之後的步驟會出現\nPlease install solc\nPlease install protoc\n安裝 go-ethereum 接著就是要安裝我們轉換的工具，官方套件自帶的 Abigen 指令可以把 abi 轉成 go package\ngit clone https://github.com/ethereum/go-ethereum.git cd go-ethereum make devtools 產生 Go library file 安裝好之後，當然還要有 contract abi 才能拿來轉換\n關於什麼是 contract abi 不在這篇的主題中，未來如果對合約有更深入的操作再來深入說明\n取得目標合約的 abi.json 之後就可以執行指令\nabigen --abi=\u0026#34;./erc721.abi.json\u0026#34; --type=\u0026#34;erc721\u0026#34; --pkg=erc721 --out=\u0026#34;erc721.go\u0026#34; 參數名稱 說明 範例 \u0026ndash;abi 合約 abi.json 的檔案路徑 ./erc721.abi.json \u0026ndash;type 綁定到 struct 的 type 名稱 erc721 \u0026ndash;pkg 產出檔案的 go package name erc721 \u0026ndash;out 輸出的檔名 erc721.go 於是我們就會得到一個檔名為erc721.go的檔案，點開查看會發現 package 名稱是erc721\n比對裡面的 function 會發現有對應上 abi 中的合約 function\n接著就可以透過引用 package 來操作合約啦！\n在 go 中操作產出的 package 首先在程式中 import 剛剛產出的erc721package\n當然操作區塊鏈不可少的go-ethereum也必須先引入\nimport ( erc721 \u0026#34;project/package-erc721/path\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/common\u0026#34; \u0026#34;github.com/ethereum/go-ethereum/ethclient\u0026#34; ) 然後透過go-ethereum操作智能合約\n以下範例是以操作合約中TotalSupply這個 function 為例\n傳入一個智能合約的 contract address 字串：hexAddress\n就可以得到該合約所發行的總數量，此範例是以 ERC721 的 NFT 合約為例\ninfuraUrl := \u0026#34;https://mainnet.infura.io/v3/38ad7d4b...97aa1d5c583\u0026#34; client, err := ethclient.Dial(infuraUrl) if err != nil { return nil, err } defer client.Close() address := common.HexToAddress(hexAddress) instance, err := erc721.NewErc721(address, client) if err != nil { return nil, err } totalSupply, err := instance.TotalSupply(nil) if err != nil { return nil, err } return totalSupply, nil 以上就是如何使用 abigen 來產生 Smart Contract 對應的 go package\n目前呼叫過的 function 有Owner, OwnerOf, TotalSupply，都有成功取得區塊鏈上資料\n其他的應用待未來有機會操作再來挖掘\n",
    "ref": "/blog/202207-go-ethereum-abigen/"
  },{
    "title": "在 GCP 上建立 Redis 服務",
    "date": "",
    "description": "透過 Google Cloud MemoryStore 建立 Redis 服務",
    "body": "GCP 提供 Google Cloud MemoryStore 服務可用來建立 Redis 或是 Memcached 快取機器服務\n價錢跟開 Database 差不多，原本以為跟 VM 一樣便宜\n建立 Redis 進入MemoryStore頁面點選則「Redis」或是「Memcached」就可以開始建立了\n這邊以 Redis 為例，點選「建立執行個體」\n輸入一些基本設定，基本上就是調整大小跟名稱而已\n照提示選項設定完之後按下「建立執行個體」接著就是等他建立好了\n這邊會要稍微等待，可以稍微去休息一下\n以上就是在 GCP 上建立 Redis 的方法\n只需要將應用程式中的端點對應到 Redis 執行個體的 IP 就可以使用\n也可以直接使用第三方 GUI，比如 Another Redis Desktop Manager 進行 IP 連線來查看執行個體的內容\n",
    "ref": "/blog/202206-gcp-redis/"
  },{
    "title": "讓你的電腦暫時公開在網路上 - Ngrok",
    "date": "",
    "description": "使用 Ngrok 讓你的電腦暫時取得一組對外開放的網址",
    "body": "在開發上有常常會遇到，想要在本機測試但是串接的服務或是 webhook 需要有一個公開的網址作為 callback\n還都要求要有 https 的認證！\n這種時候除了真的去開一台雲端主機外還有沒有其他選擇呢？\nNgrok 做為一個轉發的伺服器，他可以把外界的請求轉發到你指定的 Port\n使用的原理是連接到 ngrok 雲端伺服器，將你本機指定的地址公開\n再將由 ngrok 提供一串公開的網址來存取內容\n優點是快速而且還提供了 https 的服務讓你使用上更安全，甚至你還可以設置密碼保護！\n官方文件與載點 安裝 Mac brew install ngrok Linux 確認自己的主機硬體架構\ncat /proc/cpuinfo 再去官網下載指定檔案依照 官網安裝 方式安裝\n或是直接使用 snap 安裝\nsudo apt update sudo apt install snapd sudo snap install ngrok 啟用服務 輸入指令啟動並監聽 8080 Port\nngrok http 8080 就可以看到對外開放的網址\n註冊 ngrok 沒有註冊也是可以直接使用服務，但是過一段時間就會被斷線，重新啟動會配發一組新的網址\n但是在測試 webhook 或是提供給其他人使用的時候，重新配發網址意味著你要重新設定 webhook 或是通知其他人\n這樣在使用上有諸多不便\n登入 Ngrok 帳號之後前往 Your Authtoken 頁面\n複製 Authtoken 之後到 terminal 輸入\nngrok config add-authtoken {Your Authtoken} 看到以下訊息代表認證完成\nAuthtoken saved to configuration file: /Users/user_name/.ngrok2/ngrok.yml 註冊完成後就可以使用 Ngrok 服務，而不用擔心過一陣子服務被斷線\n",
    "ref": "/blog/202204-ngrok/"
  },{
    "title": "Jenkins 04 在流程中使用 SSH 指令操作另一台 GCP 上的執行個體",
    "date": "",
    "description": "讓 Jenkins 透過 SSH 連線操作遠端主機，代替手動連線部署",
    "body": "在沒有自動化部屬的情境下，每次都需要手動連線到伺服器主機內部\n透過下指令或是執行將部署指令的執行檔，不僅麻煩且有人為失誤的風險\n透過 Jenkins 的 pipeline 來取代人工執行，部署就變得輕鬆又愜意\n安裝套件 沒錯，又双叒叕要安裝套件\n劇透注意：先不要安裝，看到下一段再考慮\n這次要安裝 pipeline 的支援套件：SSH Pipeline Steps 安裝方法和安裝其他套件一樣，在側邊懶選擇管理 Jenkins-\u0026gt;管理外掛程式\n並搜尋 ssh-steps 然後安裝SSH Pipeline StepsVersion套件\n使用 gcloud 登入 然後突然想到之前有裝 gloud，而 gcloud 本身就具有直接透過 SSH 連線到相同專案下其他執行個體的功能！\n不用安裝套件囉！可以可賀\n如果還沒安裝 gcloud 指令的可以參考先前的文章的教學：Jenkins 03 打包 Docker image 並推送到 GCR 能夠使用 gcloud 進行 ssh 指令的前提是你的「身分與存取權管理(IAM)」要有相對應的權限設定\n如果下面步驟中的指令被拒絕就自求多福見招拆招吧，看到一個就加一個\n首先在 jenkins 主機上切換使用者成 jenkins\nsudo su jenkins 並輸入指令\ngcloud compute ssh INTERNAL_INSTANCE_NAME --zone=ZONE --internal-ip 第一次連線的時候會提示你產生及加入 ssh key，這邊最容易發生 IAM 權限不足而被拒絕\n基本上寫不進去，就是看錯誤訊息提示要加什麼權限給先前設定的那組金鑰，然後到 IAM 頁面進行調整\n若 IAM 設定沒問題，照著提示按一按產生 ssh key 後會自動加入 Compute Engine 裡面的中繼資料中\n之後就會直接登入了\n在 pipeline 中使用 gcloud 指令連線 // jenkinsfile pipeline { agent any stages { stage(\u0026#39;Deploy branch: develop to beta\u0026#39;) { when { branch \u0026#39;develop\u0026#39; } steps { echo \u0026#34;ssh to store-beta-api instance.\u0026#34; withCredentials([file(credentialsId: \u0026#39;jenkins-gcr\u0026#39;, variable: \u0026#39;GC_KEY\u0026#39;)]) { sh \u0026#34;gcloud compute ssh store-beta-api --zone=asia-east1-b --internal-ip --command \u0026#39;cd /data/store-backend \u0026amp;\u0026amp; sudo sh ./_scripts/deploy_beta.sh\u0026#39;\u0026#34; } echo \u0026#34;Deploy beta done\u0026#34; } } } } 特別注意的是需要使用--command來指定在遠端下的指令，並且是要連接在一起的\n因為當那行指令執行完就斷開連結了，狀態並不會延續！\n範例中示範了透過 gcloud 指令透過內部靜態 ip 位址進行 SSH 連線\n進入同一個 GCP 專案下位在asia-east1-b地區，名叫store-beta-api的 VM 執行個體\n連線成功後執行了兩個指令，分別是進入/data/store-backend資料夾內\n以及執行資料夾內的./_scripts/deploy_beta.sh執行檔\n在小型服務或是內部測試機環境中，通常都只有啟動一台 VM 執行個體\n透過這個簡單的範例，就可以在觸發條件滿足時自動連線到該主機內部進行部署\n參考資料：gcloud compute ssh ",
    "ref": "/blog/202204-jenkins-cicd-4-ssh-remote-server/"
  },{
    "title": "Jenkins 03 打包 Docker image 並推送到 GCR",
    "date": "",
    "description": "打包 Docker image 並在 pipeline 中使用 gcloud 指令推送到 Google Container Registry 儲存映像檔",
    "body": "Google Container Registry 是 Google 提供用來儲存、管理和保護 Docker 容器映像檔的服務\n這次要做的事是打包 Docker image，再透過 gcloud 指令推送到 GCP 以便未來部署主機時使用\nGCR(Google Container Registry 服務) 首先要先有一個 Google Cloud 專案\n可以根據官方文件：Creating and managing projects 的說明建立\n在 Jenkins 主機安裝 gcloud 以下就照著官方文件：Installing the gcloud CLI 一步一步安裝\n準備工作 先確定有安裝以下套件：apt-transport-https、ca-certificates、gnupg\n可以透過指令列出所有已安裝的套件列表\napt list --installed 如果沒安裝好，使用指令安裝\nsudo apt-get install apt-transport-https ca-certificates gnupg 加入 gcloud CLI 的發行版 URI 作為套件來源 echo \u0026#34;deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main\u0026#34; | sudo tee -a /etc/apt/sources.list.d/google-cloud-sdk.list # 如果不支援 signed-by，則使用 echo \u0026#34;deb https://packages.cloud.google.com/apt cloud-sdk main\u0026#34; | sudo tee -a /etc/apt/sources.list.d/google-cloud-sdk.list 導入 Google Cloud 公鑰 如果apt-key指令支援--keyring參數\ncurl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add - 否則\ncurl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add - 至於 Debian 11+ 或 Ubuntu 21.10+ 不支援apt-key指令的發行版\ncurl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo tee /usr/share/keyrings/cloud.google.gpg 更新並安裝 gcloud CLI sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install google-cloud-cli 初始化 gcloud 因為我們是在 GCP 同專案中的 VM 操作 gcloud，所以省略了gcloud auth login的步驟\n而是直接使用 VM 主機作為登入帳號，若是輸入指令則會詢問你是否繼續\nYou are running on a Google Compute Engine virtual machine. It is recommended that you use service accounts for authentication. You can run: $ gcloud config set account `ACCOUNT` to switch accounts if necessary. Your credentials may be visible to others with access to this virtual machine. Are you sure you want to authenticate with your personal account? Do you want to continue (Y/n)? 查看目前所有專案\ngcloud projects list 如果遇到\nERROR: (gcloud.projects.list) PERMISSION_DENIED: Request had insufficient authentication scopes.\n首先停止運行 VM並進到編輯頁面\n找到存取權範圍並開啟允許所有 Cloud API 的完整存取權\n重新啟動 VM 之後執行指令，照著提示訊息設定\ngcloud init # Your Google Cloud SDK is configured and ready to use! 可以透過指令來確定設定檔內容\ngcloud config configurations list 設定 Jenkins 推送權限 確認 gcloud 指令可以使用後，要設定 Jenkins 對 GCR 的推送權限\n產生 GCP 金鑰 進入 GCP 控制台的API 和服務左方點選憑證頁籤\n點選建立新憑證並選擇服務帳戶\n跟著提示建立好之後點選列表中剛剛建立的帳戶進入編輯頁面\n並且切換到金鑰頁籤中：新增金鑰 -\u0026gt; 建立新的金鑰\n並選擇「JSON」類型\n接著就會跳出下載提示，將 JSON 格式的金鑰下載到本機中\n設定金鑰到 Jenkins 進到Jenkins -\u0026gt; 管理 Jenkins -\u0026gt; Manage Credentials\n選擇作用範圍，這邊用預設的Jenkins也就是全域(global)\n按下 Add Credentials 後Kind選擇Secret file並填寫相關設定\nID：在 Jenkins 中呼叫用的唯一識別 ID，本文章範例中取叫jenkins-gcr File：把剛剛下載的 json 金鑰上傳 如此就完成 Jenkins 金鑰設定\nPipeline 範例 // jenkinsfile pipeline { agent any environment { GCR_HOST = \u0026#34;asia.gcr.io\u0026#34; // GCR 主機位置選離自己近的會比較快，或是直接 gcr.io PROJECT_ID = \u0026#34;my-project-315408\u0026#34; // GCP 專案的 ID FOLDER = \u0026#34;my-project-backend-test\u0026#34; VERSION = \u0026#34;${TAG_NAME}\u0026#34; IMAGE = \u0026#34;$GCR_HOST/$PROJECT_ID/$FOLDER:$VERSION\u0026#34; // 組裝出 image 名稱 } stages { stage(\u0026#39;Build docker image\u0026#39;) { when { branch \u0026#39;main\u0026#39; } steps { // 打包的 docker 指令，指定 dockerfile 在專案中的路徑 sh \u0026#34;docker build . -f ./builds/docker/php81/Dockerfile -t ${IMAGE}\u0026#34; } } stage(\u0026#39;Push image to Google Container Registry\u0026#39;) { when { branch \u0026#39;main\u0026#39; } steps { // jenkins-gcr 就是上面設定過的金鑰唯一識別 ID withCredentials([file(credentialsId: \u0026#39;jenkins-gcr\u0026#39;, variable: \u0026#39;GC_KEY\u0026#39;)]) { sh \u0026#34;cat \u0026#39;$GC_KEY\u0026#39; | docker login -u _json_key --password-stdin https://asia.gcr.io\u0026#34; sh \u0026#34;gcloud auth activate-service-account --key-file=${GC_KEY}\u0026#34; sh \u0026#34;gcloud auth configure-docker\u0026#34; echo \u0026#34;Pushing image to GCR\u0026#34; sh \u0026#34;docker push ${IMAGE}\u0026#34; } } } } } 接著就是觸發 Jenkins 服務，範例中是推送 commit 到 main 的分支上\n檢查儲存位置 若是沒有錯誤訊息，則可以到Google Cloud Registry頁面查看\n把剛剛上傳的 image 名稱想成在 linux 終端機下指令，就可以理解 GCR 中的資料夾結構\n",
    "ref": "/blog/202204-jenkins-cicd-3-push-docker-image-to-gcr/"
  },{
    "title": "伸縮自在的伺服器 02 負載平衡 Load Balancing",
    "date": "",
    "description": "設定 GCP 上的 Load Balancing 打造穩健雲端伺服器",
    "body": "在前一篇伸縮自在的伺服器 01 自動配置 Auto Scaling 中有提到\n我們需要設定一組 Load Balancer 對網際網路的請求分流到不同伺服器主機處理\n這樣可以根據流量彈性調整主機數量，並維持服務穩定運作\n先前建立的執行個體群組是各別具有獨立 IP 的主機\n而透過負載平衡則可以隱藏獨立執行個體的 IP，並且在流量變大時導流到新機器上\n這樣可以保證一定程度的安全和系統穩定性，原有主機不會因為負載過重而崩潰\n建立負載平衡 首先在側邊選單找到網路服務並選擇負載平衡\n按下上方工具列的建立負載平衡器之後選擇HTTP(S)負載平衡\n因為流量是從網際網路傳入，所以選擇從網際網路傳送至 VM 或無伺服器服務\n負載平衡 - 後端設定 接著選擇建立後端服務\n內部溝通用的通訊埠編號通通選擇80，因為我們內部主機沒有掛 SSL 憑證\n負載平衡 - 前端設定 接著到前端設定\n若是我們希望可以透過固定的一組 IP 造訪，則需要在這邊建立一組 IP 位址\n可以預先建立，或是透過畫面提示來預約一組固定 IP 位址 如果你有 SSL 憑證也可以設定在這\n儲存之後等他建立好，點進剛剛建立的負載平衡詳細資訊中\n會看到前端區塊有一個 IP 位置，貼到瀏覽器連看看，就可以看到剛剛設定的服務了！\n於是我們的負載平衡就建置完成！ 配合自動擴展功能，當流量上升到觸發擴展規則時就會啟動新的虛擬主機\n並透過負載平衡將請求分流，達到分擔流量維持服務穩定的功能\n參考文章\n[GCP 教學] 打造彈性、快速且安全的雲端基本服務架構 – 負載平衡 Load Balancer 和 Instance Group GCP VM 雲端主機最基本防護 - Load Balance ",
    "ref": "/blog/202204-gcp-load-balancing/"
  },{
    "title": "介紹 Laravel Sail 和基本操作",
    "date": "",
    "description": "使用 Laravel Sail 啟動專案開發環境，輕鬆愉快",
    "body": "在 Laravel 開發環境建置上官方與非官方都有提供非常多的方式\n這次要介紹的是 Laravel 8 之後加入的套件：Laravel Sail 過去為了節省新手在接觸初期環境建置的時間，有需多套開發環境的工具\n例如透過虛擬機建立的 Laravel Homestead 也有基於 Docker 的開發環境：laradock ，或是像我一樣自己用 Docker 建立 Laravel 開發環境 而在 Laravel 8 之後將 Laravel Sail 加入內建套件，不需要額外安裝\n相較於 Laravel Homestead 來說，因為是使用 Docker 所以需要的資源較少\n而和同樣基於 Docker 環境的 laradock 相比，則是設定較為容易，甚至不需要設定，達到開箱即用\n在使用 Laravel Sail 之前，電腦必須先安裝 Docker\n安裝 Sail 在 Laravel 9 已經內建有 Sail 了，可以直接使用指令啟動服務\nphp artisan sail:install 如果沒有安裝的舊版本 Laravel，則可以透過 composer 進行安裝\ncomposer require laravel/sail --dev 執行指令後會出現互動介面問你想要使用哪些服務\nWhich services would you like to install? [mysql]: [0] mysql [1] pgsql [2] mariadb [3] redis [4] memcached [5] meilisearch [6] minio [7] mailhog [8] selenium \u0026gt; 0,3,7 Sail scaffolding installed successfully. 選擇完之後就會在專案根目錄產生一個docker-compose.yml檔案\n然後就可以使用指令啟動 Sail 服務\n./vendor/bin/sail up 設定指令別名 如果很懶不想打這麼長，可以設定指令的別名\n透過vim ~/.bashrc或vim ~/.zshrc（看你的終端機是使用哪一款）\n在檔案中加入\nalias sail=\u0026#34;./vendor/bin/sail\u0026#34; 接著就可以直接在專案內透過sail別名來執行 Sail 指令，底下都以加入別名後的指令來進行操作\n使用 Sail 使用上跟 Docker 指令很像\nsail up -d：啟動並且在背景執行 sail stop：停止 sail down：停止並刪除容容器 sail build --no-cache：重新建立容器，並忽略快取全部重建 調整映像檔 預設的映像檔包含了 Laravel 基本的環境\n若是想調整，例如想安裝額外的 php extension 則需要導出相關設定\nphp artisan sail:publish 執行完之後專案內會多一個docker資料夾，裡面就是容器用的設定和 Dockerfile\n指行指令 在 Sail 中提供了很方便的方法可以呼叫到各種指令\n基本上就是在各種指令前面加上sail\n執行 PHP 指令 sail php --version 執行 Composer 指令 sail composer install # composer install 執行 Artisan 指令 sail artisan queue:work # php artisan queue:work sail artisan schedule:work # php artisan schedule:work 執行 shell 指令 sail shell myShell.sh # sh myShell.sh 如此簡單就可以建立開發環境，而且也可以操作指令\nLaravel Sail 真的減少很多開發上的麻煩事！\n",
    "ref": "/blog/202204-laravel-sail/"
  },{
    "title": "Jenkins 02 基本 pipeline 建置及串接 Github",
    "date": "",
    "description": "建立一個基本的 pipeline 流程，並透過 Github 的 webhook 觸發建置流程",
    "body": "在 Jenkins 中的建置流程也叫做 pipeline，也可以透過 webhook 觸發建置\n一樣有各種觸發方式和執行方式，底下示範串接 Github webhook 和常見觸發條件範例\n建立第一個 pipeline 側邊欄點選 Open Blue Ocean 來建置新的 pipeline\n依照提示建立 access token，這邊為了示範我把舊的給砍了所以才會出現 Token 被刪除的錯誤訊息\n按下Create an access token here.會開啟 Github 的personal access token建立頁面\n如果自己要找的話是在\nGitHub \u0026gt; settings \u0026gt; Developer settings \u0026gt; Personal access tokens \u0026gt; Generate new token\n基本上他已經帶入需要的權限了，直接按下Generate token\n然後複製產生的 token 貼到 jenkins\n如果這時候沒有複製下來就只能重新產生了！\n驗證完成之後就可以選擇專案\n接著按下創建就會掃瞄 Github Repository 裡面的所有分支了！\n串接 webhook 監聽事件 接著讓我們稍微改一下專案內容並且 commit push 到 github，會發現怎麼 Jenkins 沒動作？\n那是因為我們沒設定讓 Jenkins 監聽 Github 事件！\n那要怎麼設定呢？就是透過 webhook 啦\n當我們設定在 webhook 裡面的事件被觸發，就會推送事件到指定的網址\n要綁定專案 webhook 之後 jenkins 才能收到 github 上的事件\n這個在 Drone 會在建置專案的時候會自動生成，但是 Jenkins 不會\n進入專案的 Settings \u0026gt; Webhook \u0026gt; Add webhook\n在Payload URL填入jenkins主機網址/github-webhook/\n如果 port 不是使用 80 或 443，則要完整輸入。例如 Jenkins 預設使用的是8080port\n按下 Add webhook 新增後會測試連線\n如果失敗，可以再調整後點擊右側三個點的選單，按下Redeliver來重新測試\n接著每次有 push 事件發生（根據 webhook 設定），都會通知 Jenkins\n於是就達成我們想在有 push 新的內容到 Github 的時候觸發 Jenkins 建置流程\n監聽 tag 事件 在版本發佈時我們常常會下tag來指定當前版本，之前使用 Drone 的經驗中\n當 tag 被推送到版本庫，則 webhook 就會發送對應事件\n但是在 Jenkins 並不是這麼一回事，卡了半天簡直氣死！\n最後在官方文件：When using tags in Jenkins Pipeline 中發現\n預設 Jenkins 是沒有建立 tag 監聽的，必須進入你的 pipeline 設定中\n在Branch Sources設定中的Behaviours區塊最下方的Add勾選Discover tags來啟用\n至今我仍然沒參透為什麼要這樣設計\npipeline 基本範例 這邊會基本示範幾種常用的觸發條件的條件判斷，至於觸發後要進行什麼行為之後再來介紹\n首先在專案的根目錄下建立名為jenkinsfile的檔案，預設 Jenkins 會使用這個檔案作為 pipeline 流程\n// jenkinsfile pipeline { agent any stages { stage(\u0026#39;Example Build\u0026#39;) { steps { echo \u0026#39;Hello World\u0026#39; } } stage(\u0026#39;Example Deploy\u0026#39;) { when { branch \u0026#39;production\u0026#39; } steps { echo \u0026#39;Deploying\u0026#39; } } stage(\u0026#39;Example Tag Deploy\u0026#39;) { when { buildingTag() } steps { echo \u0026#34;Building $TAG_NAME\u0026#34; } } stage(\u0026#39;Example Tag Deploy\u0026#39;) { when { tag \u0026#34;release-*\u0026#34; } steps { echo \u0026#34;Building $TAG_NAME\u0026#34; } } } } 這邊示範了四種觸發條件\n沒有 when：不管怎樣都會觸發 when branch：指定分支被推送才會觸發 when buildingTag()：當任何 tag 被建立 when tag \u0026quot;release-*\u0026quot;：只有符合格式的 tag 被建立才會觸發，這邊是release- 開頭的 tag 基本有這四種應該可以玩出很多花樣了\n更多使用方法可以參考官方說明文件：Pipeline Syntax 看了看文件覺得還是 Drone 香，因為 Jenkins 充滿太多「可以這樣做，也可以那樣做」的東西\n在看別人的範例的時候常常會被搞得頭昏腦脹，有的人用 UI 有的人下指令\n不過基本概念還是差不多的，有相關經驗的話知識可以平移借鏡\n基本的 Jenkins pipeline 介紹就到這邊結束\n",
    "ref": "/blog/202203-jenkins-cicd-2-basic-pipeline/"
  },{
    "title": "伸縮自在的伺服器 01 自動配置 Auto Scaling",
    "date": "",
    "description": "設定 GCP 上的 Auto Scaling 讓伺服器更加彈性",
    "body": "建立映像檔 首先要把指定的 VM 停止\n接著在側邊欄找到儲存空間-\u0026gt;映像檔點進去選擇建立映像檔\n不要選成虛擬機器-\u0026gt;機器映像檔不然等等就會鬼打牆選不到！\n一開始自作聰明從 VM 那邊按建立機器映像檔就被送到這個異世界，卡了一下午\n最簡單的判斷方式就是第一步的 VM 不要停止\n建立映像檔的時候如果沒有提醒你要停止就是錯的\n照著提示把映像檔建立完成就可以進行下一步\n建立執行個體範本 Instance templates 進入執行個體範本按下建立執行個體範本\n硬體規則選擇 這邊是決定未來在執行個體群組內，每次啟動新的執行個體所需要的規格\n所以設定的畫面長得跟在建立 VM 的時候的畫面很像\n底下也有防火牆，如果是會用到 80 跟 443 port 的網路服務會就開起來\n選擇 VM 映像檔作為開機範本 不同的是這次我們要用剛剛建立過的映像檔作為範本！\n所以在開機磁碟的地方按下變更-\u0026gt;自訂映像檔並選擇剛剛建立的映像檔\n啟動時自動執行指令 有些時候我們在新的 VM 啟動時需要運行一些指令把服務開啟，例如 docker\n如果沒有再啟動時運行，你的 VM 就只是開了一台機器起來而不會運行 docker daemon\n點開管理的摺疊內容，可以看到自動化的說明\n您可以指定會在執行個體開機或重新啟動時執行的開機指令碼。開機指令碼可用來安裝軟體和更新項目，以及確保服務可在虛擬機器中順利運作\n所以我們在區塊中加入指令，讓 VM 在使用範本啟動時將服務啟動\n#! /bin/bash sudo systemctl start docker sudo docker start laravel-app nginx redis sudo docker exec -i laravel-app /var/www/html/artisan migrate sudo docker exec -i laravel-app /var/www/html/artisan l5-swagger:generate --all sudo docker exec -i laravel-app /usr/bin/supervisord -c ./builds/docker/beta/php81/horizon.conf sudo docker exec -i laravel-app /var/www/html/artisan queue:work \u0026amp; 官方文件：Using startup scripts on Linux VMs 建立執行個體群組 Instance Group 在觸發條件時，執行個體群組會依照剛剛設定的執行個體範本自動配置機器\n首先開啟執行個體群組，按下建立執行個體群組\n介面會看到左邊有三個選項，和網路上現有的文章都不一樣，大概是又改畫面了\nNew managed instance group (stateless) New managed instance group (stateful) New unmanaged instance group 其中只有managed instance group的兩個有 Auto Scaling 的功能\n而unmanaged instance group可以加入既有的 VM 執行個體，不需要先建立執行個體範本\n參考文件：Using managed instance groups 選擇要使用的執行個體範本並制定 Auto Scaling 規則 完成後按下最下方建立就完成執行個體群組的建立以及 Auto Scaling 設定\n設定執行個體群組健康狀態檢查與自動修復 啟動新的執行個體我們要確定他是可用的\n自動讓不可使用的執行個體關閉，並且開新的執行個體取代之\n開啟執行個體群組的編輯頁面，下滑到自動修復區塊\n選擇建立健康健康狀態檢查並設定名稱以及其他設定\n例如通訊協定選擇HTTP的話可以針對特定路由發送請求，預設的TCP則是單純確認傳輸正常\n完成之後就等他跑一下，接著回到執行個體群組詳細頁去查看\n可以看到健康報告，沒意外是一切健康\n輪動式更新 Rolling Update 當有新的映像檔建立後，需要先建立新的執行個體範本(Instance template)\n我們需要回到執行個體群組編輯所使用的執行個體範本，這樣未來啟動新執行個體才會使用新的範本\n修改後並不會直接重啟已經存在的執行個體，若是要達到線上服務無痛轉移\n就是輪動式更新上場的時候！\n到執行個體群組選擇新建立的執行個體群組，並且按下UPDATE VMS\n這個按鈕名字換來換去，就差不多位置找看看\n接著選擇新的執行個體範本，並且更新設定中的Update type要選擇自動\n否則只會在新啟動的 VM 套用新的範例，但是我們想要的是把既有的 VM 也替換成新的！\n可以看到會使用新的執行個體範本啟動一個新的執行個體\n當新的執行個體範本開啟完成之後，才會把舊的執行個體刪除\n如此就達到不影響線上服務而達到無痛升級！\n但是現在服務還不完整，執行個體群組還是個別的獨立主機\n雖然具有自動擴展的能力可以增加主機數量，但也就只是增加可以個別連線的主機而已，並不能自動對請求作分流\n如下圖所示，目前只做完了 Instance Group 以及後面的部分\n我們還需要使用 Load Balance 服務，提供一組負責接收所有請求的固定 IP 位址\n並透過 Load Balance 將流量分流到執行個體群組內個別的主機處理\n這就留到伸縮自在的伺服器 02 自動配置 Load Balancing 中說明\n",
    "ref": "/blog/202203-gcp-auto-scaling/"
  },{
    "title": "Jenkins 01 安裝",
    "date": "",
    "description": "一步一步安裝 Jenkins",
    "body": "使用 Jenkins 建立自己的自動部署服務\nJenkins 是一套以 Java 開發的一套 CI/CD 系統工具\n之前介紹過 Drone ，於是這次就來摸摸 Jenkins 了\n如果使用 docker 安裝，並且想在裡面使用 docker 指令的話會需要處理 docker in docker 問題\n對 docker 和作業系統不太熟的話，建議和我一樣使用直接在主機上安裝的方法\n底下照著官方安裝文件 一步一步安裝\n首先先確定你有裝 java\njava -version sudo apt install openjdk-11-jre 接著就是安裝 Jenkins 服務到主機上，這邊安裝的是穩定版(LTS, Long Term Support)\ncurl -fsSL https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo tee \\ /usr/share/keyrings/jenkins-keyring.asc \u0026gt; /dev/null echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \\ https://pkg.jenkins.io/debian-stable binary/ | sudo tee \\ /etc/apt/sources.list.d/jenkins.list \u0026gt; /dev/null sudo apt-get update sudo apt-get install jenkins 使用指令啟動 jenkins 服務並在瀏覽器輸入localhost:8080後會看到驗證初始密碼的提示\nsudo systemctl enable --now jenkins 可以用指令查看提示路徑中的初始 admin 密碼\nsudo cat /var/lib/jenkins/secrets/initialAdminPassword 外掛安裝 Jenkins預設不支援 pipeline，需要安裝 pipeline 外掛\n這邊我選擇的是：Blue Ocean 為了使用 docker 作為構建流程中的 agent\n還必須安裝兩個擴充功能\nDocker plugin Docker Pipeline 可以在管理外掛程式的地方進行搜尋和安裝\n當然還有就是你 Jenkins 的 Host 主機也要裝好 Docker\ndocker 指令的權限設定 首先先切換到 jenkins 身份\nsudo su jenkins 接著隨便呼叫一個 docker 指令，例如 docker ps\n如果看到權限不足的提示訊息\nGot permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post\n有些文章會告訴你直接sudo chmod 777 /var/run/docker.sock\n不要這麼做！正確做法應該是將 jenkins 加入 docker 使用者群組中\ncat /etc/passwd # 列出所有使用者 sudo groupadd docker # 建立 docker 使用者群組，通常安裝 docker 的就會建立 sudo usermod -aG docker jenkins # 將 jenkins 這個使用者加入 docker 群組 接著重啟 jenkins 服務，可以透過網址列直接輸入網址來觸發重啟\nhttp://jenlins_url/restart\n按下就可以等他重新啟動後就會載入新的設定，就可以在 jenkins 身份下執行 docker 指令了\n",
    "ref": "/blog/202203-jenkins-cicd-1-installation/"
  },{
    "title": "Laravel Queue 使用",
    "date": "",
    "description": "使用佇列，讓不需要馬上處理的任務延遲處理",
    "body": "Queue 臺灣這邊稱作「佇列」，中國那邊的翻譯會用「隊列」\n用處是將一個耗時且不需要即時完成的任務延遲處理，例如寄送電子郵件\n使用者不需要等寄信成功才能進行下一步操作，這樣可以讓應用程式對網頁請求有更快的反應\n開始之前先吐槽一下：真的有人講「佇列」嗎？平常聽到都是直接講 Queue，會不會講佇列反而沒人懂\n所以底下都會直接講 Queue 不會講佇列 eue 算 uwu 的一種變體嗎\n前置作業 在 Laravel 中支援多種 Queue 的驅動\nDatabase Redis Amazon SQS 如果在本機測試，可以將.env中設定成\nQUEUE_CONNECTION=sync 如此就會在送出任務後馬上執行，這樣對於測試 Queue 的程式碼會比較方便\n至於以下會使用database做為驅動做示範\nQUEUE_CONNECTION=database 建立 Queue 用的表 因為 Queue 是 Laravel 提供的功能，所以可以直接藉由指令建立用來紀錄待執行的 Queue 資訊的資料表：Jobs\nphp artisan queue:table php artisan migrate 建立 Job 程式檔案 可以自行建立或是透過指令\nphp artisan make:job SyncBlockchainNftItemJob 這時候會在路徑下產生檔案app/Jobs/SyncBlockchainNftItemJob.php\n寫 Job 程式邏輯 就修改剛剛的SyncBlockchainNftItemJob.php，主要功能寫在handle()裡面\n例如：\npublic function handle() { if ($this-\u0026gt;userId) { Artisan::call(\u0026#34;nft-items:sync $this-\u0026gt;userId\u0026#34;); } } 呼叫一個 Artisan 指令，讓他執行一些東西\n需要的參數可以在 Job 程式檔案中開頭的__construct初始化，未來建立 Queue 任務時作為傳入參數使用\nprotected $userId; public function __construct($userId) { $this-\u0026gt;userId = $userId; } 呼叫 Job 建立任務 現在 Job 準備好啦，要從 Controller 呼叫的話怎麼用呢？\n引入 SyncBlockchainNftItemJob 之後，在想建立任務的地方使用dispatch分派進進指定的 Job 中\n$this-\u0026gt;dispatch(new SyncBlockchainNftItemJob($user-\u0026gt;id)); // 或是更簡潔一點 SyncBlockchainNftItemJob::dispatch($user-\u0026gt;id); 啟動 Queue Worker 如果剛剛不是使用sync作為驅動，則 Queue 是不會被執行的！\n需要使用指令告訴 Queue 開始工作\nphp artisan queue:work 要特別注意的是 Queue Workers 一旦啟動後，程式碼有變更時並不會被更新\n在部署階段，記得使用指令重啟 Queue worker\n否則會持續執行舊版的程式！\nphp artisan queue:restart 檢查啟動狀態 ps -ef|grep queue:work 查看執行狀況 執行 Controller 的程式碼會發現\n當 Queue 被觸發後會在jobs這張表新增一筆紀錄\n而執行時終端機也會有對應的顯示內容\n如果看到Processed代表已經執行完成，這時候jobs中的記錄會被移除\nSupervisor 當 Queue 在運行的時候可能有各種情況造成 Queue 出現致命錯誤，如此的話就無法執行任務\n官方推薦使用 Supervisor 來管理\n當 Queue 非預期情況下停止動作，Supervisor 會根據設定檔重啟 Queue 服務\n達到讓 Job 可以常駐執行的目的！\n映像檔安裝套件 FROM php:7.4-fpm RUN apt-get install supervisor CMD /var/www/html/_scripts/cron.sh 我們最後一行 CMD 執行了一個 cron.sh 當作啟動點，等等會用到\nSupervisor Config 加入檔案在自己喜歡的位置\n# supervisord.conf [program:laravel-worker] process_name=%(program_name)s_%(process_num)02d command=php /var/www/html/artisan queue:work --sleep=90 --tries=3 autostart=true autorestart=true startsecs=5 user=root numprocs=3 redirect_stderr=true stdout_logfile=/var/www/html/storage/logs/supervisord.log stopwaitsecs=3600 [supervisord] logfile=/var/log/supervisor/supervisord_main.log pidfile=/var/www/html/storage/logs/supervisord.pid [supervisorctl] 啟動 Supervisor 在專案中建立剛剛用的_scripts/cron.sh檔案，並且掛載到容器的/var/www/html路徑下\n#!/usr/bin/env bash cd /var/www/html supervisord -c ./docker/cron/supervisord.conf # 使用指定路徑的設定檔啟動 supervisord php /var/www/html/artisan schedule:work # 順便啟動 cronjob 當 Dockerfile 經由CMD執行 shell script 的時候，可以視為執行了\nsh _scripts/cron.sh\n我們在cron.sh裡面做了三件事\n跳到容器的 /var/www/html 路徑中 使用指定的 config 來啟動 supervisord 服務 執行 php artisan schedule:work 如此一來就可以啟動 supervisord 以及 cronjob 服務\n檢查 Supervisor 運行狀態 可以透過指令來確定 supervisord 是否正在執行\npgrep -fl supervisord # 或是 ps aux|grep supervisord 若是出現錯誤訊息顯示ps或是pgrep指令不存在，則需要先透過指令安裝套件\napt-get update \u0026amp;\u0026amp; apt-get install procps 若是看到有出現supervisord則代表已經在運行中了\n",
    "ref": "/blog/202203-laravel-queue/"
  },{
    "title": "使用 ssh 從本機連線到 GCP VM",
    "date": "",
    "description": "在本機透過終端機 ssh 連線到 GCP VM",
    "body": "原先在 GCP 開啟 VM 後每當管理主機時都要先開啟 GCP 控制台頁面，找到指定主機\n按下畫面上的 SSH 連線按鈕，接著開啟 GCP 的終端機畫面\n開啟的步驟實在繁瑣，而且那個終端機也沒有自己本機的用的習慣\n這篇文章說明如何透過本機終端機 ssh 連線到 GCP 主機內\n先前有介紹過一種方法：設定 ssh 金鑰登入遠端主機 缺點就是專案中每一台主機，都要分別設定。這次透過 GCP 設定，讓專案中的主機都可以共用設定\n「達成設定一次，到處可用」的目標\n基本設定 在本機產生 ssh key，使用指令\nssh-keygen 接著複製/.ssh/id_rsa.pub檔案內容，新增進 GCP 的「中繼資料」\n如此一來，整個專案下的所有主機都可以使用這組 key 存取\n再也不需要一台一台設定，人員異動時也更便於管理\n加入之後就完成了，就是這麼簡單\n回到你的本機開啟終端機，輸入\nssh -i ~/.ssh/id_rsa {遠端主機 username}@{遠端主機對外 IP} 出現交互問題時回答yes就可以成功登入遠端主機！\n只有第一次會出現問句，之後就會直接登入了\n快還要更快 剛剛已經可以連線進去主機，但是每次都要去記得 IP 位置很麻煩\n有沒有更快的方法呢？答案當然是有！\n在~/.ssh下新增config檔案，不用打任何副檔名\nHost ssh-test # 用來連線的 alias 名稱 HostName 486.69.87.420 # host domain 或 ip Port 22 # host 的 SSH port (預設是 22 port 可以省略) User ray # 登入 SSH 的 username IdentitiesOnly yes # 使用指定的 key IdentityFile ~/.ssh/id_rsa # 指定的 ssh key 路徑 儲存之後就可以使用Host設定的別名進行連線登入遠端主機\nssh ssh-test 其他用途 除了單純登入主機外，設定這個還有什麼額外的應用呢？\n一般來說要查看 Google Cloud SQL 中的資料庫，要在 GCP 控制台進行連線 連線後還要輸入資料庫密碼\n並且有個明顯的缺點：沒有 GUI\n做什麼都要直接下指令，而且顯示出來的格式很不親民\n如果想要用 GUI 查看，官方的說明是使用 Cloud SQL proxy 這東西實在不好設定，而且需要把資料庫位址公開在網路上\n一般在當資料庫和主機都是使用 GCP 的情況下，可以直接透過 GCP 的內部網路進行連線\n避免設定對外的資料庫 IP 位址讓駭客有機可趁\n有看到關鍵字嗎？「GCP 的內部網路」！\n我們剛剛可以從本機利用 ssh 連線到遠端 GCP VM 中，那就可以利用這個方法存取到同在內部網路的資料庫了\n因為是利用內部網路存取，所以也不需要設定對外的資料庫 IP 位址\n大部分的資料庫 GUI 都有提供 ssh 連線的選項\n遠裡就是先透過上面設定好的 ssh 連線進到主機作為跳板，接著使用「內部網路」對資料庫進行存取\n所以資料庫連線的Host和Username等只要和程式中使用一樣的連線設定即可！\n如此一來絕對是有助於開發速度，不需要特地從 GCP 控制台登入\n",
    "ref": "/blog/202202-connect-to-gcp-vm-using-ssh/"
  },{
    "title": "使用 Prerender 為 SPA 增進 SEO",
    "date": "",
    "description": "解決 CSR 網頁的 SEO 問題，示範自架與 SaaS 方案",
    "body": "Single Page Application(SPA) 網站使用 Client-Side Rendering (CSR) 來渲染畫面\n一開始載入時伺服器只會回傳根元件，透過後續 API 互動取得資料填入\n而網站排名的爬蟲，爬到就會是空空的。雖然 Google 聲稱他們的爬蟲會執行 JS，但是其他搜尋引擎不一定會執行\n所以透過 Prerender 服務來做到預先渲染給網頁爬蟲，達成搜尋結果最佳化\nPrerender 原理是內部起一個 headless 的 chrome 達到預先渲染畫面的效果\n以下會介紹兩個 Prerender 的使用方式\n自架：prerender SaaS 服務：Prerender.io 要自建的話要先建一個反向代理，在 request 進來的時候\n判斷 user agent，機器人的話就把請求發給自己 host 的 prerender 服務\n服務本身有個 headless chrome，所以可以 render 出 HTML 回傳\n如果是一般使用者進來就直接轉發前端伺服器，不做渲染\n使用 Prerender.io 所提供的 SaaS 服務，就會有所限制\n並且超過免費使用的上限就會需要付費，但是就不需要自己管理以及設定服務\n而自建的優點則是擁有更多設定上的自由\n兩個方案可以依照使用情境評估後自行選擇\n若是要使用 Prerender.io 方案，則必須在網站已經上線的情況下才能進行設定\n自架 套件：Prerender 說明寫的其實蠻清楚，就是這麼簡單\n為了表示誠意，底下還是一步一步示範\n1. 安裝 開個資料夾，為了方便我們先取叫prerender\n在資料夾內輸入指令：\nnpm install prerender 就安裝好了\n2. 設定 在 prerender 資料夾中新增一個檔案 server.js\nconst prerender = require(\u0026#39;prerender\u0026#39;); const server = prerender(); server.start(); 3. 啟動 終端機輸入指令啟動服務\nnode server.js 服務會啟動在本機的 3000 port\n如果你的服務也是啟動在 3000 port，就把 port 錯開\n接著在你的前端專案啟動的狀況下開啟終端機，輸入\ncurl \u0026#34;https://www.google.com.tw/\u0026#34; # 你的 SPA 專案網址 會得到空空一片只有根元件的 DOM，因為取得元件內容的 JS 還沒被執行\n這也是 SPA 的 SEO 不好的原因\n雖然 Google 聲稱他們的爬蟲會執行 JS，但是其他搜尋引擎不一定會執行\n接著就是神奇的時刻了，打開終端機輸入\ncurl \u0026#34;http://localhost:3000/render?url=https://www.google.com.tw/\u0026#34; # 你的 SPA 專案網址 拿到一大包渲染過後的結果啦！\n前面網址是 Prerender 服務的網址，然後參數帶上你的專案網址\n就會透過 Prerender 內部啟動的 headless chrome 去渲染畫面再回傳\n快取設定 一般情況下，如果你自己起一個 Prerender 服務\n則每次進行轉發都會重新渲染畫面，但是實務上我們不需要這麼頻繁的重新渲染\n可以藉由設定快取保留渲染結果一段時間\n每次請求進來，如果快取還沒過期就直接回傳快取結果\n不用重新渲染畫面，可以減少服務本身的附載\n使用的快取套件：prerender-memory-cache 1. 安裝 用終端機在剛剛的 prerender 資料夾輸入指令安裝套件\nnpm install prerender-memory-cache --save 2. 設定 打開剛剛 prerender 的 server.js\n在原先檔案的server.start();前加入設定聲明\nserver.use(require(\u0026#39;prerender-memory-cache\u0026#39;)) 就是這麼簡單，第二次請求應該會使用快取的結果\n3. 參數 我們還可以在 prerender 資料夾下使用終端機輸入來設定參數\n快取最大項目數量\nexport CACHE_MAXSIZE=1000 default: 100\n快取存活時間(秒)\nexport CACHE_TTL=600 default: 60\n4. 測試 設定存活時間之後使用終端機去測試\ncurl \u0026#34;http://localhost:3000/render?url=http://localhost:3030/\u0026#34; # 你的 SPA 專案網址 打完第一次之後，去修改自己專案的一些內容（footer, title 之類）\n確認用瀏覽器直接造訪畫面有出現變更\n接著再重新使用終端機測試，應該會出現舊的 HTML 內容\n這就證明他是使用快取的內容，而不是請求一來就重新渲染\n所以剛剛才會建議修改 footer 或是 title，因為比較好確認\n線上服務價錢方案 底下範例使用 Cloudflare Workers 設定 Prerender.io 服務\n因為專案的前端好像有自己的 Nginx 服務，不想介入太多 不然到時候又變我要負責\n而且以前就聽過 Cloudflare Workers 也知道很強大，畢竟就像個 proxy 掛在最前面，所以能做的事情很多\n但是從來沒機會使用，剛好用這次機會摸摸看\nPrerender.io 價錢方案 Cloudflare workers 價錢方案 設定 進到 prerender 頁面，點擊Install middleware後選擇cloudflare選項\n官方已經新增了文件，只要照著文件操作，連不會寫程式的人也可以安心設定了！\n照著文件按圖施工就好：Cloudflare Integration 根據提示打開設定檔的範例：prerender/prerender-cloudflare-worker 就會看到範例的index.js，看起來要改的只有API_KEY和PRERENDERED_DOMAINS\nAPI_KEY：prerender.io 儀表板左上的Token PRERENDERED_DOMAINS：等等會拿來設定路由規則的目標網域 建立一個 Cloudflare worker，把剛剛的設定檔貼上去\n一般的 Worker 可以使用提供的 playground 玩看看\n但是我們使用的是第三方服務，必須經過 Prerender 驗證才會生效\n所以在這邊使用 playground 是無法測試的\n在設定好 Worker 之後，開啟 Worker 頁籤\n選擇新增路由\n接著要設定要求限制失敗模式\n選擇開啟失敗 (繼續)的話，當請求進來而 Worker 失敗則會直接進到服務內\n而關閉失敗 (封鎖)是會噴出錯誤頁面阻止使用者繼續訪問\n由於我們不希望在達到免費方案限制的時候網站就無法存取，且不預先渲染內容不影響網站功能\n所以選擇讓在失敗時跳過 Worker 直接執行，畢竟只是拿來做 prerender，爬蟲這次爬不到就下次再來也不要緊\n路由規則要和你在 Worker 設定的網址一樣\n設定完之後要記得回到 Prerender.io 按下一步進行驗證，接著就是等他自己驗證完成囉\n通常按下驗證過幾秒驗證結果就會出來了\n如果驗證完成後想模擬爬蟲爬取的時候會取得的結果，可以使用\ncurl -A Googlebot \u0026#34;https://{你線上服務網址}\u0026#34; 這樣可以模擬Googlebot爬蟲得到的結果，因為我們在 Worker 的 nginx 設定檔中有指定特定的 user agent\n所以 Cloudflare Worker 會替我們判斷是不是需要轉發給 Prerender.io 服務處理\n如果不加上-A Googlebot參數，則不會轉發進行渲染 會回傳一般使用者造訪網頁時的 CSR 結果，也就是未經渲染的網頁內容\n",
    "ref": "/blog/202201-using-prerender-improve-spa-seo/"
  },{
    "title": "使用 PHP CodeSniffer 檢查 Coding Style",
    "date": "",
    "description": "透過 phpcs 與 phpcbf 檢查並修正 Coding Style",
    "body": "透過 phpcs(PHP Code Sniffer) 檢查程式碼是否符合標準\n使用 phpcbf(PHP Code Beautifier and Fixer) 自動修正不符合標準的程式碼\nPHP CodeSniffer PHP_CodeSniffer 是一套用來檢查程式碼是否符合標準的工具\n包含兩個 PHP script：phpcs, phpcbf\nphpcs：用來檢查 PHP、JavaScript 和 CSS 檔案有沒有符合指定的 Coding Style phpcbf：自動修正不符合標準的程式碼 安裝與使用 如何設定檢查用的配置文件phpcs.xml之前已經在 使用 GrumPHP 做程式碼品質的守門員 介紹過\n就不多花篇幅重複說明\n本機 安裝指令\ncomposer global require \u0026#39;squizlabs/php_codesniffer=*\u0026#39; 如果是的使用者 oh-my-zsh 的話需要額外手動設定\nvim ~/.zshrc 加入\nexport PATH=$HOME/bin:/usr/local/bin:/Users/[your-user-name]/.composer/vendor/bin:$PATH 使用指令重新載入設定並檢查安裝版本\nsource ~/.zshrc which phpcs phpcs --version 變更提示訊息顏色設定 phpcs --config-set colors 1 執行自定義 Coding Style 如果有自己定義的 Coding Style，需要設定執行指定 phpcs.xml 設定檔\nphpcs --standard={/path/to/custom_phpcs.xml} {/path/to/project/or/file} 更換預設 Coding Style phpcs --config-set default_standard ../../phpcs.xml 當然也可以換成其他的 PSR 標準\nphpcs --config-set default_standard PSR2 設定預設 Coding Style 原始預設是 PSR-2，可以換成自己的版本\nphpcs --config-set default_standard ../../phpcs.xml 直接用預設執行檢查和修正格式 phpcs {/path/to/project/or/file} phpcbf {/path/to/project/or/file} 在專案中使用 如果想在專案中配置，並且加入 CI(Continuous integration) 流程中自動執行\n則可以直接加入到專案中，方便統一設定\ncomposer require --dev squizlabs/php_codesniffer ./vendor/bin/phpcs -h ./vendor/bin/phpcbf -h ",
    "ref": "/blog/202201-phpcs/"
  },{
    "title": "第一次在 GCP 開 VM 就成功",
    "date": "",
    "description": "手把手在 Google Cloud Platform (GCP) 啟動第一個 VM 執行個體及相關設定",
    "body": "如何在 Google Cloud Platform (GCP) 上開啟一個 VM 虛擬主機呢？\n聽起來很複雜，實際做起來十分簡單\n過去沒有開主機的經驗，這次就把步驟給記錄下來\n我不想花錢自己開，以前公司也沒開權限給我過\n開新 VM 執行個體 沒什麼要注意的，進到 GCP 後台的VM 執行個體頁面後\n直接選則要的規格，取名後點建立就好\n固定對外 IP 因為每次重啟 VM，對外的 IP 都會變動，為了讓我們的服務有一個固定的 IP\n我們可以將外部 IP 的類型從「臨時」改為「靜態」\n把臨時 IP 固定成靜態 IP 會額外收取一些費用\n首先選擇要調整的 VM 主機，點擊三個點點點形狀的「其他操作項目」選單\n選擇「查看網路詳細資料」\n接著在左方選單選擇「外部 IP 位址」標籤\n在使用者欄位中找到剛剛建立的 VM 執行個體\n可以發現目標的名稱欄位為空\n按下左方的保留，這時候就會要你填名稱了\n填好之後你 VM 主機 IP 就不會因為服務重啟而改變\n開啟對外 port 虛擬主機開好了，也固定對外的 IP 了！來連線吧\n瀏覽器輸入 IP 連線，然後就連不進去！欸？\n網路服務常用 port 預設開啟 VM 的時候只會開啟 ssh 連線用的22port\n如果建立的時候你有選擇防火牆規則，則會套用http-server和https-server這兩個「網路標記」\n如此就可以接收發向80和443兩個 port 的請求\n如果不確定自己原本有沒有開啟，可以進到 VM 的資訊頁面查看「網路標記」區塊\n如果發現沒有開啟，而你想開啟這兩個 port\n點擊 VM 的編輯按鈕，找到防火牆設定\n選取建立時沒勾選的http-server和https-server規則\n套用成功之後就可以接收 80 和 443 port 進來的請求了\n其他 port 有些服務會需要使用到不同的 port，這時候就需要自行設定\n以下用8080port 為例進行設定\n建立防火牆規則 選擇要調整的 VM 主機，最右方三點選單選擇「查看網路詳細資料」進入「虛擬私有雲網路」\n選擇左方「防火牆」選單，並點擊「建立防火牆規則」\n大部分都可以使用預設值，看說明來判斷要不要自己設定\n只有幾個地方需要調整\n目標標記 這個是之後選擇防火牆規則時候用的網路標記\n作用跟設定 80 port 時的http-server一樣，作為識別用途\n來源 IPv4 範圍 設定信任的 IP 位置，如果要公開就設定成 0.0.0.0/0接受全部來源的請求\n通訊協定和埠 為了示範同時開放多個 port 所以加入 8089\n如此就可以指定 tcp 的 8080 與 8089 port 對外開放\n可以看到 port 號之間是用逗號「,」分隔\n若是用減號「-」則可以指定開放一個範圍的 port\n套用防火牆規則 回到 Compute Engine 中選擇要套用規則的 VM 執行個體，點擊編輯按鈕\n手動在網路標記輸入剛剛建立防火牆規則時填寫的目標標記，儲存後就可以套用囉\n",
    "ref": "/blog/202201-gcp-vm-basic/"
  },{
    "title": "[A Tour of Go 學習筆記] 09 併發(concurrency)",
    "date": "",
    "description": "使用官方教學瞭解 Go 的併發",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go 來認識基本的 Golang 使用\n這篇介紹 go 強大的併發（concurrency）\nGoroutine 透過 Go runtime 運作的輕量級的執行緒管理\n會啟動並執行一個新的Goroutine，可以理解為建立了一個新的 Thread\ngo f(x, y, z) 以go開頭來調用函式，可以使指定的函式 f 跑在另一個 Goroutine 上\nf,x,y,z 取自目前的 Goroutine，而main也是執行在同一個 Thread 裡\n下面範例中say(\u0026quot;world\u0026quot;)會開啟另一個執行序，並行於原本的執行序\n而原本的執行序會執行say(\u0026quot;hello\u0026quot;)\n一般情況下會先執行say(\u0026quot;world\u0026quot;)，待執行完才執行say(\u0026quot;hello\u0026quot;)\n如果加上go關鍵字調用say(\u0026quot;world\u0026quot;)，變成go say(\u0026quot;world\u0026quot;)\n會開啟一個新的 Goroutine，而原本的執行序會繼續執行say(\u0026quot;hello\u0026quot;)\n兩個執行緒會同時運行，當 Main Goroutine 執行結束後，其他的 Goroutine 會被強制關閉\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(\u0026#34;world\u0026#34;) say(\u0026#34;hello\u0026#34;) } /* \u0026gt;\u0026gt;\u0026gt; world \u0026gt;\u0026gt;\u0026gt; hello \u0026gt;\u0026gt;\u0026gt; world \u0026gt;\u0026gt;\u0026gt; hello \u0026gt;\u0026gt;\u0026gt; hello \u0026gt;\u0026gt;\u0026gt; world \u0026gt;\u0026gt;\u0026gt; world \u0026gt;\u0026gt;\u0026gt; hello \u0026gt;\u0026gt;\u0026gt; hello */ Channels Channel 是帶有類型的通訊，可以透過 \u0026lt;- 來發送或是接收值\n具有阻塞的特性，可以讓執行緒進行等待\n和 maps 跟 slices 一樣，在使用前必須先建立 channels\nch := make(chan int) 因為 Channel 就像水管一樣，發送和接收會暫停直到另一邊準備完成\n直到另一端完成推入或是拉出的動作後才會繼續往下處理，可以被用在 Goroutines 間同步資料內容\nch \u0026lt;- v // 將 v 發送到 channel ch v := \u0026lt;-ch // 從 ch 接收值，並且指派給 v 以下範例示範了對切片中的數求和，再將任務分配給兩個 Goroutines\n要等到兩個 Goroutines 內的計算都被完成，才會計算出最終結果\npackage main import \u0026#34;fmt\u0026#34; func sum(s []int, ch chan int) { sum := 0 for _, v := range s { sum += v } ch \u0026lt;- sum // send sum to ch } func main() { s := []int{7, 2, 8, -9, 4, 0} ch := make(chan int) go sum(s[:len(s)/2], ch) go sum(s[len(s)/2:], ch) x, y := \u0026lt;-ch, \u0026lt;-ch // receive from ch fmt.Println(x, y, x+y) } /* \u0026gt;\u0026gt;\u0026gt; -5 17 12 */ Buffered Channels Channels 可以帶有緩衝(buffered)，將緩衝長度作為 channel 初始化時候的第二個參數傳入\n前面提到的一般 Channel 具有以下特色\n推入一個資料卻還未拉取資料時，會造成推入方的等待其他 Goroutine 拉出 Goroutine 拉出時 Channel 中沒有資料，會造成拉出方的等待其他 Goroutine 推入 而若是帶上了緩衝，則會變成只會在 Buffered 中資料填滿以後才會阻塞造成等待\n如以下範例中，只有到第101個資料被推入後，推入方的 Goroutine 才會開始進行等待\nch := make(chan int, 100) 緩衝長度代表這個 channel 可以緩衝儲存的資料數量，如果傳入大於緩衝長度的元素數量則會發生deadlock\npackage main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int, 1) ch \u0026lt;- 1 ch \u0026lt;- 2 fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) } /* \u0026gt;\u0026gt;\u0026gt; fatal error: all goroutines are asleep - deadlock! */ 如果有取出就不會發生錯誤\npackage main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int, 1) ch \u0026lt;- 1 fmt.Println(\u0026lt;-ch) ch \u0026lt;- 2 fmt.Println(\u0026lt;-ch) } /* \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt;\u0026gt;\u0026gt; 2 */ Range 和 Close 發送者可以透過close關閉一個 Channel 來表示沒有需要發送的值了\n接收者可以通過第二個參數來測試 Channel 是不是被關閉\n若沒有值可以接收，且 channel 被關閉的話ok會被設為 false\nv, ok := \u0026lt;-ch 如果對一個 channel 做 for 迴圈for i := range c則會不斷從 Channel 接收值，直到他被關閉\npackage main import ( \u0026#34;fmt\u0026#34; ) func fibonacci(n int, c chan int) { x, y := 0, 1 for i := 0; i \u0026lt; n; i++ { c \u0026lt;- x x, y = y, x+y } close(c) } func main() { c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c { fmt.Println(i) } } /* \u0026gt;\u0026gt;\u0026gt; 0 \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt;\u0026gt;\u0026gt; 2 \u0026gt;\u0026gt;\u0026gt; 3 \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt;\u0026gt;\u0026gt; 8 \u0026gt;\u0026gt;\u0026gt; 13 \u0026gt;\u0026gt;\u0026gt; 21 \u0026gt;\u0026gt;\u0026gt; 34 */ 若是向已經關閉的 channel 發送資料會引發panic，所以應該由推入的 Goroutine 執行關閉 Channel\n還有就是 Channel 和檔案不同，通常情況下不需要手動關閉\n只有在必須告訴接收者不再有新的值的時候，例如一個range迴圈，才需要關閉\nSelect 可以透過select處理 Channel 的多種情況，其中包括阻塞時的處理\nselect { case i := \u0026lt;-c: // use i default: // receiving from c would block } 當所有 case 都沒符合的時候會執行default\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for { select { case \u0026lt;-tick: fmt.Println(\u0026#34;tick.\u0026#34;) case \u0026lt;-boom: fmt.Println(\u0026#34;BOOM!\u0026#34;) return default: fmt.Println(\u0026#34; .\u0026#34;) time.Sleep(50 * time.Millisecond) } } } /* \u0026gt;\u0026gt;\u0026gt; . \u0026gt;\u0026gt;\u0026gt; . \u0026gt;\u0026gt;\u0026gt; tick. \u0026gt;\u0026gt;\u0026gt; . \u0026gt;\u0026gt;\u0026gt; . \u0026gt;\u0026gt;\u0026gt; tick. \u0026gt;\u0026gt;\u0026gt; . \u0026gt;\u0026gt;\u0026gt; . \u0026gt;\u0026gt;\u0026gt; tick. \u0026gt;\u0026gt;\u0026gt; . \u0026gt;\u0026gt;\u0026gt; . \u0026gt;\u0026gt;\u0026gt; tick. \u0026gt;\u0026gt;\u0026gt; . \u0026gt;\u0026gt;\u0026gt; . \u0026gt;\u0026gt;\u0026gt; tick. \u0026gt;\u0026gt;\u0026gt; BOOM! */ sync.Mutex 前面我們使用 Channel 讓 Goroutine 之前可以進行溝通傳遞資料\n因為阻塞的特點，當拉取時若沒資料，便會等待其他的 Goroutine 將資料推入 Channel\n那如果我們不使用 Channel，而是直接在多個 Goroutine 之間共用變數的話呢？\n當多個 Goroutine 之間共用變數，同時對一個變數做操作\n便會發生 Race Condition，這時候會沒辦法保證運算結果的正確性\n這牽涉到 互斥(mutual exclusion) 的概念，可以使用 互斥鎖(Mutex) 來避免衝突\nGo 提供了一個 struct：sync.Mutex 提供兩個方法\nLock Unlock 在Lock和Unlock之間的操作，會使其他的 Goroutine 進入等待\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // SafeCounter is safe to use concurrently. type SafeCounter struct { mu sync.Mutex v map[string]int } // Inc increments the counter for the given key. func (c *SafeCounter) Inc(key string) { c.mu.Lock() // Lock so only one goroutine at a time can access the map c.v. c.v[key]++ c.mu.Unlock() } // Value returns the current value of the counter for the given key. func (c *SafeCounter) Value(key string) int { c.mu.Lock() // Lock so only one goroutine at a time can access the map c.v. defer c.mu.Unlock() return c.v[key] } func main() { c := SafeCounter{v: make(map[string]int)} for i := 0; i \u0026lt; 1000; i++ { go c.Inc(\u0026#34;somekey\u0026#34;) } time.Sleep(time.Second) fmt.Println(c.Value(\u0026#34;somekey\u0026#34;)) } /* \u0026gt;\u0026gt;\u0026gt; 1000 */ ",
    "ref": "/blog/202112-a-tour-of-go-09-concurrency/"
  },{
    "title": "[A Tour of Go 學習筆記] 08 interface 和 error",
    "date": "",
    "description": "使用官方教學瞭解 Go interface 和 error",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go 來認識基本的 Golang 使用\n這篇介紹 interface 和 error\ninterface 概念有點像 PHP 裡面的 implement 定義 function name、接收的參數及型別、回傳的值與型別\n並不定義實作方法，而是由繼承的對象個別實作\n然而 Go 沒有繼承的機制，不需要明確的使用implement關鍵字來聲明它實作了哪個 interface\n無論是任何資料型別，只要實作了 interface 裡的定義，就等於自動實作了該 interface\ninterface 型別定義了一組方法，如果某個物件實現了某個介面的所有方法，則此物件就實現了此介面\npackage main import \u0026#34;fmt\u0026#34; type I interface { M() } type T struct { S string } // This method means type T implements the interface I, // but we don\u0026#39;t need to explicitly declare that it does so. func (t T) M() { fmt.Println(t.S) } func main() { var i I = T{\u0026#34;hello\u0026#34;} i.M() } /* \u0026gt;\u0026gt;\u0026gt; hello */ 這種特性也被稱為 Duck type 「當看到一隻鳥走起來像鴨子、游泳起來像鴨子、叫起來也像鴨子，那麼這隻鳥就可以被稱為鴨子。」\n可以解釋為，當一個物件有實作鴨子這個 interface 的所有定義，那他就是鴨子\nerror 在 Go 中使用error來表示錯誤狀態\n和fmt.Stringer類似，error 類型是一個內建(built-in) 的 interface\ntype error interface { Error() string } 通常會讓 function 回傳一個error，並且判斷值是不是nil來進行錯誤處理\ni, err := strconv.Atoi(\u0026#34;42\u0026#34;) if err != nil { fmt.Printf(\u0026#34;couldn\u0026#39;t convert number: %v\\n\u0026#34;, err) return } fmt.Println(\u0026#34;Converted integer:\u0026#34;, i) 當 error 為nil時表示成功；非nil的 error 表示失敗\n",
    "ref": "/blog/202112-a-tour-of-go-08-interface-and-error/"
  },{
    "title": "[A Tour of Go 學習筆記] 07 method",
    "date": "",
    "description": "使用官方教學瞭解 Go method",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go 來認識基本的 Golang 使用\n這篇介紹 method\nmethod Go 不是物件導向，所以沒有 class，但是可以用Type搭配receiver參數來時做出類似功能\n而 method 是一種帶有特殊接收(receiver)參數函數\nreceiver 出現在它自己的參數列表中，位於宣告字串：func和方法名稱之間\n在範例中Abs函數擁有一個 Type 是Vertex並且叫做v的 receiver\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } /* \u0026gt;\u0026gt;\u0026gt; 5 */ 方法即函數 method 就只是具有 receiver 的 function\n底下就是一個一般寫法的 function，功能並沒有什麼變化\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func Abs(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(Abs(v)) } /* \u0026gt;\u0026gt;\u0026gt; 5 */ method 聲明也可以使用非結構化的 type\n只能使用同一個package作用域中聲明過的的type當作receiver\n如果是聲明在其他package中，就算是內建的型別，例如int也不行\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type MyFloat float64 func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } func main() { f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) } /* \u0026gt;\u0026gt;\u0026gt; 1.4142135623730951 */ 指針接收者(Pointer receivers) 你也可以使用指針 receiver 來聲明 method\n型態前加*代表是 Pointer receiver，method 的 receiver type 為指針\n範例程式中，函數Scale的 receiver 就聲明為*Vertex\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} v.Scale(10) fmt.Println(v.Abs()) } /* \u0026gt;\u0026gt;\u0026gt; 50 */ 具有 pointer receiver 的 method，例如上面的Scale可以直接修改變數指向的值，而不是單純的運算\n由於 method 經常會修改 receiver，所以實際應用上比較常使用指針作為 receiver\n如果把上面範例中的Scale的 receiver*刪除，變成一般的 method\n則是會把Vertex的值複製一份，對其進行操作\n如果嘗試執行，得到的結果會是5\n因為v.Scale(10)的執行結果不會影響到main裡面v := Vertex{3, 4}得到的結果，而直接印出5\nPointers and functions 現在我們要把Abs和Scale方法重寫為函數\n之前的範例中v.Scale(10)可以直接調用指針 receiver\n而 function 的寫法參數必須使用\u0026amp;符號聲明傳入指針\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X, Y float64 } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func ScaleFunc(v *Vertex, f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} v.Scale(2) ScaleFunc(\u0026amp;v, 10) p := \u0026amp;Vertex{4, 3} p.Scale(3) ScaleFunc(p, 8) fmt.Println(v, p) } /* \u0026gt;\u0026gt;\u0026gt; {60 80} \u0026amp;{96 72} */ 和前面兩個範例做比較，會發現會注意到帶有參數的 functions 必須傳入一個指針，否則\nvar v Vertex ScaleFunc(v, 5) // Compile error! ScaleFunc(\u0026amp;v, 5) // OK 但是帶有 pointer receiver 的 methods 在被呼叫時可以接受一個值或一個指針\nvar v Vertex v.Scale(5) // OK p := \u0026amp;v p.Scale(10) // OK 對於v.Scale(5)即使v是個值而非指針，帶有 pointer receiver 的 methods 也能被直接呼叫\n也就是說，由於Scale method 有一個 pointer receiver\n為方便起見，Go 會將v.Scale(5)視為(\u0026amp;v).Scale(5)\n同樣的事情也發生在相反的情況，若是對傳值的 function 傳入指針\nvar v Vertex fmt.Println(AbsFunc(v)) // OK fmt.Println(AbsFunc(\u0026amp;v)) // Compile error! 但是作為 method 使用的時候，又可以直接傳入指針\nvar v Vertex fmt.Println(v.Abs()) // OK p := \u0026amp;v fmt.Println(p.Abs()) // OK 因為這種情況下p.Abs()會被解釋為(*p).Abs()\nreceiver 類型怎麼選（值/指針） 通常來說使用「指針」作為 receiver 是因為\nmethod 能夠修改指向的值 避免每次調用的時候複製資料，若使用的 type 是大型 struct 時效率比較好 在範例中Scale和Abs的 receiver 類型為*Vertex，即使Abs並不需要修改 receiver\n通常來說，所有具有類型的 method 都應該要有值或是指針的 receiver，但不該兩者混用\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := \u0026amp;Vertex{3, 4} fmt.Printf(\u0026#34;Before scaling: %+v, Abs: %v\\n\u0026#34;, v, v.Abs()) v.Scale(5) fmt.Printf(\u0026#34;After scaling: %+v, Abs: %v\\n\u0026#34;, v, v.Abs()) } /* \u0026gt;\u0026gt;\u0026gt; Before scaling: \u0026amp;{X:3 Y:4}, Abs: 5 \u0026gt;\u0026gt;\u0026gt; After scaling: \u0026amp;{X:15 Y:20}, Abs: 25 */ ",
    "ref": "/blog/202112-a-tour-of-go-07-method/"
  },{
    "title": "匯入 Excel 或是 csv 檔案到 Laravel",
    "date": "",
    "description": "使用 Laravel-excel 套件匯入 Excel 或是 csv 檔案，並寫入資料庫",
    "body": "在後台介面尚未建置完成，或是使用者有大量資料不想逐筆新增\n而是要透過表單一次性匯入，這時候我們就會用到 Laravel-excel 這個套件\n同時也分享一次匯入大量資料的時候遇到的坑\n目前大部分開發者使用的套件都是：Laravel-excel 支援大多數匯入時候會使用的檔案格式，並且包含很多常用功能\n官方文件寫的也是清楚並且有範例程式碼\n安裝方式 使用指令安裝，會透過 auto-discovered 註冊進 ServiceProvider 和 Facade\n目前最新版本是：Documentation 3.1 composer require maatwebsite/excel 如果需要加入自定義的 config 就執行指令產生config/excel.php\ncomposer require maatwebsite/excel php artisan vendor:publish --provider=\u0026#34;Maatwebsite\\Excel\\ExcelServiceProvider\u0026#34; --tag=config 定義檔案讀入格式 因為 Laravel 自帶的 collection 類型太好用\n所以我們也想把讀取到的表單資料轉成 collection 格式\n首先要先建立資料要載入之後的物件定義，我們假設要匯入的是商品規格的 csv\n所以就建立一個名為app/Imports/ProductImport.php的檔案\n\u0026lt;?php namespace App\\Imports; use Illuminate\\Support\\Collection; use Maatwebsite\\Excel\\Concerns\\ToCollection; class ProductImport implements ToCollection { public $collection; public function collection(Collection $collection) { $this-\u0026gt;collection = $collection-\u0026gt;transform(function ($row) { return collect([ \u0026#39;name\u0026#39; =\u0026gt; $row[1], \u0026#39;main_image\u0026#39; =\u0026gt; $row[2], \u0026#39;author_name\u0026#39; =\u0026gt; $row[3], \u0026#39;material\u0026#39; =\u0026gt; $row[4], \u0026#39;specification\u0026#39; =\u0026gt; $row[5], \u0026#39;description\u0026#39; =\u0026gt; $row[6], ]); }); } } 可以看到我們使用了ToCollection這個 interface\n並且定義了collection和讀取到的表單內容對應\n讀取 csv 檔案 在 controller 呼叫當初藉由 auto-discovered 註冊到 Facade 的Excel來讀取上傳的檔案\n首先是建立物件ProductImport，接著透過 Facade 呼叫Excel套件並使用載入功能\n載入之後透過 collection 的 shift() 方法去除第一列的 header 資料\npublic function uploadCsv(Request $request) { $import = new ProductImport(); Excel::import($import, $request-\u0026gt;file(\u0026#39;file\u0026#39;)); $productCollection = $import-\u0026gt;collection; $productCollection-\u0026gt;shift(); } 如此就可以將上傳的 csv 檔案載入成 collection 來做後續操作\n上傳測試 用 Postman 要測試，只要在 Body 頁籤選擇form-data類性之後\nkey可以名稱的後面下拉選單可以選擇 file 格式\n常見問題 413 Payload Too Large 這個是來自 Nginx 的錯誤訊息，意思是：上傳的檔案太大了，Server 端忍不住\n參考：413 Payload Too Large 解決方法以 PHP 開發環境為例\nNginx config 調整 預設是 2M，如果要傳超過的檔案就必須調整\n打開nginx.conf在 server 段落內加上\nclient_max_body_size 10M; 如此一來請求才會傳入 nginx 內交給 php 執行後續內容\nphp.ini 調整 php.ini 是 php 的各項設定\n其中我們要修改的就是upload_max_filesize這項，預設是 2M\n將其設定的跟 nginx 一樣\nupload_max_filesize = 10M; 如果是使用 Docker 建立環境，則在建立客製的php.ini檔案之後\n將其掛載到容器內指定位置即可\n- ./php/config/php.ini:/usr/local/etc/php/conf.d/php.ini 以上調整都完成之後，對有調整的容器下指令重啟或是重新載入設定檔\n並進入容器內確認設定都有被載入\nPHP 就用 phpinfo()、nginx 就用 nginx -T\nError: 1390 too many placeholders 當你成功把檔案上傳，並且開始執行程式\n在途中把資料印出來檢查都照你預期的方式執行\n於是你開始使用 query builder 組裝要執行的 SQL 語句\n突然！報出一條錯誤訊息\n1390 Prepared statement contains too many placeholders\n這個是來自於 MySQL 的報錯，因為我們使用了：Prepared statement 而 Prepared statement 只支援 65535 (2^16-1) 個參數設定\n如果你今天想要一口氣寫入超級多資料，不論是欄位還是筆數\n只要超過這個數字，就會無法組裝進而報錯\n知道發生的原因之後就很好想出解決辦法了！\n那就是不要一次寫入太多資料\u0026hellip;廢話\n言歸正傳，想要解決這個問題我們可以先將很大量的資料\n比如說內含一萬筆商品內容的陣列切分成 500 筆一組的的多個陣列\n一次執行 500 筆資料的寫入或修改，如此一來就可以避免 too many placeholders 的問題\n在 PHP 中我們會使用 array_chunk 來分割\n$productChunks = array_chunk($products, 500); 執行完之後會得到一個把原始資料每 500 筆切為一包的新陣列\n接著就可以用迴圈把每一組的 500 筆取出來執行\n原本是一個迴圈跑 10,000 筆資料，現在是一次 500 筆跑 20 次\n這就是使用 Laravel-excel 套件來讀取 csv 並且寫入資料庫的方法\n至於匯出檔案就留到下次有實際案例再來說明\n",
    "ref": "/blog/202112-laravel-excel-import/"
  },{
    "title": "[A Tour of Go 學習筆記] 06 Range、Map 和 function",
    "date": "",
    "description": "使用官方教學瞭解 Go Range、Map 和 function",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go 來認識基本的 Golang 使用\n這篇介紹 Range、Map 和 function\nRange 用 for 迴圈的range形式可以遍歷切片或是 map，類似於其他語言的 foreach 用法\n當使用 for 迴圈遍歷切片的時候，每次迭代都會回傳兩個值。第一個值是元素的 index，第二個值是元素內容的副本。\npackage main import \u0026#34;fmt\u0026#34; var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} func main() { for i, v := range pow { fmt.Printf(\u0026#34;2**%d = %d\\n\u0026#34;, i, v) } } /* \u0026gt;\u0026gt;\u0026gt; 2**0 = 1 \u0026gt;\u0026gt;\u0026gt; 2**1 = 2 \u0026gt;\u0026gt;\u0026gt; 2**2 = 4 \u0026gt;\u0026gt;\u0026gt; 2**3 = 8 \u0026gt;\u0026gt;\u0026gt; 2**4 = 16 \u0026gt;\u0026gt;\u0026gt; 2**5 = 32 \u0026gt;\u0026gt;\u0026gt; 2**6 = 64 \u0026gt;\u0026gt;\u0026gt; 2**7 = 128 */ 如果不需要某個值（通常是 index）可以用_來忽略他\n因為 golang 對定義卻沒用的變數很在意，會出錯誤：key declared but not used\nfor i, _ := range pow for _, value := range pow 如果只需要 index，可以直接忽略第二個變數\nfor i := range pow 底下是一個只取 index 的範例：\npackage main import \u0026#34;fmt\u0026#34; func main() { pow := make([]int, 10) for i := range pow { pow[i] = 1 \u0026lt;\u0026lt; uint(i) // 把值設為 index 左移一位元，等於 2 的 i 次方 } for _, value := range pow { fmt.Printf(\u0026#34;%d\\n\u0026#34;, value) } } /* \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt;\u0026gt;\u0026gt; 2 \u0026gt;\u0026gt;\u0026gt; 4 \u0026gt;\u0026gt;\u0026gt; 8 \u0026gt;\u0026gt;\u0026gt; 16 \u0026gt;\u0026gt;\u0026gt; 32 \u0026gt;\u0026gt;\u0026gt; 64 \u0026gt;\u0026gt;\u0026gt; 128 \u0026gt;\u0026gt;\u0026gt; 256 \u0026gt;\u0026gt;\u0026gt; 512 */ Map 前面介紹的不管是陣列或是切片，都是以數字當 index，而 map 可以使用字串作為 index\n用在Key-Value的組合\n在初始化沒有賦值時 map 的初始值(zero value)是nil，一個nil map 沒有 key 也不能加入 key\n使用make函數可以初始化指定型別 map 並回傳\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { Lat, Long float64 } var m map[string]Vertex func main() { m = make(map[string]Vertex) m[\u0026#34;Bell Labs\u0026#34;] = Vertex{ 40.68433, -74.39967, } fmt.Println(m[\u0026#34;Bell Labs\u0026#34;]) } /* \u0026gt;\u0026gt;\u0026gt; {40.68433 -74.39967} */ map 和 struct 類似，但是 key 是必須的\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { Lat, Long float64 } var m = map[string]Vertex{ \u0026#34;Bell Labs\u0026#34;: {40.68433, -74.39967}, \u0026#34;Google\u0026#34;: {37.42202, -122.08408}, } func main() { fmt.Println(m) } /* \u0026gt;\u0026gt;\u0026gt; map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}] */ 如果最頂層的型別只是一種類別名稱，則可以省略不寫\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { Lat, Long float64 } var m = map[string]Vertex{ \u0026#34;Bell Labs\u0026#34;: {40.68433, -74.39967}, \u0026#34;Google\u0026#34;: {37.42202, -122.08408}, } func main() { fmt.Println(m) } /* \u0026gt;\u0026gt;\u0026gt; map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}] */ 修改 map 中的值 在 map 中插入或修改元素\nm[key] = elem 取得元素\nelem = m[key] 刪除元素\ndelete(m, key) 透過雙賦值(two-value assignment)檢查某個鍵值是否存在\nelem, ok = m[key] 如果 key 存在 m 中ok = true，否則ok = false\n若讀取不存在的鍵值時，會得到 map 的元素類型的預設值\n在使用時若elem或是ok還沒被定義，可以使用:做簡短變數聲明\nelem, ok := m[key] 實際操作起來就：\npackage main import \u0026#34;fmt\u0026#34; func main() { m := make(map[string]int) m[\u0026#34;Answer\u0026#34;] = 42 fmt.Println(\u0026#34;The value:\u0026#34;, m[\u0026#34;Answer\u0026#34;]) m[\u0026#34;Answer\u0026#34;] = 48 fmt.Println(\u0026#34;The value:\u0026#34;, m[\u0026#34;Answer\u0026#34;]) delete(m, \u0026#34;Answer\u0026#34;) fmt.Println(\u0026#34;The value:\u0026#34;, m[\u0026#34;Answer\u0026#34;]) v, ok := m[\u0026#34;Answer\u0026#34;] fmt.Println(\u0026#34;The value:\u0026#34;, v, \u0026#34;Present?\u0026#34;, ok) } /* \u0026gt;\u0026gt;\u0026gt; The value: 42 \u0026gt;\u0026gt;\u0026gt; The value: 48 \u0026gt;\u0026gt;\u0026gt; The value: 0 \u0026gt;\u0026gt;\u0026gt; The value: 0 Present? false */ 函數 Function Function values function 也是值，也可以被傳遞\n函數可以作為函數的參數或是回傳值\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func compute(fn func(float64, float64) float64) float64 { return fn(3, 4) } func main() { hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow)) } /* \u0026gt;\u0026gt;\u0026gt; 13 \u0026gt;\u0026gt;\u0026gt; 5 \u0026gt;\u0026gt;\u0026gt; 81 */ 閉包 Function closures Go function 也可以是一個閉包\n閉包是一個函數值，引用了函數本身外部的變數。閉包函數被指定給變數，並且可以存取變數。\n換句話說，閉包函數跟變數被「綁定」在一起。\n範例中的adder這個 function 回傳一個閉包，所以每個sum變數都擁有自己的閉包函數\npackage main import \u0026#34;fmt\u0026#34; func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) } } /* \u0026gt;\u0026gt;\u0026gt; 0 0 \u0026gt;\u0026gt;\u0026gt; 1 -2 \u0026gt;\u0026gt;\u0026gt; 3 -6 \u0026gt;\u0026gt;\u0026gt; 6 -12 \u0026gt;\u0026gt;\u0026gt; 10 -20 \u0026gt;\u0026gt;\u0026gt; 15 -30 \u0026gt;\u0026gt;\u0026gt; 21 -42 \u0026gt;\u0026gt;\u0026gt; 28 -56 \u0026gt;\u0026gt;\u0026gt; 36 -72 \u0026gt;\u0026gt;\u0026gt; 45 -90 */ ",
    "ref": "/blog/202112-a-tour-of-go-06-range-and-map/"
  },{
    "title": "操作 Google 表單，透過 GAS(Google App Script)",
    "date": "",
    "description": "使用 GAS(Google App Script) 服務把 Google 表單當作簡易的資料庫使用",
    "body": "在管理後台尚未建立完成而前台已經上線的時候，會希望可以讓非程式人員自行調整網頁上的文案\n又或是暫時性的紀錄內容不想因此開資料表，通常這時候我們會透過 Google 表單來管理資料\n先把話說在前面，這種做法都是權宜之計！\nGoogle 表單本身限制蠻多的，如果你拿去當正式資料庫絕對會爆炸\n沒爆炸代表你的服務太小，連三公分都不到\n在初期小不是什麼問題，換來的靈活性讓非程式人員在正式編輯介面完成前可以讓自行修改內容\n而不用透過技術人員發布新版程式\n讀取 Google 表單有兩種方式，一種是將表單發佈在網路上\n如此就可以透過網址取得指定輸出類型的表單內容，最常見的就是輸出成 csv 格式\n優點：\n操作簡單，人人都會 不需要額外寫程式，建立好之後可以直接訪問網址取得資料 缺點：\n發佈內容會被 Google 快取：雖然說明寫有修改之後會更新，但是實際更新大概要等個三到五分鐘\n如果你的內容是需要即時存取最新資料做判斷的話會發生問題 至於第二種方式就是為了解決缺點的部分，為此我們要使用 Google 提供的 GAS(Google App Script) 服務\n1. 建立一個google 表單 既然都說要「操作 Google 表單」所以建立一個 Google 表單也是合情合理的吧\n設為共用可查看就好\n2. 建立新 Google App Script 專案 可以在 Google App Script 專案頁面 建立\n或是用在 google sheet 裡面直接開啟擴充功能\n3. Google Script 撰寫 現在已經有了 Google 表單，也知道操作用的程式要寫在哪了\n接著就是要來寫要執行的程式，撰寫時可以參考：官方參考文件 從文件中找到需要的函數來操作 Google 表單\n共用參數說明 有一些很常用的函數先一併說明\ne.parameter 取得傳入的所有參數，後續程式可以用來操作\n使用方式是\nlet params = e.parameter params.sheetTag google sheet 最下面的工作表名稱，作為變數傳入就可以同時寫或是讀多個不同工作表\n使用方式是在取得傳入的所有變數之後呼叫sheetTag\nlet sheetTag = params.sheetTag params.sheetId Google 表單的 ID 用來識別，作為參數傳入就可以區分正式或是測試環境\n用自己的就好了，這份文件我已經刪掉了！\n使用方式是在取得傳入的所有變數之後呼叫sheetId\nlet sheetId = params.sheetId 讀取資料 接下來是說一下怎麼讀取資料\n讀取表單用的 function 名稱一定要叫deGet，所有 get 方法都打到這邊\n呼叫的內建方法可以去查上面提到過的官方文件\n取得最後一欄和最後一列的數字 取得範圍內的所有資料 回傳 json 格式 function doGet(e) { let params = e.parameter let sheetTag = params.sheetTag let sheetId = params.sheetId let SpreadSheet = SpreadsheetApp.openById(sheetId) let Sheet = SpreadSheet.getSheetByName(sheetTag) let lastRow = Sheet.getLastRow() let lastColumn = Sheet.getLastColumn() // getSheetValues(startRow, startColumn, numRows, numColumns) let values = Sheet.getSheetValues(1, 1, lastRow, lastColumn) let jsonString = JSON.stringify(Object.assign({}, values)) return ContentService.createTextOutput(jsonString) } 在寫好doGet之後我們來測試一下是否可以達成預期結果\n在直接發佈之前可以利用內建的測試工具來測試\n在剛剛的 Google App Script 專案下新增一個檔案debugGet.gs\nfunction debug() { var e = { parameter:{ sheetId:\u0026#34;1XuNpMRdZasL8TNovZasd13asd41SoEBo0BMzabGqaE1s\u0026#34;, sheetTag:\u0026#34;todo\u0026#34; } } let result = doGet(e) Logger.log(result.getContent()) } 設定好 Google 表單要傳入資料之後，按下執行\n回傳結果會透過Logger.log顯示在底下執行結果視窗\n寫入資料 傳入 data 是一個 json 字串，將會一筆一筆寫入指定的工作表\n比較特別的是假設資料內容有包含網址，在傳入的時候必須跳脫特殊字元\n而原生 JavaScript 沒有轉回來的函示\n都必須調用 DOM document，但是 GAS 是 server side 的沒得呼叫\n所以就直接用替換的\n傳入的資料從字串轉換為 JSON 物件 遍歷物件將值從第一列根據不同 index 寫入到不同欄位 function doPost(e) { let params = e.parameter // 初始化試算表 let sheetTag = params.sheetTag let sheetId = params.sheetId let SpreadSheet = SpreadsheetApp.openById(sheetId) let Sheet = SpreadSheet.getSheetByName(sheetTag) let data = JSON.parse(params.data) let lastRow = 0 // 寫入試算表 data.forEach(function(value){ with(value) { content = content.replace(/\u0026amp;amp;/g, \u0026#34;\u0026amp;\u0026#34;).replace(/\u0026amp;lt;/g, \u0026#34;\u0026lt;\u0026#34;).replace(/\u0026amp;gt;/g, \u0026#34;\u0026gt;\u0026#34;).replace(/\u0026amp;quot;/g, \u0026#34;\\\u0026#34;\u0026#34;).replace(/\u0026amp;#039;/g, \u0026#34;\u0026#39;\u0026#34;) Sheet.getRange(lastRow + 1, 1).setValue(article_id) Sheet.getRange(lastRow + 1, 2).setValue(content) } lastRow = lastRow + 1 }) return ContentService.createTextOutput(JSON.stringify(true)).setMimeType(ContentService.MimeType.JSON) } 測試方法和 Get 的時候很像，我們新增一個檔案debugGet.gs\nfunction debugPost(){ var processing = { parameter:{ sheetId:\u0026#34;1XuNpMRdZasL8TNovZS09Aing41SoEBo0BMzabGqaE1s\u0026#34;, sheetTag:\u0026#34;processing\u0026#34;, data: \u0026#39;[{\u0026#34;action\u0026#34;:\u0026#34;鐵人賽\u0026#34;,\u0026#34;date\u0026#34;:\u0026#34;2021/09/12\u0026#34;}]\u0026#39;, } } var done = { parameter:{ sheetId:\u0026#34;1XuNpMRdZasL8TNovZS09Aing41SoEBo0BMzabGqaE1s\u0026#34;, sheetTag:\u0026#34;done\u0026#34;, data: \u0026#39;[{\u0026#34;action\u0026#34;:\u0026#34;還書\u0026#34;,\u0026#34;date\u0026#34;:\u0026#34;2021/10/09\u0026#34;}]\u0026#39;, } } let result1 = doPost(processing) let result2 = doPost(done) Logger.log(result1.getContent()) Logger.log(result2.getContent()) } 可以看到我們測試了兩種傳入參數：processing 和 done\n兩者的差異就只有傳入的 sheetTag，代表不同工作表\n下一個範例比較複雜，屬於延伸應用\n輸入邀請碼和使用者 email 檢查該邀請碼是否還有可使用額度(相同邀請碼的後一欄均已經被填入資料，換言之沒有可填入資料的欄位) 檢查該使用者是否登記過邀請碼 寫入資料 / 回傳結果 function doPost(e) { let params = e.parameter let sheetTag = params.sheetTag let sheetId = params.sheetId let SpreadSheet = SpreadsheetApp.openById(sheetId) let Sheet = SpreadSheet.getSheetByName(sheetTag) let invitation_code = params.invitation_code let email = params.email // email 已存在 let user_target_range = Sheet.createTextFinder(email).findNext() if(user_target_range !== null) { return ContentService.createTextOutput(false) } // 撈取全部 invitation_code let ranges = Sheet.createTextFinder(invitation_code).findAll() // 遍歷所有 invitation_code 的結果 let target_row = 0 ranges.every(function(range){ let row_num = range.getRowIndex() let column_value = Sheet.getRange(row_num, 2).getValue() // 取得當前目標的 B 欄內容，如果為空就設定寫入行數 if(column_value == \u0026#39;\u0026#39;) { target_row = row_num return false } return true }) if(target_row !== 0) { Sheet.getRange(target_row, 2).setValue(email) return ContentService.createTextOutput(true) } return ContentService.createTextOutput(false) // 邀請碼額度已經用完 } 測試用的 function\nfunction debugPost(){ let params = { parameter: { sheetId:\u0026#34;1XuNpMRdZasL8TNovZS09Aing41SoEBo0BMzabGqaE1s\u0026#34;, sheetTag:\u0026#34;done\u0026#34;, invitation_code: \u0026#34;5XdxPDdv\u0026#34;, email: \u0026#39;test123@gm.co\u0026#39; } } Logger.log(doPost(params).getContent()); } 從後端呼叫 在測試沒問題之後，就可以按下發佈\n就可以拿到一串 API 的網址，這邊沒有截圖的原因是 Google 整天在改版\n搞不好截圖過幾天就又改位置了\n接著示範怎麼在 PHP 發送請求到 GAS 的 API\nprivate function updateSheet(string $invitation_code): void { $auth_user = auth()-\u0026gt;user(); $user_email = $auth_user-\u0026gt;account; $client = new \\GuzzleHttp\\Client(); $response = $client-\u0026gt;request(\u0026#39;POST\u0026#39;, $this-\u0026gt;gas_url, [ \u0026#39;form_params\u0026#39; =\u0026gt; [ \u0026#39;sheetId\u0026#39; =\u0026gt; $this-\u0026gt;sheetId, \u0026#39;sheetTag\u0026#39; =\u0026gt; $this-\u0026gt;sheetTag, \u0026#39;invitation_code\u0026#39; =\u0026gt; $invitation_code, \u0026#39;email\u0026#39; =\u0026gt; $user_email, ] ]); if ($response-\u0026gt;getStatusCode() != Response::HTTP_OK) { throw new AppException(Response::HTTP_INTERNAL_SERVER_ERROR, \u0026#39;The Sheet Die\u0026#39;); } } 可以看到使用的是form_params來帶入變數，其他就沒什麼需要別注意的了\n最後再說一遍，只有在服務還小的時候可以這樣做\n除了 ACID 這類的考量外，你永遠不知道什麼時候會踩中 Google 的敏感帶\n取回資料後最好就快取在自己的伺服器，不要讓每個請求都去執行 GAS 因為過於頻繁觸發 GAS 有可能會造成 Google 表單無法存取的情形發生\n",
    "ref": "/blog/202111-operate-google-sheet-via-google-app-script/"
  },{
    "title": "[A Tour of Go 學習筆記] 05 陣列和切片",
    "date": "",
    "description": "使用官方教學瞭解 Go 語言陣列和切片",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go 來認識基本的 Golang 使用\n這篇介紹陣列和切片的概念\n[n]T 代表一個擁有n個T型別內容的陣列\n所以陣列中值型別必須一致，而且長度固定\nvar a [10]int // a 是一個長度為 10 的純 int 陣列 package main import \u0026#34;fmt\u0026#34; func main() { var a [2]string a[0] = \u0026#34;Hello\u0026#34; a[1] = \u0026#34;World\u0026#34; fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int{2, 3, 5, 7, 11, 13} fmt.Println(primes) } /* \u0026gt;\u0026gt;\u0026gt; Hello World \u0026gt;\u0026gt;\u0026gt; [Hello World] \u0026gt;\u0026gt;\u0026gt; [2 3 5 7 11 13] */ 這樣感覺起來，陣列超難用的啊\n誰會一開始就想好長度\n別擔心，Go 提供了另一種方便的方法來操作陣列\n切片(slice) 陣列大小固定，而切片則提供動態大小，一般來說比陣列更常使用\n[]T代表一個內容型別是T的切片，透過下界和上界來取得陣列內容的切片\n取得包含 low 但不包含 high 的元素\na[low: high] 以下範例中建立了一個一個a元素從 1 到 3 的切片\npackage main import \u0026#34;fmt\u0026#34; func main() { primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] fmt.Println(s) } /* \u0026gt;\u0026gt;\u0026gt; [3 5 7] */ 切片本身不具有存取的功用，是底層陣列的引用\n所以變更切片的內容，其他使用同樣底層陣列的切片也會受到影響！\npackage main import \u0026#34;fmt\u0026#34; func main() { names := [4]string{ \u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, } fmt.Println(names) a := names[0:2] b := names[1:3] fmt.Println(a, b) b[0] = \u0026#34;XXX\u0026#34; fmt.Println(a, b) fmt.Println(names) } /* \u0026gt;\u0026gt;\u0026gt; [John Paul George Ringo] \u0026gt;\u0026gt;\u0026gt; [John Paul] [Paul George] \u0026gt;\u0026gt;\u0026gt; [John XXX] [XXX George] \u0026gt;\u0026gt;\u0026gt; [John XXX George Ringo] */ 切片可包含任何類型，甚至包含其他的切片\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // 一個井字遊戲模板 board := [][]string{ []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, } // 兩個玩家輪流打上 O 和 X board[0][0] = \u0026#34;X\u0026#34; board[2][2] = \u0026#34;O\u0026#34; board[1][2] = \u0026#34;X\u0026#34; board[1][0] = \u0026#34;O\u0026#34; board[0][2] = \u0026#34;X\u0026#34; for i := 0; i \u0026lt; len(board); i++ { fmt.Printf(\u0026#34;%s\\n\u0026#34;, strings.Join(board[i], \u0026#34; \u0026#34;)) } } /* \u0026gt;\u0026gt;\u0026gt; X _ X \u0026gt;\u0026gt;\u0026gt; O _ X \u0026gt;\u0026gt;\u0026gt; _ _ O */ 切片表示法 切片聲明法類似於沒有長度的陣列\n這是一個陣列聲明\n[3]bool{true, true, false} 這是一個切片表示法\n會先建立和上面一樣的陣列，然後建立一個指向該陣列的切片\n[]bool{true, true, false} package main import \u0026#34;fmt\u0026#34; func main() { q := []int{2, 3, 5, 7, 11, 13} fmt.Println(q) r := []bool{true, false, true, true, false, true} fmt.Println(r) s := []struct { i int b bool }{ {2, true}, {3, false}, {5, true}, {7, true}, {11, false}, {13, true}, } fmt.Println(s) } /* \u0026gt;\u0026gt;\u0026gt; [2 3 5 7 11 13] \u0026gt;\u0026gt;\u0026gt; [true false true true false true] \u0026gt;\u0026gt;\u0026gt; [{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}] */ 切片的預設值 切片的預設值是nil\n一個nil切片的長度和容量為 0，並且沒有底層參照陣列\npackage main import \u0026#34;fmt\u0026#34; func main() { var s []int fmt.Println(s, len(s), cap(s)) if s == nil { fmt.Println(\u0026#34;nil!\u0026#34;) } } /* \u0026gt;\u0026gt;\u0026gt; [] 0 0 \u0026gt;\u0026gt;\u0026gt; nil! */ 切片的預設行為 切片預設忽略上限和下限\n或是說預設下限是 0 上限是切片長度\n假設有一個陣列\nvar a [10]int 那以下切片內容是一樣的\na[0:10] a[:10] a[0:] a[:] 在底下範例中，因為切片會修改參照的陣列\n所以s本身的內容是會被改變的\npackage main import \u0026#34;fmt\u0026#34; func main() { s := []int{2, 3, 5, 7, 11, 13} s = s[1:4] fmt.Println(s) s = s[:2] fmt.Println(s) s = s[1:] fmt.Println(s) } /* \u0026gt;\u0026gt;\u0026gt; [3 5 7] \u0026gt;\u0026gt;\u0026gt; [3 5] \u0026gt;\u0026gt;\u0026gt; [5] */ 切片長度和容量 長度：包含的元素個數 容量：從第一個元素開始數，到底層參照陣列的最後一個元素的數量 長度可以透過 len(s) 取得\n容量可以透過 cap(s) 取得\n被切片過改變過長度的陣列，可以透過重新切片來擴充切片\n給他足夠的容量，前提是原始陣列長度必須足夠\npackage main import \u0026#34;fmt\u0026#34; func main() { s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[:0] printSlice(s) // Extend its length. s = s[:4] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) } func printSlice(s []int) { fmt.Printf(\u0026#34;len=%d cap=%d %v\\n\u0026#34;, len(s), cap(s), s) } /* \u0026gt;\u0026gt;\u0026gt; len=6 cap=6 [2 3 5 7 11 13] \u0026gt;\u0026gt;\u0026gt; len=0 cap=6 [] \u0026gt;\u0026gt;\u0026gt; len=4 cap=6 [2 3 5 7] \u0026gt;\u0026gt;\u0026gt; len=2 cap=4 [5 7] */ 但若是超過底層參照的陣列長度會出現 panic\n假設初始切片長度為 6，而我們在程式中將切片擴充容量到 9\ns := []int{2, 3, 5, 7, 11, 13} s = s[:9] printSlice(s) /* \u0026gt;\u0026gt;\u0026gt; panic: runtime error: slice bounds out of range [:9] with capacity 6 */ 用 make 建立切片 切片可以用 make 建立，這也是建立動態陣列的方法\nmake function 會分配一個內部元素皆為 0 的指定長度陣列，並回傳引用該陣列的切片\n如果要指定容量，需向 make 傳入第三個參數\npackage main import \u0026#34;fmt\u0026#34; func main() { a := make([]int, 5) printSlice(\u0026#34;a\u0026#34;, a) b := make([]int, 0, 5) printSlice(\u0026#34;b\u0026#34;, b) c := b[:2] printSlice(\u0026#34;c\u0026#34;, c) d := c[2:5] printSlice(\u0026#34;d\u0026#34;, d) } func printSlice(s string, x []int) { fmt.Printf(\u0026#34;%s len=%d cap=%d %v\\n\u0026#34;, s, len(x), cap(x), x) } /* \u0026gt;\u0026gt;\u0026gt; a len=5 cap=5 [0 0 0 0 0] \u0026gt;\u0026gt;\u0026gt; b len=0 cap=5 [] \u0026gt;\u0026gt;\u0026gt; c len=2 cap=5 [0 0] \u0026gt;\u0026gt;\u0026gt; d len=3 cap=3 [0 0 0] */ 對切片增加元素 為切片追加新的元素是種經常會使用到的操作\n在 golang 中使用Append來達成，內建方法可以參考：官方文件 append表示式的第一個參數s是一個元素類型為T的切片\n其餘類型為T的值將會被加到原有切片的末尾\nfunc append(s []T, ...T) []T 產生的結果是一個包含元切片所有元素加上新加入元素的切片\n若是s的底層陣列太小，不足以容納所有給定的值的時候\ns會被分派到一個更大的陣列，回傳的切片會指向這個新分配的陣列\n(了解更多關於切片的內容，可以閱讀這篇文章：Go Slices: usage and internals )\npackage main import \u0026#34;fmt\u0026#34; func main() { var s []int printSlice(s) // 加入一個空白的切片 s = append(s, 0) printSlice(s) // 切片會照需求增長 s = append(s, 1) printSlice(s) // 可以一次性增加多個元素 s = append(s, 2, 3, 4) printSlice(s) } func printSlice(s []int) { fmt.Printf(\u0026#34;len=%d cap=%d %v\\n\u0026#34;, len(s), cap(s), s) } /* \u0026gt;\u0026gt;\u0026gt; len=0 cap=0 [] \u0026gt;\u0026gt;\u0026gt; len=1 cap=1 [0] \u0026gt;\u0026gt;\u0026gt; len=2 cap=2 [0 1] \u0026gt;\u0026gt;\u0026gt; len=5 cap=6 [0 1 2 3 4] */ ",
    "ref": "/blog/202111-a-tour-of-go-05-array-and-slice/"
  },{
    "title": "[A Tour of Go 學習筆記] 04 指針和結構",
    "date": "",
    "description": "使用官方教學瞭解 Go 語言指針和結構",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go 來認識基本的 Golang 使用\n這篇介紹指針和結構的使用\n指針(pointer) Go 有指針，指針代表值在記憶體中的位址\n*T代表指向T這個類型的指針，預設值是nil\nvar p *int // p = nil \u0026amp;符號會指向目標的「記憶體位址」\ni := 42 p := \u0026amp;i // p = 0xc000018038 = 變數 i 的指針位置 *可以取得該指針位置代表的「值」\nfmt.Println(*p) // 透過指針 p 取得 i 代表的值 *p = 21 // 透過設定指針位置 p 的值，間接改變 i 這就是常說的「間接引用」或是「重新定向」\npackage main import \u0026#34;fmt\u0026#34; func main() { i, j := 42, 2701 p := \u0026amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = \u0026amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the new value of j } /* \u0026gt;\u0026gt;\u0026gt; 42 \u0026gt;\u0026gt;\u0026gt; 21 \u0026gt;\u0026gt;\u0026gt; 73 */ 結構 (struct) 類似於 JavaScript 的物件，是一堆欄位的集合\n變數儲存單一值，如果需要表是比較複雜的概念例如座標，就可以使用結構\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X int Y int } func main() { fmt.Println(Vertex{1, 2}) } /* \u0026gt;\u0026gt;\u0026gt; {1 2} */ 甚至連訪問方式都很像 JavaScript 的物件，使用.來存取結構中的內容\n注意到了嗎，這邊的X和Y都是大寫的\n代表該內容被導出可以在外部被呼叫！\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X int Y int } func main() { v := Vertex{1, 2} v.X = 4 fmt.Println(v.X) } /* \u0026gt;\u0026gt;\u0026gt; 4 */ 上面提到的指針操作，同樣也適用於 struct 操作\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X int Y int } func main() { v := Vertex{1, 2} p := \u0026amp;v // p 指向 v 的記憶體位置，代表他們是同一個目標 p.X = 1e9 fmt.Println(v) } /* \u0026gt;\u0026gt;\u0026gt; {1000000000 2} */ 創建 struct package main import \u0026#34;fmt\u0026#34; type Vertex struct { X, Y int } var ( v1 = Vertex{1, 2} // 建立型別為 Vertex 的 struct v2 = Vertex{X: 1} // Y:0 是因為 int 型別預設為 0 v3 = Vertex{} // X:0, Y:0 p = \u0026amp;Vertex{3, 2} // 建立型別為 *Vertex 的 struct ) func main() { fmt.Println(v1, v2, v3, p) } /* \u0026gt;\u0026gt;\u0026gt; {1 2} {1 0} {0 0} \u0026amp;{3 2} */ ",
    "ref": "/blog/202111-a-tour-of-go-04-pointer-and-struct/"
  },{
    "title": "[A Tour of Go 學習筆記] 03 流程控制",
    "date": "",
    "description": "使用官方教學瞭解 Go 語言流程控制",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go 來認識基本的 Golang 使用\n這篇是流程控制相關的筆記，說明一些 if else for switch 還有 defer\nfor Go 只有一種迴圈：for\n組成結構是：\n初始值：在第一次迭代之前執行 執行條件：在每次迭代前求值 更新語句：在每次迭代結束時執行 初始值通常是一個簡短變數聲明，該變數只作用於for迴圈內\n一旦執行條件判斷結果為false則迴圈就會被停止\n底下是一個基本的迴圈\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } fmt.Println(sum) } /* \u0026gt;\u0026gt;\u0026gt; 45 */ 初始值和更新語句是可以省略的\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 1 for ; sum \u0026lt; 1000; { sum += sum } fmt.Println(sum) } /* \u0026gt;\u0026gt;\u0026gt; 1024 */ 甚至你可以連分號都省略\n有沒有覺得很眼熟？這就是在 go 語言中實踐while迴圈的方式\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 1 for sum \u0026lt; 1000 { sum += sum } fmt.Println(sum) } /* \u0026gt;\u0026gt;\u0026gt; 1024 */ 如果想要寫出無窮迴圈，只要省略條件判斷迴圈就不會結束\n如此就可以很簡單寫出無限迴圈\npackage main func main() { for { } } if package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func sqrt(x float64) string { if x \u0026lt; 0 { return sqrt(-x) + \u0026#34;i\u0026#34; } return fmt.Sprint(math.Sqrt(x)) } func main() { fmt.Println(sqrt(2), sqrt(-4)) } /* \u0026gt;\u0026gt;\u0026gt; 1.4142135623730951 2i */ 簡短語句 就跟for一樣，if也有簡短的寫法\n可以在條件判斷式之前執行一個簡單的操作\n可以參考底下範例\n要注意的是變數v的作用域只存在if內\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } // 這裡就不能使用 v 了 return lim } func main() { fmt.Println( pow(3, 2, 10), pow(3, 3, 20), ) } /* \u0026gt;\u0026gt;\u0026gt; 9 20 */ else 在if中聲明的變數也可以在對應的else範圍內被使用\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } else { fmt.Printf(\u0026#34;%g \u0026gt;= %g\\n\u0026#34;, v, lim) } // can\u0026#39;t use v here, though return lim } func main() { fmt.Println( pow(3, 2, 10), pow(3, 3, 20), ) } /* \u0026gt;\u0026gt;\u0026gt; 27 \u0026gt;= 20 \u0026gt;\u0026gt;\u0026gt; 9 20 */ switch 和其他語言不同的點是，go 語言中的 switch 不需要break聲明\n只會執行對應的 case，而其他語言會繼續執行後續的所有 case\n在最後可以藉由default定義所有條件都不符合的預設情況\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { fmt.Print(\u0026#34;Go runs on \u0026#34;) switch os := runtime.GOOS; os { case \u0026#34;darwin\u0026#34;: fmt.Println(\u0026#34;OS X.\u0026#34;) case \u0026#34;linux\u0026#34;: fmt.Println(\u0026#34;Linux.\u0026#34;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(\u0026#34;%s.\\n\u0026#34;, os) } } /* \u0026gt;\u0026gt;\u0026gt; Go runs on Linux. */ case中不一定要是常數或是整數，甚至可以在裡面執行計算\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { fmt.Println(\u0026#34;When\u0026#39;s Saturday?\u0026#34;) today := time.Now().Weekday() switch time.Saturday { case today + 0: fmt.Println(\u0026#34;Today.\u0026#34;) case today + 1: fmt.Println(\u0026#34;Tomorrow.\u0026#34;) case today + 2: fmt.Println(\u0026#34;In two days.\u0026#34;) default: fmt.Println(\u0026#34;Too far away.\u0026#34;) } } /* \u0026gt;\u0026gt;\u0026gt; When\u0026#39;s Saturday? \u0026gt;\u0026gt;\u0026gt; Too far away. */ 不設定條件的 switch 就等同於switch true，可以把很長的 if-then-else 變比較好閱讀\n就由上到下比對 case 內條件何者首先為真，就執行內容\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;Good morning!\u0026#34;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026#34;Good afternoon.\u0026#34;) default: fmt.Println(\u0026#34;Good evening.\u0026#34;) } } /* \u0026gt;\u0026gt;\u0026gt; Good evening. */ defer 會將函數延遲到整個方法結束後執行\n但是參數的值會先傳入，等到外層函數執行完成後才會被執行\npackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) } /* \u0026gt;\u0026gt;\u0026gt; hello \u0026gt;\u0026gt;\u0026gt; world */ Stacking defers 如果在迴圈中使用 defer 會發生什麼事情呢？\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;counting\u0026#34;) for i := 0; i \u0026lt; 10; i++ { defer fmt.Println(i) } fmt.Println(\u0026#34;done\u0026#34;) } /* counting done 9 8 7 6 5 4 3 2 1 0 */ 首先可以先判斷迴圈外的兩個Println會先被執行，這很好理解\n接著進入迴圈，從 0 一路執行到 9，並且將印出當前數字送進defer推遲執行\n而實際印出的順序是從 9 印到 0，所以可以推斷defer是一種堆疊\n當多個defer同時存在，則會遵守後進先出(LIFO)來執行\n",
    "ref": "/blog/202111-a-tour-of-go-03-flow-control-statements/"
  },{
    "title": "[A Tour of Go 學習筆記] 02 變數與型別",
    "date": "",
    "description": "使用官方教學瞭解 Go 語言變數與型別",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go 來認識基本的 Golang 使用\n這篇是變數與型別的筆記\n變數 在 Go 語言中使用var來定義變數，並且和函數的參數列表一樣將型別定義在最後\nvar 聲明可以出現在 package 或是 function 的作用域內\npackage main import \u0026#34;fmt\u0026#34; var c, python, java bool func main() { var i int fmt.Println(i, c, python, java) } /* \u0026gt;\u0026gt;\u0026gt; 0 false false false */ 變數預設值 在聲明變數的時後可以定義一個初始值\n如果有定義初始值，在聲明的時候可以省略類型\nGo 會根據初始值來推斷變數的型別，這點十分聰明！\npackage main import \u0026#34;fmt\u0026#34; // 主動定義變數型別 var i, j int = 1, 2 func main() { // 省略型別，透過預設值 var c, python, java = true, false, \u0026#34;no!\u0026#34; fmt.Println(i, j, c, python, java) } /* \u0026gt;\u0026gt;\u0026gt; 1 2 true false no! */ 短變數聲明 在函數內可以使用:=來代替使用var聲明變數\n在函數外部，每個語句都以關鍵字(var、func 等)開頭，不可使用:=\npackage main import \u0026#34;fmt\u0026#34; func main() { var i, j int = 1, 2 k := 3 c, python, java := true, false, \u0026#34;no!\u0026#34; fmt.Println(i, j, k, c, python, java) } /* \u0026gt;\u0026gt;\u0026gt; 1 2 true false no! */ 基本型別 Go 的基本型別有\nbool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 一般來說int、uint和uintptr的長度和系統位元數一樣\n在 32 位元系統中就是 32 位元；在 64 位元系統中就是 64 位元\n當你需要整數的時候直接使用int就好\n除非有明確的理由，否則不應該去限制長度\n可以使用fmt.Printf套件來印出變數的格式化輸出內容，包含型別%T和值%v\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/cmplx\u0026#34; ) var ( ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) func main() { fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, ToBe, ToBe) fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, MaxInt, MaxInt) fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, z, z) } /* \u0026gt;\u0026gt;\u0026gt; Type: bool Value: false \u0026gt;\u0026gt;\u0026gt; Type: uint64 Value: 18446744073709551615 \u0026gt;\u0026gt;\u0026gt; Type: complex128 Value: (2+3i) */ Zero values 如果在聲明變數的時候沒有給定預設值\n那就會被自動賦予 Zero value\n不同型別的 Zero value 分別是\n數值型別：0 布林型別：false 字串型別：\u0026quot;\u0026quot;(空字串) 型別轉換 使用T(v)的形式來將v型別轉換成T\n例如：\nvar i int = 42 var f float64 = float64(i) var u uint = uint(f) 或是可以使用更簡短的表達方式：\ni := 42 f := float64(i) u := uint(f) 常數 和變數的宣告方式很像，只是改為使用const 內容可以是字元、字串、布林、或數值資料 不能使用:=聲明 數值常數(Numeric constants) 一種高精度的數值 根據上下文使用來決定他的數值型別 import \u0026#34;fmt\u0026#34; const ( // 透過將 1 往左移動 100 位數來創造一個很大的數字（二進制中 1 後面接了 100 個 0） Big = 1 \u0026lt;\u0026lt; 100 // 再往左移 99 位元，變成二進制的「10」也就是十進制的 2 Small = Big \u0026gt;\u0026gt; 99 ) func needInt(x int) int { return x*10 + 1 } func needFloat(x float64) float64 { return x * 0.1 } func main() { fmt.Println(needInt(Small)) fmt.Println(needFloat(Small)) fmt.Println(needFloat(Big)) } /* \u0026gt;\u0026gt;\u0026gt; 21 \u0026gt;\u0026gt;\u0026gt; 0.2 \u0026gt;\u0026gt;\u0026gt; 1.2676506002282295e+29 */ 這時候如果印出needInt(Big)會發生什麼事情呢？\nconstant 1267650600228229401496703205376 overflows int\n原來是因為我們所使用的系統中，最長的 int 就是 64-bit(有時候會更少)\n而我們定義的數值常數Big是一個 100 位元的正數，所以就造成了 overflow\n",
    "ref": "/blog/202111-a-tour-of-go-02-variables-and-types/"
  },{
    "title": "[A Tour of Go 學習筆記] 01 Packages 和 Functions",
    "date": "",
    "description": "使用官方教學瞭解 Go 語言基本套件包和函數的基礎",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go 來認識基本的 Golang 使用\n本篇包含基本套件包和函數的基礎\nHello World 第一個就是跑不掉的Hello World\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello World\u0026#34;) } Packages 每個 Go 語言程式都是由 packages 組成\n程式會從 package main開始執行\nimport 底下範例中，引入了fmt和math/rand兩個套件包\n按照慣例 package 的名稱與導入路徑的最後一個元素相同\n例如math/rand中的方法皆以package rand開始\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { fmt.Println(\u0026#34;My favorite number is\u0026#34;, rand.Intn(10)) } 除了將要引入的套件寫在import括弧內的「分組導入」\n還有另一種導入方式是寫成多行的 import，但是分組導入是比較好的做法\npackage main import \u0026#34;fmt\u0026#34; import \u0026#34;math\u0026#34; func main() { fmt.Printf(\u0026#34;Now you have %g problems.\\n\u0026#34;, math.Sqrt(7)) } exported name 在 Go 中如果是以大寫字母開頭，則代表他是被導出的、可以在外部使用的\n例如：Pizza就是一個 exported name，而在math package 裡的Pi也一樣\n而pizza和pi就不是一個 exported name，因為不是使用大寫開頭\n當在使用 package 的時候，你只能呼叫 exported name 的內容\n無法從外部使用任何非導出的內容！\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { fmt.Println(math.Pi) } Functions 和其他語言一樣，一個函數可以不傳入參數或傳入多個參數\n範例中的add函數就接收了兩個int型別的參數\n要注意的是型別是定義在參數「後面」\npackage main import \u0026#34;fmt\u0026#34; func add(x int, y int) int { return x + y } func main() { fmt.Println(add(42, 13)) } /* \u0026gt;\u0026gt;\u0026gt; 55 */ 如果是傳入連續多個同樣型別的參數，可以忽略前面幾個參數的型別宣告\n只在最後一個後宣告，把x int, y int換成x, y int\npackage main import \u0026#34;fmt\u0026#34; func add(x, y int) int { return x + y } func main() { fmt.Println(add(42, 13)) } /* \u0026gt;\u0026gt;\u0026gt; 55 */ 回傳多個值 一個函數可以返回任意數量的結果\npackage main import \u0026#34;fmt\u0026#34; func swap(x, y string) (string, string) { return y, x } func main() { a, b := swap(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) fmt.Println(a, b) } /* \u0026gt;\u0026gt;\u0026gt; world hello */ 也可以對回傳值進行命名\n在函數的最上方將回傳值命名後，會被視為函數內的變數\n不帶任何參數的return會回傳已經命名好的回傳值，也就是直接返回(\u0026ldquo;naked\u0026rdquo; return)\n回傳值命名應具有意義，可以做為文件使用\nNaked return 只應該被用在簡短的函數中，因為在比較長的函數中這麼做會影響程式可讀性\npackage main import \u0026#34;fmt\u0026#34; func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } func main() { fmt.Println(split(19)) } /* \u0026gt;\u0026gt;\u0026gt; 4 5 */ ",
    "ref": "/blog/202111-a-tour-of-go-01-packages-and-functions/"
  },{
    "title": "[Git 教學] 設定本機全域 gitignore",
    "date": "",
    "description": "不要再把編輯器設定檔上傳！我真的不想知道你用什麼編輯器",
    "body": "在開發專案時，你會不會把編輯器自動產生的設定檔加入 .gitignore 裡呢？\n為什麼要把你的個人的環境設定加到專案中呢？\n例如你是用 PhpStorm，就會生出.idea這個資料夾：What is the .idea folder? 如果是用蘋果系統就會有.DS_Store：wiki .DS_Store 個人開發的時候很順手加進.gitignore很方便，乾淨又衛生\n但是當你參與的是多人專案這件事就會變得不合理\n因為一般會加入.gitignore排除在版本控制之外的是一些專案設定檔、金鑰、渲染出來的內容等\n所以把idea和.DS_Store加入到 gitignore 中並不合理，畢竟不是每個人都會需要忽略這些檔案\n其實我們可以在本機的 git 設定檔進行設定，畢竟你的這台電腦不會突然從 Mac 自己變成 Windows\n而在本機環境下將特定的檔案或路徑排除在版本控制，聽起來就合理多了\n操作步驟 1 建立全域 gitignore 用的設定檔 檔名可以隨意，使用終端機下指令\ntouch .gitignore_global 2 加入需要 ignore 的檔案 像 .gitignore 一樣作法，也可以手動開啟檔案編輯\necho /.idea \u0026gt;\u0026gt; .gitignore_global 3 加入設定檔到 .gitconfig 裡面 可以手動修改，也可以使用底下的指令\ngit config --global core.excludesfile ~/.gitignore_global 4 檢查設定是否成功 當然最簡單就是打開專案，把.gitignore裡面對應的設定刪掉啦\n不過還是可以來看看我們剛剛究竟設定了些什麼\n可以使用指令查看或是直接開啟檔案，因為用指令看起來比較高端\n所以我們用指令查看試試\nvim .gitignore_global 可以看到我們想要忽略的檔案列表設定檔，可能有些是初始化 git 的時候就加入的\n只要確認我們剛剛加入的內容有寫入檔案就好\n*~ .DS_Store /.idea 接著查看 git 設定檔有沒有設定\nvim .gitconfig 可以看到在排除的設定檔中有指定給剛剛建立的忽略列表設定檔\n[core] excludesfile = {.gitignore_global 所在路徑} 如此一來就完成了這次的「本機全域 gitignore 設定」\n參考資料：git gitignore ",
    "ref": "/blog/202111-git-global-gitignore/"
  },{
    "title": "[Discord 機器人] 02.擲骰機器人",
    "date": "",
    "description": "建立擲骰子用的 Discord 聊天機器人，使用 Python3",
    "body": "不知道大家知不知道 TTRPG 呢？\n比較有名的大概就是龍與地下城(D\u0026amp;D)吧\n之前看 hololive EN 在玩，就萌生了「來寫個擲骰子 Bot 玩看看好了」的想法\n需求討論 要可以擲多個骰子 骰子的面數要可以自訂 成功判定計算 指令格式\n!roll 5D10\u0026gt;8 這代表：擲 5 個 10 面骰，成功判定是點數大於等於 8\n程式碼 # 導入 Discord.py 套件 import discord # 導入隨機數套件 import random # 取得 Discord client 物件才能操作 client = discord.Client() # 調用 event 函式庫 @client.event # 當機器人完成啟動時在終端機顯示提示訊息 async def on_ready(): print(f\u0026#39;目前登入身份：{client.user}\u0026#39;) # 調用 event 函式庫 @client.event # 當有訊息時 async def on_message(message): # 排除機器人本身發出的訊息，避免機器人自問自答的無限迴圈 if message.author == client.user: return # 預設錯誤訊息 error = [] # 處理輸入文字 content = message.content.replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;).lower() # 如果是「!roll」開頭的訊息 if message.content.startswith(\u0026#39;!roll\u0026#39;): content = content.replace(\u0026#39;!roll\u0026#39;, \u0026#39;\u0026#39;) # 骰子數量計算 dice_cont = content.split(\u0026#39;d\u0026#39;)[0] try: dice_cont = int(dice_cont) except ValueError: error.append(\u0026#39;How many dice you roll must be an interger!\u0026#39;) # 骰子類型判斷 content = content.split(\u0026#39;d\u0026#39;)[1] dice_type = content.split(\u0026#39;\u0026gt;\u0026#39;)[0] try: dice_type = int(dice_type) except ValueError: error.append(\u0026#39;Dice type must be an interger!\u0026#39;) # 成功判斷 if \u0026#39;\u0026gt;\u0026#39; in content: success = content.split(\u0026#39;\u0026gt;\u0026#39;)[1] try: success = int(success) except ValueError: error.append(\u0026#39;Success condition must be an interger!\u0026#39;) else: success = 0 if len(error) == 0: success_count = 0 result_msg = \u0026#39;\u0026#39; # 擲骰子 results = [random.randint(1, dice_type) for _ in range(dice_cont)] for result in results: if success \u0026gt; 0 and result \u0026gt;= success: success_count += 1 result_msg += f\u0026#39;`{result}`, \u0026#39; await message.channel.send(result_msg) if success \u0026gt; 0: await message.channel.send(f\u0026#39;Success: `{success_count}`\u0026#39;) else: await message.channel.send(error) # TOKEN 在 Discord Developer 的「BOT」頁取得 client.run(\u0026#39;\u0026#39;) 程式說明 基本的discord.py使用方法之前寫過就不寫了\n針對邏輯的部份做說明\n輸入訊息偵測 首先透過\nmessage.content.startswith(\u0026#39;!roll\u0026#39;) 只對!roll開頭的訊息做反應\n為了讓使用者不管輸入大小寫或是有沒有空格都可使用\n所以透過\nmessage.content.replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;).lower() 去除空白和全部轉小寫\n如此一來，使用者不論輸入\n!Roll 5 D10 !roll5d10 後續程式都是以!roll5d10做處理\n骰子數量計算 根據輸入訊息的格式，在!roll後面、d前面的「數字」代表骰子數量\n使用\ncontent.replace(\u0026#39;!roll\u0026#39;, \u0026#39;\u0026#39;) 去除字串中的!roll，因為這只是用來觸發機器人，不會影響擲骰子結果\n使用\ncontent.split(\u0026#39;d\u0026#39;)[0] 將字串從d切分，取得列表第一個值，這就是骰子數量\n使用強制轉型判斷取得的值是不是數字？如果不是則轉型出錯會被try except捕獲\n若是被捕獲了，就新增錯誤訊息字串\n骰子類型判斷 和剛剛的數量計算很像，只是這次我們抓取的邏輯是介於d後，\u0026gt;符號前\n如果沒有對應的\u0026gt;符號，則不會分切回傳整個內容\n再藉由跟數量計算一樣的強制轉型判斷取得的類型是否是數字\n若是錯誤，一樣新增錯誤訊息\n成功判斷 因為我們允許使用者在使用指令的時候不輸入成功判斷條件\n所以透過'\u0026gt;' in content:來判斷使用者是否有輸入判斷條件\n如果有輸入的話條件會在\u0026gt;後面，一樣取得值之後判斷是否是數字\n擲骰 我們需要的參數都已經取得了，接下來就是根據條件擲骰並回傳\n首先先檢查前面的錯誤訊息是不是有被建立，如果有代表不該擲骰！\n這時候就直接輸出錯誤訊息到 Discord\n如果錯誤訊息為空，就透過\nresults = [random.randint(1, dice_type) for _ in range(dice_cont)] 取得指定數量的隨機亂數執行結果，用這種方法寫和寫迴圈是一樣的！\n接著遍歷所有結果，整理成輸出到 Discord 想要的格式\n並且如果使用者有輸入擲骰成功的條件，也在這邊計算成功次數\n最後就是輸出擲骰結果和成功次數到 Discord，結果如下\n如此就完成了擲骰機器人的需求\n改進方向 儘管機器人的需求是完成了，但是還有很多可以優化的部分\n函式切分 現在太多邏輯全部寫在一起，應該拆成獨立函數來呼叫\n這樣不論是寫測試或是未來要調整都會比較容易\n輸入判斷邏輯優化 切分邏輯過於簡單，萬一使用者輸入了我們沒想到的內容\n例如!roll6D10d5，雖然程式執行起來會跟!roll6D10一樣\n但是使用者不應該多最後那個d5，這部分該如何處理也是一個可以改進的目標\n",
    "ref": "/blog/202110-make-discord-chatbot-02-roll-dice-bot/"
  },{
    "title": "[Discord 機器人] 01.建立基本機器人",
    "date": "",
    "description": "使用 Python3 建立基本的 Discord 聊天機器人",
    "body": "閒閒沒事，來寫點沒寫過的東西\n最近都在 Discord 活動，就決定寫 Discord ChatBot 啦\n新增 Discord Application 到 Discord Developers Applications 登入 Discord 帳號\n按下New Application命名之後按下Create，名字之後可以改\n左邊Bot進入後點選Add Bot\n點選左邊OAuth2頁籤\nSCOPES中點選bot Bot Permissions 選擇 Administrator 下面就是機器人的邀請連結，可以將機器人邀請到自己的群\n安裝 pip 及 Discord .py 使用指令安裝Discord.py套件\npython3 -m pip install -U discord.py 機器人程式碼 剛剛已經建立機器人，並且把機器人加到自己的群組裡\n下一步就是要來啟動機器人，讓他可以開始做事\n作為範例，我們先寫一個最簡單的機器人試試看運行結果\nroll_dice.py\n# 導入 Discord.py 套件 import discord # 取得 Discord client 物件才能操作 client = discord.Client() # 調用 event 函式庫 @client.event # 當機器人完成啟動時在終端機顯示提示訊息 async def on_ready(): print(f\u0026#39;目前登入身份：{client.user}\u0026#39;) # 調用 event 函式庫 @client.event # 當有訊息時 async def on_message(message): # 排除機器人本身發出的訊息，避免機器人自問自答的無限迴圈 if message.author == client.user: return # 如果我們說了「誰是機器人」，機器人就會回「誰叫我？」 if message.content == \u0026#39;誰是機器人\u0026#39;: await message.channel.send(\u0026#39;誰叫我？\u0026#39;) client.run(\u0026#39;MY APP TOKEN\u0026#39;) 程式說明都寫在範例中了，唯一要解釋的就是 token 要去哪裡拿？\n廢話不多說，上圖！\nTOKEN 在上面 Discord Developer 的BOT頁面中取得\n他不會直接顯示在畫面上，就按Copy就好了，如果堅持要看的話就按下Click to Reveal Token就會顯示\n如果覺得 TOKEN 外洩可以使用 Regenerate 重新產生\n啟動機器人 開啟你的終端機，執行剛剛的 python 檔案\npython roll_dice.py 接著測試指令是不是可以觸發機器人\n看來成功被呼叫了呢！\n",
    "ref": "/blog/202110-make-discord-chatbot-01-set-up/"
  },{
    "title": "[LeetCode] #404 Sum of Left Leaves (Easy)",
    "date": "",
    "description": "LeetCode 第 404 題 Sum of Left Leaves，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Sum of Left Leaves，屬於 Easy\n原始題目 Given the root of a binary tree, return the sum of all left leaves.\nExample 1:\nInput: root = [3,9,20,null,null,15,7] Output: 24 Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively. Example 2:\nInput: root = [1] Output: 0 Constraints:\nThe number of nodes in the tree is in the range [1, 1000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 題目分析 判斷一個二元樹的左子葉總和\n把每個節點送進遞迴函數裡面取得該節點的左節點，並且送進同一個函數取得更深入的左節點\n如果傳入節點的左節點不為空，且該節點的左節點沒有更深入的左節點\n而且該節點的左節點的右節點為空，則找到了一個左子葉\n判斷式長得像：\nif (node-\u0026gt;left != NULL \u0026amp;\u0026amp; node-\u0026gt;left-\u0026gt;left == NULL \u0026amp;\u0026amp; node-\u0026gt;left-\u0026gt;right == NULL) { 找到左子葉 } 解題過程 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumOfLeftLeaves(self, root: Optional[TreeNode]) -\u0026gt; int: if not root: return 0 left_left_leaves_sum = self.sumOfLeftLeaves(root.left) right_left_leaves_sum = self.sumOfLeftLeaves(root.right) cur_left_leaf_val = 0 if root.left and not root.left.left and not root.left.right: cur_left_leaf_val = root.left.val return cur_left_leaf_val + left_left_leaves_sum + right_left_leaves_sum 結果 ",
    "ref": "/blog/202110-leetcode-no404-sum-of-left-leaves/"
  },{
    "title": "[LeetCode] #1013 Partition Array Into Three Parts With Equal Sum (Easy)",
    "date": "",
    "description": "LeetCode 第 1013 題 Partition Array Into Three Parts With Equal Sum，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Partition Array Into Three Parts With Equal Sum，屬於 Easy\n原始題目 Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 \u0026lt; j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])\nExample 1:\nInput: arr = [0,2,1,-6,6,-7,9,1,2,0,1] Output: true Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 Example 2:\nInput: arr = [0,2,1,-6,6,7,9,-1,2,0,1] Output: false Example 3:\nInput: arr = [3,3,6,5,-2,2,5,1,-9,4] Output: true Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 Constraints:\n3 \u0026lt;= arr.length \u0026lt;= 5 * 104 -104 \u0026lt;= arr[i] \u0026lt;= 104 題目分析 一個陣列，當裡面的內容相加可以分成完全相等的三個部分，並且內容都不是空值就會傳 true\n否則回傳 false\n解題過程 可以理解成三等分的每一份恰好等於陣列總和的三分之一，所以不能整除三的就必定是 false\n從陣列開頭累加，當等於三分之一的總和，則切為一份\n繼續計算下一份的累加值，當累加值等於三分之二的總和時，剩下的值總和必然是另外的三分之一，所以可以回傳 true\n若累加沒有達到三分之二則回傳 false\nclass Solution: def canThreePartsEqualSum(self, arr: List[int]) -\u0026gt; bool: s = sum(arr) if s % 3 != 0: return False target = s // 3 n, i, cur = len(arr), 0, 0 while i \u0026lt; n: cur += arr[i] if cur == target: break i += 1 if cur != target: return False j = i + 1 while j + 1 \u0026lt; n: cur += arr[j] if cur == target * 2: return True j += 1 return False 結果 ",
    "ref": "/blog/202110-leetcode-no1013-partition-array-into-three-parts-with-equal-sum/"
  },{
    "title": "[LeetCode] #455 Assign Cookies (Easy)",
    "date": "",
    "description": "LeetCode 第 455 題 Assign Cookies，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Assign Cookies，屬於 Easy\n原始題目 Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] \u0026gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\nExample 1:\nInput: g = [1,2,3], s = [1,1] Output: 1 Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1. Example 2:\nInput: g = [1,2], s = [1,2,3] Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. Constraints:\n1 \u0026lt;= g.length \u0026lt;= 3 * 104 0 \u0026lt;= s.length \u0026lt;= 3 * 104 1 \u0026lt;= g[i], s[j] \u0026lt;= 231 - 1 題目分析 有一串小孩的胃口，和另一串餅乾數量。要滿足最多小孩的胃口\n解題過程 看到這種滿足ＯＯ、讓最多ＸＸ怎樣怎樣的題目，馬上反應使用貪婪演算法\n排序胃口跟餅乾 餅乾從最小到最大，依序餵飽小孩 餵飽後計數器 +1 如果餅乾無法滿足指定的小孩，則跳出迴圈 回傳可滿足的小孩數量 class Solution: def findContentChildren(self, g: List[int], s: List[int]) -\u0026gt; int: g.sort() s.sort() # 可以餵飽的小孩數量 res = 0 # 遍歷所有餅乾 for i in range(len(s)): # 如果可餵飽的數量小於小孩總數，且餅乾大小大於下一個小孩的胃口。則餵飽數量 +1 if res \u0026lt; len(g) and s[i] \u0026gt;= g[res]: res += 1 else: break return res 結果 ",
    "ref": "/blog/202110-leetcode-no455-assign-cookies/"
  },{
    "title": "[LeetCode] #150 Evaluate Reverse Polish Notation (Medium)",
    "date": "",
    "description": "LeetCode 第 150 題 Evaluate Reverse Polish Notation，難度 Medium",
    "body": "用 Python3 解 LeetCode 系列，Evaluate Reverse Polish Notation，屬於 Medium\n原始題目 Evaluate the value of an arithmetic expression in Reverse Polish Notation .\nValid operators are +, -, *, and /. Each operand may be an integer or another expression.\nNote that division between two integers should truncate toward zero.\nIt is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.\nExample 1:\nInput: tokens = [\u0026#34;2\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;*\u0026#34;] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2:\nInput: tokens = [\u0026#34;4\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;+\u0026#34;] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3:\nInput: tokens = [\u0026#34;10\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;-11\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;+\u0026#34;] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 題目分析 這題是使用：逆波蘭表示法 ，兩個值之間的運算符號是表示在兩個值後面\n和一般日常使用寫在中間的表示方式不太一樣 ，遇到運算符才把前面「兩個」數字做運算\n解題過程 遍歷傳入的 Input，如果值不是運算符代表他是要運算的數字。轉換成 int 存進堆疊裡 遇到運算符號的時候，把堆疊最上面的兩個值取出進行運算( python 3.8 沒有 switch case 可以用) class Solution: def evalRPN(self, tokens: List[str]) -\u0026gt; int: stack = [] for value in tokens: # 不是運算符就把值轉成 int 存進 stack 裡 if value not in \u0026#34;+-*/\u0026#34;: stack.append(int(value)) # 防止第二的值就是運算符的防呆 elif len(stack) \u0026gt; 1: # 遇到運算符的時候，取得堆疊最上面兩個值進行運算 num2 = stack.pop() num1 = stack.pop() if value == \u0026#39;+\u0026#39;: stack.append(num1 + num2) elif value == \u0026#39;-\u0026#39;: stack.append(num1 - num2) elif value == \u0026#39;*\u0026#39;: stack.append(num1 * num2) elif value == \u0026#39;/\u0026#39;: # 題目要求除法取整數就好 stack.append(int(num1 / num2)) return stack[-1] 結果 ",
    "ref": "/blog/202109-leetcode-no150-evaluate-reverse-polish-notation/"
  },{
    "title": "[LeetCode] #155 Min Stack (Easy)",
    "date": "",
    "description": "LeetCode 第 155 題 Min Stack，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Min Stack，屬於 Easy\n原始題目 Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\nMinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. Example 1:\nInput [\u0026#34;MinStack\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;getMin\u0026#34;,\u0026#34;pop\u0026#34;,\u0026#34;top\u0026#34;,\u0026#34;getMin\u0026#34;] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 題目分析 設計具有 push, pop, top 操作，並能在常數時間 O(n) 內查詢到最小元素的堆疊\n解題過程 建立一個 list min_stack紀錄堆疊最小值 建立stack list 作為堆疊紀錄 push：把值放進堆疊後面，如果該值小於等於 min_stack 堆疊的最後一筆資料，則一併加入 min_stack 堆疊 pop：從 stack 移除最上面一筆值，如果該值等於 min_stack 最後一筆，一併從堆疊移除 top：取得堆疊最上面一個元素stack[-1] getMin：取得最小值，也就是 min_stack 的最後一個元素min_stack[-1] class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -\u0026gt; None: self.stack.append(val) if not self.min_stack or val \u0026lt;= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -\u0026gt; None: if self.stack.pop() == self.min_stack[-1]: self.min_stack.pop() def top(self) -\u0026gt; int: return self.stack[-1] def getMin(self) -\u0026gt; int: return self.min_stack[-1] # Your MinStack object will be instantiated and called as such: # obj = MinStack() # obj.push(val) # obj.pop() # param_3 = obj.top() # param_4 = obj.getMin() 結果 ",
    "ref": "/blog/202109-leetcode-no155-min-stack/"
  },{
    "title": "[LeetCode] #66 Plus One (Easy)",
    "date": "",
    "description": "LeetCode 第 66 題 Plus One，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Plus One，屬於 Easy\n原始題目 You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0\u0026rsquo;s.\nIncrement the large integer by one and return the resulting array of digits.\nExample 1:\nInput: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124. Thus, the result should be [1,2,4]. Example 2:\nInput: digits = [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Incrementing by one gives 4321 + 1 = 4322. Thus, the result should be [4,3,2,2]. Example 3:\nInput: digits = [0] Output: [1] Explanation: The array represents the integer 0. Incrementing by one gives 0 + 1 = 1. Thus, the result should be [1]. Example 4:\nInput: digits = [9] Output: [1,0] Explanation: The array represents the integer 9. Incrementing by one gives 9 + 1 = 10. Thus, the result should be [1,0]. 題目分析 傳入一個純正整數的陣列 該陣列是一個大正整數，依照每個位數拆開 計算出該正整數 +1 的結果 把結果依照輸入的方式也輸出成陣列 解題過程 把輸入的陣列數字一個一個串成字串 字串轉換成數字，然後 +1 每個位元拆開做成新的 list 後回傳 class Solution: def plusOne(self, digits: List[int]) -\u0026gt; List[int]: number_string = \u0026#39;\u0026#39; number_new = [] # list 用字串串起來 for number in digits: number_string += str(number) # 字串轉數字，數字 +1 number_string = str(int(number_string) + 1) # 每一個位元拆開成新的 list for number in number_string: number_new.append(number) return number_new 結果 ",
    "ref": "/blog/202109-leetcode-no66-plus-one/"
  },{
    "title": "[LeetCode] #290 Word Pattern (Easy)",
    "date": "",
    "description": "LeetCode 第 290 題 Word Pattern，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Word Pattern，屬於 Easy\n原始題目 Given a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.\nExample 1:\nInput: pattern = \u0026#34;abba\u0026#34;, s = \u0026#34;dog cat cat dog\u0026#34; Output: true Example 2: Input: pattern = \u0026#34;abba\u0026#34;, s = \u0026#34;dog cat cat fish\u0026#34; Output: false Example 3:\nInput: pattern = \u0026#34;aaaa\u0026#34;, s = \u0026#34;dog cat cat dog\u0026#34; Output: false Example 4:\nInput: pattern = \u0026#34;abba\u0026#34;, s = \u0026#34;dog dog dog dog\u0026#34; Output: false 題目分析 給你一個模式pattern和s pattern 裡的每個字母對應s一個單字，相同字母單字必須一樣 判斷s是否符合pattern 解題過程 長度判斷，如果pattern字母數量和s單字數量不同，一定就是 false mapping_dict的 key 是pattern的字母，值是同 index 的s內容 exist_check_dict的 key 是s的單字，值是pattern的字母 遍歷pattern所有值 檢查當前pattern字母為 key 的mapping_dict資料，和s中相同位置的單字有沒有一樣 檢查和當前pattern字母同 index 的 s 單字所對應的字母和exist_check_dict紀錄中的字母有沒有一樣 class Solution: def wordPattern(self, pattern: str, s: str) -\u0026gt; bool: # 長度判斷，如果不同長度一定就是 false words_list = s.split(\u0026#39; \u0026#39;) words_len = len(words_list) pattern_len = len(pattern) if words_len != pattern_len: return False mapping_dict = dict() exist_check_dict = dict() for index, val in enumerate(pattern): # 如果 pattern key 存在 if val in mapping_dict.keys(): # 檢查 pattern 字母代表的單字是否一致 if mapping_dict[val] != words_list[index]: return False else: # 檢查有沒有重複的單字在不同字母中 if words_list[index] in exist_check_dict: if exist_check_dict[words_list[index]] != val: return False else : mapping_dict[val] = words_list[index] exist_check_dict[words_list[index]] = val return True 結果 ",
    "ref": "/blog/202109-leetcode-no290-word-pattern/"
  },{
    "title": "使用 GrumPHP 做程式碼品質的守門員",
    "date": "",
    "description": "檢查你的程式有沒有怪味道，在你犯錯前就制止你。一生只督你一人",
    "body": "多人一起開發的環境下，Code Review 是一件非常重要的事情\n因為如果有人寫出一些不符合規則的程式，或是無法通過測試的程式時會造成專案出錯\n而人工檢查語法或是手動執行測試耗時費力 no fashion，這種事情應該讓程式自動做\n於是 GrumPHP 登場了\n什麼是 GrumPHP GrumPHP 是一個開源的 Composer 套件，藉由 git hook\n當有人變更程式並且 commit 的時候，GrumPHP 將根據設定好的 tasks 去檢查程式內容\n如果測試失敗，commit 會被中斷\n並且 GrumPHP 內建了一組常見的任務，可以用最少的客製設定使用 GrumPHP\n可以在官方文件中的 Tasks 頁面找到大部分你會用到的檢查任務\n以下我們就分別從安裝到加入四個常用的任務來介紹\n安裝 GrumPHP 一樣拿上次做一半的 LaraPeko 來做示範，以下說的「專案」指的都是這個套件包！\n首先進入專案目錄下執行\ncomposer require --dev phpro/grumphp 會跳出互動介面問你要不要建立設定檔grumphp.yml，然後給你一大堆選項\n可以先隨便選一個，或是直接跳過\n因為下一步要安裝的是yamllint，如果你在這邊選了 yamllint，下一步就沒事了\n可以在專案根目錄執行指令來測試是否可以執行檢查\nvendor/bin/grumphp run 若是執行\ncomposer install 可以看到提示GrumPHP is sniffing your commits!代表 GrumPHP 已經在嗅探我們的 commit 了\n加入檢查任務 這邊會逐步安裝並說明四個常用的基本檢查任務\nyamllint PHPLint Phpunit Phpcs 首先如果上一步沒建立grumphp.yml的話，在專案根目錄下建立檔案並建立內容\ngrumphp: tasks: { } 在官方 GitHub 上有一份範例的 grumphp.yml 設定檔\n而 Parameters 文件 有參數的詳細說明和與設值介紹\n在這邊為了減少設定上的步驟，我們都先用預設值就好\n1. yamllint 檢查你專案中的 yaml 檔結構合法性，如果有 drone 或是其他需要使用 yaml 格式檔案配置的設定檔\n根據文件中 YamlLint 我們不需要額外配置\n只需要在 tasks 列表中加入 yamllint 即可\ngrumphp: tasks: { yamllint: null, } 2. PHPLint 檢查語法錯誤，多一個逗點之類會讓 IDE 有紅字的syntax error\n照著官方文件的任務使用方法安裝：PHPLint 首先執行 composer 指令安裝依賴項目，因為這個檢查只有在測試環境需要被執行\n所以只在測試環境require-dev中安裝\ncomposer require --dev php-parallel-lint/php-parallel-lint 接著加入grumphp.yml中的任務\ngrumphp: tasks: { yamllint: null, phplint: ~, } 同樣的，在文件中有很多可以調整個規則\n可以依照個人使用調整，而這邊我們依然使用預設值就好\n3. Phpunit 指行指定路徑下的測試，如果失敗則視為任務失敗\n照著官方文件的任務說明安裝在測試環境中：Phpunit composer require --dev phpunit/phpunit 而文件中有說明，你必須建立phpunit.xml作為任務的設定檔\n底下範例指定了測試檔案的資料夾目錄\nUnit：./tests/Unit Feature：./tests/Feature 如果缺少這個檔案，預設會是 null，執行下去會報錯\n如果你的對應資料夾沒建立，在執行檢查的時候也會視為錯誤，記得要在專案中建立對應資料夾\nphpunit.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;phpunit xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:noNamespaceSchemaLocation=\u0026#34;./vendor/phpunit/phpunit/phpunit.xsd\u0026#34; bootstrap=\u0026#34;vendor/autoload.php\u0026#34; colors=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;testsuites\u0026gt; \u0026lt;testsuite name=\u0026#34;Unit\u0026#34;\u0026gt; \u0026lt;directory suffix=\u0026#34;Test.php\u0026#34;\u0026gt;./tests/Unit\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; \u0026lt;testsuite name=\u0026#34;Feature\u0026#34;\u0026gt; \u0026lt;directory suffix=\u0026#34;Test.php\u0026#34;\u0026gt;./tests/Feature\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; \u0026lt;/testsuites\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;whitelist processUncoveredFilesFromWhitelist=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;directory suffix=\u0026#34;.php\u0026#34;\u0026gt;./app\u0026lt;/directory\u0026gt; \u0026lt;/whitelist\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;/phpunit\u0026gt; 來測試一下任務是否有執行上次套件包中的測試吧！\n因為配合 phpunit.xml 的設定，所以把上次寫在 tests 資料夾內的測試搬到 tests/unit 內\n執行指令vendor/bin/grumphp run可以看到通過的綠色的開心老頭\n若我們修改測試方法，讓測試無法通過\npublic function testGetAhoy() { $larapeko = new LaraPeko(); $this-\u0026gt;assertEquals(\u0026#39;ahoy\u0026#39;, \u0026#39;DD\u0026#39;); } 接著再一次執行指令便會看到一個生氣的紅色老頭，以及其錯誤訊息\n透過提示訊息，我們可以清楚的知道是哪個測試沒有通過\n4. Phpcs 這個任務，可以檢查提交的 PHP 內容是不是符合 PSR 規則 首先安裝相關套件，參考：Phpcs 任務文件 composer require --dev squizlabs/php_codesniffer 接著一樣是需要建立配置文件phpcs.xml來設定我們需要檢查的規則，這邊以基本的 PSR-12 為例\n可以看到我們設定了 PSR12 的檢查規則\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;ruleset name=\u0026#34;PSR12\u0026#34;\u0026gt; \u0026lt;description\u0026gt;The PSR12 coding standard.\u0026lt;/description\u0026gt; \u0026lt;rule ref=\u0026#34;PSR12\u0026#34;/\u0026gt; \u0026lt;file\u0026gt;app/\u0026lt;/file\u0026gt; \u0026lt;file\u0026gt;config/\u0026lt;/file\u0026gt; \u0026lt;file\u0026gt;routes/\u0026lt;/file\u0026gt; \u0026lt;exclude-pattern\u0026gt;public/index.php\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;server.php\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;laravel-nova-*\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;vendor\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;resources\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;database/\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;storage/\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;node_modules/\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;tests\u0026lt;/exclude-pattern\u0026gt; \u0026lt;/ruleset\u0026gt; 既然設定好了就執行看看吧\nvendor/bin/grumphp run 可以看到我們設定的測試都有通過了\n那如果有一些不符合 PSR12 規則的東西會發生什麼事情呢？\n為了測試，我們隨便找一段 PHP 程式，在分號後面再加一個分號\n這麼做並不會觸發先前安裝的 phplint 檢查，因為這不屬於語法錯誤，但這麼做不符合 PSR12 規則\n於是我們又看到了生氣的老頭，指出哪裡有問題\n自動監聽 以上都是我們手動執行套件的任務來測試程式碼的品質，好還要更好\n最好可以讓程式自動執行測試，也就是一開頭我們說過的在 commit 時自動觸發 GrumPHP 的 tasks\n這件事情想起來難，做起來倒是一點就通\n透過修改專案的composer.json我們可以加入指令，參考 composer 官方文件 我們可以透過加入scripts區塊，讓指令在 composer 執行過程中被執行\n在專案的composer.json中加入指令，在初始時就就開始嗅探\n\u0026#34;scripts\u0026#34;: { \u0026#34;post-install-cmd\u0026#34;: [ \u0026#34;@php ./vendor/bin/grumphp git:init\u0026#34; ] }, 這樣不論是在 CLI 執行git commit或是使用 GUI 操作，都可以在 commit 前觸發我們定義的 tasks\n如下圖就是使用 GUI 觸發 phpcs 這個任務的失敗狀態跳出的訊息\n",
    "ref": "/blog/202107-grumphp-a-php-code-quality-tool/"
  },{
    "title": "開發屬於自己的 Laravel 套件",
    "date": "",
    "description": "介紹如何在本機進行 Laravel 套件開發及撰寫測試，並在本機專案透過 composer 安裝自行開發的套件",
    "body": "目前的 Laravel 生態中有許多好用的套件包可以使用\n但要是找不到別人寫好的套件包，又或是必須建置公司共用的套件包怎麼辦呢？\n本篇就來在本機進行套件包開發，並且會在本機專案中使用 composer 進行安裝並測試\n有些文章會教你在既有的 Laravel 專案中建立 packages 資料夾，並在裡面進行開發\n但這不是一個好方法，試想你萬一有天把專案刪掉了，套件包的專案也被刪掉了\n並且這種做法不能測試使用 composer 安裝是否正常，所以本篇使用的是另一種方式\n1. 初始化套件專案 首先我們開一個資料夾，方便起見我們用 larapeko 作為範例\nmkdir larapeko 接著進到剛剛的 larapeko 資料夾中，執行指令初始化套件\ncd larapeko composer init 會經過一連串的問答協助你設定套件的基本資訊\n接著就會在資料夾內看到剛剛初始化的套件 composer.json 檔案\n{ \u0026#34;name\u0026#34;: \u0026#34;ray247k/larapeko\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A package for demo peko\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Ray\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;ray247k@gmail.com\u0026#34; } ], \u0026#34;minimum-stability\u0026#34;: \u0026#34;dev\u0026#34;, \u0026#34;require\u0026#34;: {} } 2. 撰寫套件程式 在 larapeko 資料夾中新建 src 資料夾，我們的套件程式碼主要都放在這\n建立一個名為 LaraPeko.php 的檔案，並設定所使用的 namespace\n為了後續示範，我先建立一個簡單的 function\n\u0026lt;?php # LaraPeko.php namespace Ray247k\\LaraPeko; class LaraPeko { public function sayPeko() { echo \u0026#34;好油喔 peko\\n\u0026#34;; } } 3. ServiceProvider 在 src 目錄內建立剛剛檔案的 ServiceProvider，為了好識別，我們就命名為 LaraPekoServiceProvider.php\n透過 register 中的 singleton，會註冊一個叫做LaraPeko的類別，並回傳剛剛建立的 LaraPeko 物件\n\u0026lt;?php # LaraPekoServiceProvider.php namespace Ray247k\\LaraPeko; use Illuminate\\Support\\ServiceProvider; class LaraPekoServiceProvider extends ServiceProvider { public function boot() { } // 註冊套件函式 public function register() { $this-\u0026gt;app-\u0026gt;singleton(\u0026#39;LaraPeko\u0026#39;, function ($app) { return new LaraPeko(); }); } } 4. Facade Facade 提供一個靜態的介面讓我們直接呼叫註冊過的類別\n在 src 目錄內建立剛剛檔案的 Facade，命名為 LaraPekoFacade.php 吧\n使用剛剛上面 ServiceProvider 註冊的LaraPeko類別作為 Laravel 的 Facade 物件\n\u0026lt;?php # LaraPekoFacade.php namespace Ray247k\\LaraPeko; use Illuminate\\Support\\Facades\\Facade; class LaraPekoFacade extends Facade { protected static function getFacadeAccessor() { return \u0026#39;LaraPeko\u0026#39;; } } 5. 預設 config 以及使用方法 在使用套件的時候，有時候會想讓使用者可以透過設定檔設定參數\n這時候可以在套件目錄下建立config資料夾，並且在裡面加入 config 設定檔 lara_peko.php\n\u0026lt;?php # lara_peko.php return [ \u0026#39;best_girl\u0026#39; =\u0026gt; \u0026#39;Yagoo\u0026#39;, ]; 建立好了之後，我們要編輯LaraPekoServiceProvider.php成底下內容\n\u0026lt;?php # LaraPekoServiceProvider.php namespace Ray247k\\LaraPeko; use Illuminate\\Support\\ServiceProvider; class LaraPekoServiceProvider extends ServiceProvider { public function boot() { $source = realpath($raw = __DIR__.\u0026#39;/../config/lara_peko.php\u0026#39;) ?: $raw; $this-\u0026gt;publishes([ $source =\u0026gt; config_path(\u0026#39;lara_peko.php\u0026#39;), ]); } // 註冊套件函式 public function register() { $configPath = __DIR__ . \u0026#39;/../config/lara_peko.php\u0026#39;; $this-\u0026gt;mergeConfigFrom($configPath, \u0026#39;lara_peko\u0026#39;); $this-\u0026gt;app-\u0026gt;singleton(\u0026#39;LaraPeko\u0026#39;, function ($app) { return new LaraPeko(); }); } } 在boot()中使用publishes方法後，在引用套件的時候可以在專案內使用指令\nphp artisan vendor:publish 並根據跳出的互動視窗選擇套件對應數字輸入\n就可以的在專案目錄的 config 路徑下產生套件包的 config 範本對應的檔案\n如果如果你很確定自己要建立的是哪一個套件的 config 檔，也可以直接加上 provider 標籤\n指定要呼叫的是哪一個命名空間內的 provider 的 publishes 發布方法\nphp artisan vendor:publish --provider=\u0026#34;Ray247k\\LaraPeko\\LaraPekoServiceProvider\u0026#34; 而register()中則是將預設的 config 設定檔和新建立的設定檔合併\n如此一來，若使用者對專案設定檔做修改，會覆蓋掉預設的設定檔，達到客製化的目的\n清除 config 的快取 當 config 有變更，則需要使用指令清除專案內的設定檔快取\nphp artisan config:clear # 清除設定檔快取 php artisan cache:clear # 清除一般快取 使用 config 參數 若是要在程式中使用 config 設定，則可以使用 config() 方法呼叫\n回到LaraPeko.php，新建個方法getBestGirl取得設定檔中的best_girl參數內容\n\u0026lt;?php # LaraPeko.php namespace Ray247k\\LaraPeko; class LaraPeko { public function sayPeko() { echo \u0026#34;好油喔 peko\\n\u0026#34;; } public function getBestGirl() { echo config(\u0026#39;lara_peko.best_girl\u0026#39;); } } 6. 套件包自動發現 Laravel 5.5 新增的功能，可以借由套件包的設定減少使用者安裝時候需要的步驟\n目的是在執行 composer install 之後，不需要手動編輯config/app.php 的providers和aliases陣列\n關鍵字：Package Auto-discovery、Laravel 擴充套件包自動發現\n作法：\n在套件包的 composer.json 裡面加入 autoload 和 extra 的內容\n因為整串貼有點太長，就只貼有新增的部分\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;Ray\\\\LaraPeko\\\\\u0026#34;: \u0026#34;src\u0026#34; } }, \u0026#34;extra\u0026#34;: { \u0026#34;laravel\u0026#34;: { \u0026#34;providers\u0026#34;: [ \u0026#34;Ray\\\\LaraPeko\\\\LaraPekoServiceProvider\u0026#34; ], \u0026#34;aliases\u0026#34;: { \u0026#34;LaraPeko\u0026#34;: \u0026#34;Ray\\\\LaraPeko\\\\LaraPekoFacade\u0026#34; } } } } 藉由 extra 中的 laravel 定義，會在陣列中的 providers 和 aliases 內各加入一筆資料進行相關註冊\n而 autoload 會使用 psr-4 的規則將指定命名空間指向我們套件程式所在的資料夾src\n7. 套件包相依套件 如果你的套件包相依於某個套件，例如常用的Guzzle\n那麼就在套件包的 composer.json 中加入 require 的項目如下\n{ \u0026#34;name\u0026#34;: \u0026#34;ray247k/larapeko\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A package for demo peko\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Ray\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;ray247k@gmail.com\u0026#34; } ], \u0026#34;minimum-stability\u0026#34;: \u0026#34;dev\u0026#34;, \u0026#34;require\u0026#34;: { \u0026#34;php\u0026#34;: \u0026#34;\u0026gt;=7.3\u0026#34;, \u0026#34;laravel/framework\u0026#34;: \u0026#34;5.5.*||^6.0|^7.0|^8.0\u0026#34;, \u0026#34;guzzlehttp/guzzle\u0026#34;: \u0026#34;^6.3\u0026#34; } } 我們除了 require guzzle 外，還 require 了 php 必須大於指定版本以及 Laravel\n8. 套件包測試 建立測試用專案 經過上面流程，我們的套件包差不多就設定好了\n接著就要進入測試流程，因為我們是要在 Laravel 專案中使用的\n所以就建立一個新的 Laravel 專案來進行測試，叫做 lara-ahoy\nlaravel new lara-ahoy 可以藉由指令查看安裝的 Laravel 版本\ncd \u0026lt;專案目錄\u0026gt; php artisan -V # Laravel Framework 6.20.30 專案中引用套件 加入套件項目 在專案中使用指令，在 composer.json 中加入套件的版本儲存位置\n這邊因為是在本機測試，所以使用 path 方法指定本機套件包的相對或絕對路徑\n關於路徑的設定可以參考官方說明：Composer Documentation #Path composer config repositories.ray247k path ../larapeko 從相對路徑看得出來我把套件包(larapeko) 和測試用的專案(lara-ahoy) 放在同一個資料夾裡面\n指令執行之後可以打開 lara-ahoy 專案的 composer.json 檔案\n會發現最下面多了一段\n{ \u0026#34;repositories\u0026#34;: { \u0026#34;ray247k\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;../larapeko\u0026#34; } } } 如果不想用指令加入套件位址，也可以手動加入這段\n如果套件是在某個 repository 的話 可以把引用 type 換成 vcs，然後加上遠端版本庫的 url\ncomposer config repositories.ray247k vcs https://github.com/ray247k/larapeko 或是手動調整 composer.json 裡面的 repositories 設定\n{ \u0026#34;repositories\u0026#34;: { \u0026#34;ray247k\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;vcs\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://github.com/ray247k/larapeko\u0026#34; } } } 遠端的 url 可以使用 https 或是 ssh 方法\n但如果該套件的 repository 是私有的，那就必須用 ssh：git@github.com:ray247k/larapeko.git\n添加依賴 可以使用指令\ncomposer require ray247k/larapeko @dev 或是直接打開 cmoposer.json 找到require段落加入底下內容\n{ \u0026#34;require\u0026#34;: { \u0026#34;ray247k/larapeko\u0026#34;: \u0026#34;@dev\u0026#34; }, } 若是在使用指令的時候發生某個套件的相依套件無法安裝而造成錯誤的話\nProblem 1 - \u0026lt;某個套件\u0026gt; is locked to version 3.1.2 and an update of this package was not requested. - \u0026lt;某個套件\u0026gt; 3.1.2 requires ext-rdkafka \u0026gt;=1.0 -\u0026gt; it is missing from your system. Install or enable PHP\u0026#39;s rdkafka extension. 可以藉由加上 --ignore-platform-reqs 忽略平台\ncomposer require ray247k/larapeko --ignore-platform-reqs 在添加本機依賴之後，預設每次被使用都會自動去抓取本機套件最新的程式碼\n如果沒自動抓取，或是不想要自動抓取，而是每次都想要 composer require 來更新的話\n可以在測試專案中的 composer.json 透過 repositories 區塊內的 options.symlink 設定來調整\n{ \u0026#34;repositories\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;../../packages/my-package\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;symlink\u0026#34;: false } } ] } 安裝套件 使用套件安裝指令\ncomposer install 在上圖中可以看到剛剛的套件已經成功被發現，並且安裝\nDiscovered Package: ray247k/larapeko Package manifest generated successfully. 如果跟 require 的時候一樣發生相依套件的版本錯誤，一樣可以加入參數忽略平台\ncomposer install --ignore-platform-reqs 打開 lara-ahoy 中的 composer.lock 檔案，可以看到剛剛成功安裝的套件資料\n若是先前已經執行過專案，那必須清除原有 autoload 的快取\ncomposer dump-autoload 測試套件 上一步驟中我們在測試用專案 lara-ahoy 中安裝好了本機開發的套件 larapeko\n接著會分別用兩種方式測試套件是否有正確被引入，分別是直接呼叫測試和單元測試\n在開發套件時候如果就有撰寫單元測試，那這時候就會方便許多\n本篇文章也會帶著你建立基本的單元測試並執行，就繼續看下去吧！\n方法一、檔案測試 直接在測試用的 Laravel 專案跟目錄資料夾下建立 test-autoload.php 檔案\n在檔案中載入 autoload 之後呼叫套件方法\n\u0026lt;?php # test-autoload.php use Ray247k\\LaraPeko\\LaraPeko; require_once \u0026#39;./vendor/autoload.php\u0026#39;; LaraPeko::sayPeko(); 在 lara-ahoy 專案目錄下執行測試檔案\nphp test-autoload.php 如果成功載入應該會出現套件中sayPeko()的執行結果\n雖然跳出了 PHP Deprecated，但是還是有成功印出我們的預設字串內容\n代表剛剛在 ServiceProvider 註冊的 Facade aliases 有成功被呼叫了！\n如果真的很不想看到那個錯誤訊息\n只要在 test-autoload.php 中加入error_reporting(0);關閉錯誤訊息提示\n\u0026lt;?php error_reporting(0); use Ray247k\\LaraPeko\\LaraPeko; require_once \u0026#39;./vendor/autoload.php\u0026#39;; LaraPeko::sayPeko(); 如此就不會看到 PHP Deprecated 的提示了\n方法二、使用單元測試 接著就是使用單元測試來測試套件，參考文件：Laravel Package Development #Testing 先試試看 PHPUnit 是否可以執行，在專案目錄下使用指令\nphp vendor/bin/phpunit 如果出現底下錯誤訊息\n/usr/bin/php declares an invalid value for PHP_VERSION. This breaks fundamental functionality such as version_compare(). Please use a different PHP interpreter. 那看來是蘋果的鍋：PHPUnit does not work when I run the tests on the Laravel framework PHPUnit refuses to be run with a PHP interpreter where the value of the PHP_VERSION constant contains an invalid value due to modification made by vendors that ship (binary) distributions of PHP.\n7.3.24-(to be removed in future macOS) is such an invalid value. The -(to be removed in future macOS) suffix was added by Apple, who is the vendor of the PHP interpreter binary you use.\nTL;DR: Do not use the PHP interpreter that is shipped by Apple with macOS. Use Homebrew, or similar, instead.\n這時候有兩個解法，一個是用 Homebrew 安裝 PHP，記得要修改 bash/zsh 的設定檔\n另一個是把測試專案搬到 docker 環境裡面 PHP mount 的資料夾內\n直接進到 php 容器裡面執行 php vendor/bin/phpunit 指令\n如果 php vendor/bin/phpunit 可以執行，接著就要來建置單元測試檔案\n先在 LaraPeko.php 新增一個測試用的 function\npublic function getAhoy() { return \u0026#34;ahoy\u0026#34;; } 接著在套件包專案內建立 tests 資料夾，並建立測試檔案 LaraPekoTest.php\n\u0026lt;?php namespace Ray247k\\LaraPeko; use PHPUnit\\Framework\\TestCase; class LaraPekoTest extends TestCase { /** * @test * * @return void */ public function testClassInstance() { $this-\u0026gt;assertInstanceOf(LaraPekoTest::class, new LaraPekoTest); } public function testGetAhoy() { $larapeko = new LaraPeko(); $this-\u0026gt;assertEquals(\u0026#39;ahoy\u0026#39;, $larapeko-\u0026gt;getAhoy()); } } 可以看到我們呼叫 LaraPeko 物件，然後調用了 getAhoy() 方法\n因為我們上面有建立了這個方法，會回傳「ahoy」\n使用 assertEquals 的測試斷言式判斷回傳值是不是等於「ahoy」\n建立好 test file 之後進到容器中的 Laravel 專案的根目錄，使用指令執行指定路徑下的測試\nphp vendor/bin/phpunit vendor/ray247k/larapeko/tests 補充\n假設現在 LaraPeko 套件裡有個 private function 叫做 testMethod\nprivate function testMethod() { return \u0026#39;Haha\u0026#39;; } 如果想測試 private function 可以使用閉包中的 bindTo() 方法\n產生物件之後手動注入一個物件，替換掉 closure 物件中的 $this\n如此一來就像是直接使用 LaraPeko 物件去呼叫 testMethod 方法\n/** * @test * * @return void */ public function testMethodTest() { $contentSegment = new LaraPeko(); $closure = function () { return $this-\u0026gt;testMethod(); }; $closure_bind = $closure-\u0026gt;bindTo($contentSegment, $contentSegment); $this-\u0026gt;assertEquals(\u0026#39;Haha\u0026#39;, $closure_bind()); } 這樣去執行單元測試就可以對 private 方法進行測試了！\n以上就是這次\n",
    "ref": "/blog/202107-laravel-package-development/"
  },{
    "title": "用 Docker 建立 Laravel 開發環境",
    "date": "",
    "description": "介紹如何使用 Docker 建置基礎的 Laravel 的開發環境",
    "body": "過去在本機開發 Laravel 專案，多數是直接在本機安裝所需要服務\n而後來改以虛擬機為主，曾經官方文件推薦開發環境的 Homestead 是很多人第一次使用的環境\n而後出現的 Laradock 就是一個容器化的 PHP 開發環境\n裡面已經預先設定好了常用的容器，只需要修改一些設定就可以直接使用\n可以說是 Laradock 開啟了 Laravel 的大容器時代，在目前最新版本的 Laravel 8 中直接內建了容器環境\nLaravel Sail 是一個輕量級的 cli\n為使用 PHP、MySQL 和 Redis 建置的 Laravel 專案提供了一個可以直接使用的容器，甚至不需要有 Docker 經驗\n那為什麼還需要自己學 Docker 自己建環境呢？因為當初還沒有 Sail 可以用\n在本機開發可能不會遇到需要調整設定檔的情況\n但是如果你想要的服務 Laravel Sail 沒有提供\n又或是想要把線上環境也改為使用 Docker，那就必須要知道怎麼用 Docker 建置環境\n並且知道該怎麼配置相關服務\n廢話一大串，正文開始\nLaravel 專案環境建置 使用 docker-compose 建構 Laravel 專案環境\n一個 Laravel 專案需要包含以下服務\nnginx php redis postgreSQL 資料庫選用 postgreSQL，如果想換成 mysql 的也有在程式碼中附上設定方式\n啟動的時候二選一就好！\n1. docker-compose.yml 首先先建立一個專案資料夾，為了好分辨就叫 docker_env 吧\n在 docker_env 資料夾內建立檔案 docker-compose.yml，當作 docker-compose 服務的設定檔\n完整程式碼 # docker-compose.yml version: \u0026#39;3\u0026#39; networks: server: data: services: nginx: container_name: docker_env_nginx image: nginx:1.18 # stable version networks: - server ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - ./nginx/conf.d/:/etc/nginx/conf.d/ - ./nginx/ssl/:/ssl/ - \u0026lt;local project path\u0026gt;:/var/www/html/\u0026lt;project name\u0026gt; restart: always php: container_name: docker_env_php build: ./php/ expose: - 9000 networks: - server - data volumes: - /trp/web/home/:/var/trp/ restart: always redis: container_name: docker_env_redis image: redis:6.0 # stable version ports: - \u0026#34;6379:6379\u0026#34; networks: - data restart: always postgre: container_name: docker_env_postgre ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:12.6\u0026#34; volumes: - /trp/database/dev/database_data:/var/lib/postgresql/data # persist data even if container shuts down networks: - data environment: POSTGRES_DB: ${DB_NAME} POSTGRES_USER: ${DB_USER} POSTGRES_PASSWORD: ${DB_PASSWORD} restart: always mysql: container_name: docker_env_mysql ports: - \u0026#34;3306:3306\u0026#34; image: mysql:5.7.23 volumes: - /var/lib/mysql networks: - data environment: MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD} MYSQL_USER: ${DB_USER} MYSQL_PASSWORD: ${DB_PASSWORD} 分段說明 這邊會就 services 內容做說明，也會一併把需要的設定做完\n如果只把上面複製貼上就啟動服務的話必定會失敗的\nnginx 使用 nginx 作為我們的 Web 伺服器程式\nnginx: container_name: docker_env_nginx # 將容器命名為 docker_env_nginx image: nginx:1.18 # stable version networks: - server ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; # 容器外主機的 port:容器內的 port volumes: - ./nginx/conf.d/:/etc/nginx/conf.d/ # 載入的 nginx 設定檔 - ./nginx/ssl/:/ssl/ # 使用的 ssl 憑證 - \u0026lt;local project path\u0026gt;:/var/www/html/\u0026lt;project name\u0026gt; # 將專案掛載進容器裡面 restart: always # 自動重啟 ports 設定了對容器內外的 port 對應，上面的設定檔中比較看不出來\n我們改成 8080:80 來說明的話就是把主機上的 8080 port 映射給 nginx 容器內的 80 port\nvolumes 區塊則是說明需要掛載進 Docker 容器中的檔案，表現方式一樣是 本機位置:容器內位置\n第三行中我們把指定的 Laravel 專案掛載進容器的指定目錄下，如果你沒有 Laravel 專案的話先去建一個新專案\n第二行掛載了如果本機也想要用 https 的網址，你可以自己產一組證書放在 docker_env/nginx/ssl 目錄下\n這麼做雖然會顯示不安全，但是至少是 https 的網址\n第一行我們把同層中的 nginx 資料夾掛載進「/etc/nginx/conf.d/」這是 nginx 服務使用的設定檔位置\n所以我們要在 docker_env/nginx 資料夾中建立 nginx config 檔案\n# dev.project.com.conf server { listen 80; listen [::]:80; # Redirect all HTTP requests to HTTPS with a 301 Moved Permanently response. return 301 https://$host$request_uri; } server { listen 443 ssl; listen [::]:443 ssl; root /var/www/html/\u0026lt;laravel project name\u0026gt;/public; index index.php index.html index.htm; ssl_certificate /ssl/ssl.crt; ssl_certificate_key /ssl/ssl.key; server_name dev.project.com; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri /index.php =404; fastcgi_pass docker_env_php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ /\\.ht { deny all; } } 可以看到，監聽 80 port 的部分，會直接使用 301 跳轉到 443 port a.k.a https 使用的 port\nroot 則是指定專案資料夾的位置，可以看到他的指定位置和剛剛在 docker-compose.yml 中設定的掛載路徑一樣\n至於 public 是 Laravel 專案的程式進入點\n使用的 ssl 憑證也是對應到掛載時指定的容器內部路徑\n而 fastcgi_pass 是指定到有安裝 php-fpm 的容器 container_name，以及剛剛提供容器內部存取的 port\n其名稱和使用的 port 不是固定的！\nphp php: container_name: docker_env_php build: ./php/ expose: - 9000 networks: - server - data volumes: - \u0026lt;local project path\u0026gt;:/var/www/html/\u0026lt;project name\u0026gt; # 將專案掛載進容器裡面 restart: always 因為 php 容器不需要對外 port，所以使用 expose 讓容器的 9000 port 可以在 docker network 裡面被存取\nvolumes 的掛載方式和 nginx 服務一樣\n而要使用 Laravel，我們需要額外安裝一些 PHP 的擴充套件\n安裝套件這件事情會使用 build 指令，重新打包我們自己的 docker image\n會安裝一些 Laravel 所需要的 PHP 擴充套件，而資料庫的擴充套件就依照所使用的資料庫做選擇\n底下主要以 postgreSQL 做範例\n這邊也會一併示範安裝 composer，如果需要的話自行開啟，但是因為 PHP 不需要提前編譯的特性\n我們可以透過直接在本機下指令改變 volumes 的檔案，進而讓容器內部程式產生變更\n除非有非要在容器內下指令的原因，否則是不建議安裝\n在 docker_env 資料夾下建立 php 資料夾，新增檔案 Dockerfile\n# Dockerfile FROM php:7.4-fpm WORKDIR /var RUN apt-get update \u0026amp;\u0026amp; apt-get install -y libpq-dev libpng-dev libzip-dev zip RUN docker-php-ext-install pgsql pdo_pgsql gd zip\\ \u0026amp;\u0026amp; docker-php-ext-enable opcache # To use mysql, install pdo pdo_mysql instead of pgsql pdo_pgsql # Install composer Latest # RUN php -r \u0026#34;copy(\u0026#39;https://getcomposer.org/installer\u0026#39;, \u0026#39;composer-setup.php\u0026#39;);\u0026#34; \\ # \u0026amp;\u0026amp; php -r \u0026#34;if (hash_file(\u0026#39;sha384\u0026#39;, \u0026#39;composer-setup.php\u0026#39;) === \u0026#39;756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3\u0026#39;) { echo \u0026#39;Installer verified\u0026#39;; } else { echo \u0026#39;Installer corrupt\u0026#39;; unlink(\u0026#39;composer-setup.php\u0026#39;); } echo PHP_EOL;\u0026#34; \\ # \u0026amp;\u0026amp; php composer-setup.php \\ # \u0026amp;\u0026amp; php -r \u0026#34;unlink(\u0026#39;composer-setup.php\u0026#39;);\u0026#34; \\ # \u0026amp;\u0026amp; mv composer.phar /usr/local/bin/composer database postgre: container_name: docker_env_postgre ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:12.6\u0026#34; volumes: - /trp/database/dev/database_data:/var/lib/postgresql/data # persist data even if container shuts down networks: - data environment: POSTGRES_DB: ${DB_NAME} POSTGRES_USER: ${DB_USER} POSTGRES_PASSWORD: ${DB_PASSWORD} restart: always mysql: container_name: docker_env_mysql ports: - \u0026#34;3306:3306\u0026#34; image: mysql:5.7.23 volumes: - /var/lib/mysql networks: - data environment: MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD} MYSQL_USER: ${DB_USER} MYSQL_PASSWORD: ${DB_PASSWORD} 而資料庫的設定中 volumes 主要是在做資料持久化使用，當容器重啟時會去讀取裡面的資料\n資料庫的相關環境參數設定則是在 environment 區塊中，可以看到有很多敏感資料\n所以我們可以藉由在 docker_env 資料夾中建立不加入版本控制的 .env 檔案\n# .env DB_USER=db_user DB_PASSWORD=db_password DB_NAME=my_database 等號左邊的鍵值可以在 docker-compose.yml 裡面透過 ${鍵值} 呼叫，進而取得左邊設定的值\n啟動容器 經過上面的步驟，我們設定了 nginx php 和資料庫的服務\n確定 Docker 服務本身有在運作後，進入 docker_env 資料夾下執行\ndocker-compose up -d 如果一切正常，容器會在背景起動\n這樣就完成了「使用 Docker 建置 Laravel 環境」的目標！\n要檢查容器啟動狀況可以使用指令，看是不是全部運行中\ndocker ps -a 不過如果是我自己在寫新的 docker-compose.yml 設定檔，我會先使用\ndocker-compose up 讓 Log 即時顯示在畫面上，這時候要除錯就方便很多了！\n通常會遇到的問題是 volume 的資料夾不存在，例如 nginx config、ssl、Laravel 專案\nLaravel .env 設定 在完成 Docker 環境的啟動之後，就要設定 Laravel 專案的環境設定檔\n開啟根目錄下的.env，修改內容，這邊資料庫一樣使用 postgreSQL 做範例\n設定上使用 docker-compose.yml 中 postgre 服務的內容\nDB_HOST：設定檔中的容器名稱 container_name DB_PORT：設定檔中的 ports DB_DATABASE：設定檔中的 POSTGRES_DB DB_USERNAME：設定檔中的 POSTGRES_USER DB_PASSWORD：設定檔中的 POSTGRES_PASSWORD # .env DB_CONNECTION=pgsql DB_HOST=docker_env_postgre DB_PORT=5432 DB_DATABASE=my_database DB_USERNAME=db_user DB_PASSWORD=db_password 如以一來 Laravel 專案就可以透過容器內部網路存取到資料庫所在的容器\n設定本機測試用網址 用 Docker 建立 Laravel 環境 - 完成 Laravel 連線到 Docker 的資料庫 - 完成\n如此一來就大功\u0026hellip; 欸不對！我還沒上車 我要怎麼看專案的畫面？\n接下來要做的就是讓我們可以用瀏覽器開啟本機 Laravel 專案的畫面\n首先使用終端機指令，不管是 bash 還是 zsh\nsudo vim /etc/hosts 在 /etc/hosts 檔案裡面加入\n127.0.0.1 dev.project.com 意思是要把後面定義的網址名稱，指向前面的 IP 位址\n所以當瀏覽器網址列輸入 dev.project.com 的時候會將請求發送到本機的 localhost\n那為什麼這樣就可以看到剛剛設定的 Laravel 專案呢？\n因為我們在前面的 nginx config 設定中，有設定了 server_name 內容\nserver_name dev.project.com; 所以當監聽本機 80 和 443 port 的 Docker nginx 服務發現有請求進來\n而且符合 server_name 區塊設定的內容，就會進行處理\n如果你有另一個 nginx config 在 listen port 號的後面加上 default_server 如下\nlisten 80 default_server; 那代表當其他 nginx config 規則都沒有抓取到的時候，nginx 會使用這個設定檔\n若是全部 config 都沒有設定成 default_server，那麼會使用「檔名排序最前面」的設定檔\n如此一來應該就可以瀏覽 Laravel 專案的畫面了\n執行 Laravel 指令 如果想執行 Laravel 中跟資料庫有關的指令，例如\nphp artisan migrate 首先要先進入 php 容器內\ndocker exec -ti docker_env_php bash 在容器內的專案目錄下運行指令，就可以看到指令被正確執行\n若是沒有連進容器，直接執行 migrate 指令，則會得到錯誤訊息\nSQLSTATE[08006] [7] could not translate host name \u0026#34;docker_env_postgre\u0026#34; to address: nodename nor servname provided, or not known 因為程式不認得「docker_env_postgre」這個 host 的真實位址，所以無法執行\n如果我們把 .env 中的 DB_HOST 換成真實位置，透過 docker inspect 指令取得\n就可以執行，但是每次容器重啟就會被刷新。看來並沒有解決問題\n如果真的很懶，覺得連進容器執行也很麻煩，就是要直接在本機資料夾執行該怎麼辦呢？\n再一次修改 etc/hosts 檔案，加上\n127.0.0.1 docker_env_postgre # 資料庫使用的容器名稱 完工啦，這樣在本機專案資料夾下執行 migrate 就會被指向本機容器\n以上就是這次「用 Docker 建立 Laravel 開發環境」的全部內容\n好幾個小時終於打完這一篇，真的是心血結晶\n牽涉到很多伺服器知識，如果不熟的人建議還是去了解一下再進行操作 礙於篇幅只能簡單說明怎麼設定，跳過很多設定的詳細說明和作法\n還有很多部分沒提到，像是 docker network 的切分和使用\n",
    "ref": "/blog/202107-laravel-environment-with-docker/"
  },{
    "title": "環境初始化主機設定(Docker + Laravel)",
    "date": "",
    "description": "介紹如何在一台剛開的主機上設定基礎的 Docker 以及 Laravel 執行環境",
    "body": "如果今天開啟一台全新的雲端主機，要在上面使用 Docker 建立 Laravel 開發環境\n並且可以在遠端主機執行 Laravel 常用的 composer 與 artisan 指令\n因為這個步驟實在不常執行，所以記錄下來方便未來查找\n也為了接下來使用 Docker 建立 Laravel 環境文章做鋪陳\n1. 建立版本庫存取權限 要讓遠端主機可以對指定的 Repository 進行存取，需要加入 ssh key\n正規方法： ssh 登入遠端主機之後，在遠端主機使用指令產生 ssh key\nssh-keygen 然後把 public key 加到遠端版本庫\n小朋友不要學的方法： 也是可以把自己已經具有版本庫存取權限的 key pair 塞進遠端主機\n如果 .ssh 資料夾不存在要自己加，權限 700\nmkdir .ssh chmod 700 .ssh cd .ssh vim id_rsa chmod 600 id_rsa vim id_rsa.pub chmod 644 id_rsa.pub 2. 更新 linux 套件包 因為等等要裝套件，先更新主機的套件包\nsudo apt update 3. 安裝 docker 都說要建立 Docker 的環境，當然要安裝 Docker\nsudo apt install docker.io 4. 安裝 docker-compose 後面會使用 docker-compose 來組合多個 Docker container 啟動一個完整服務\n因為之後的 Laravel 專案中會同時啟動 nginx, PHP, redis, mysql 等容器\n透過 docker-compose 管理與操作會比較方便\nsudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 5. 安裝 php 套件 因為 Laravel 專案不需要編譯，當我們修改容器外的檔案，會同步對掛載進容器的檔案做變更\n所以不一定要連進容器裡執行指令，在本機的變更一樣會直接生效。當然不進行這一步也是可以的\n為了之後可以直接在主機上執行 php artisan 和 phpunit，還有安裝\u0026amp;執行 composer\nPHP 版本根據你的需求安裝\napt install php7.4-cli php7.4-gd install php7.4-mbstring php7.4-curl php7.4-xml php7.4-zip 如果不確定自己想找的套件名稱叫什麼，可以在 apt install php7.4 之後按兩下 tab\n這樣就會列出名稱為「php7.4」開頭的所有套件，如此就可以很方便的找到指定版本的套件！\n下圖用 apt install docker 按兩下 tab 顯示所有「docker」開頭的套件為例\n6. 安裝 PHP 的套件管理工具 composer 照官網步驟安裝即可：Download Composer 範例：（正確指令以官方網站為主）\nphp -r \u0026#34;copy(\u0026#39;https://getcomposer.org/installer\u0026#39;, \u0026#39;composer-setup.php\u0026#39;);\u0026#34; php -r \u0026#34;if (hash_file(\u0026#39;sha384\u0026#39;, \u0026#39;composer-setup.php\u0026#39;) === \u0026#39;756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3\u0026#39;) { echo \u0026#39;Installer verified\u0026#39;; } else { echo \u0026#39;Installer corrupt\u0026#39;; unlink(\u0026#39;composer-setup.php\u0026#39;); } echo PHP_EOL;\u0026#34; php composer-setup.php php -r \u0026#34;unlink(\u0026#39;composer-setup.php\u0026#39;);\u0026#34; 將 composer 移動到環境變數，讓全域都可以使用指令\n建議要執行此步驟，否則就只能在你安裝的路徑（有 composer.phar 檔案）的地方執行指令\nsudo mv composer.phar /usr/local/bin/composer 若要查看全域可以執行的指令與對應目錄\necho $PATH 7. 設定 .sh 檔案可執行 如果專案中有 shell 需要執行，必須要修改檔案權限\nchmod 755 {target file path} 如此就可以在主機中執行以下的指令\ndocker composer php artisan 也就完成了接下來使用 Docker 建置 Laravel 環境的所需要的基礎設定\n",
    "ref": "/blog/202107-initialize-server-setting-with-docker-and-laravel/"
  },{
    "title": "[用 Drone 建立自動部署] 04 drone runner 介紹",
    "date": "",
    "description": "透過 Drone 建立自動部署流程，drone runner 介紹",
    "body": "我們在 [用 Drone 建立自動部署] 01 基本服務建置及串接 GitHub 文章中有 docker-compose.yml 的範例\n在範例中建立了兩個 docker runner，分別是 drone_runner_docker 和 drone-runner-ssh\n而在 [用 Drone 建立自動部署] 02 部署觸發條件(pipeline)設定 中使用到的其實只有 docker runner\n這篇文章來分別介紹兩個 runner，以及官方網站上提到的其他 runner\n所有的 runner 可以在官方網站的 runner overview 頁面找到\n預設的 runner 是 docker runner\n在文章編輯的時候有的 runner 列表\nDocker Runner Kubernetes Runner Exec Runner SSH Runner Digital Ocean Runner Macstadium Runner ssh runner 範例： kind: pipeline type: ssh name: default server: host: from_secret: GCP_IP_HOST user: from_secret: TESTING_USER ssh_key: from_secret: TESTING_PRIVATE_SSH_KEY steps: - name: greeting commands: - echo hello world - whoami - pwd - echo DRONE_REPO = ${DRONE_REPO} - echo DRONE_BRANCH = ${DRONE_BRANCH} 解說 當 type 使用 ssh 的時候，就是使用 ssh runner 執行\n在 server 區塊中指定了 ssh 所需要的參數，包含遠端的 host ip 位置以及登入的使用者名稱\nfrom_secret: SSH_KEY 代表從 Drone 服務後台設定的 Secrets 取用特定 index 的值\n如果有需要使用 ssh 登入主機操作，則這邊要填入主機的 id_rsa\n並且也要建立權限為 600 的 authorized_keys 檔案在用來登入的使用者目錄下 .ssh 中\n檔案內容則是 id_rsa.pub 的內容，如此 drone 的 ssh runner 才能正確的使用指定使用者的 ssh key 登入遠端主機\n這樣做的好處是敏感資料不用讓所有專案的部署者知道，只要知道使用的 secrets index 叫什麼就好\n未來若是有修改，也只需要在 Drone 後台操作，不需要每個專案修改檔案\nSecrets 官方說明 當然也可以使用 password 而不是 ssh 登入遠端主機，更多設定可以在 官方文件 裡面查看\ndocker runner 會使用指定的 image 去建立容器，並且用容器執行指定的行爲\n是預設的 runner，也是建議初學者使用的 runner\n若是你的多個 pipeline 會需要繼承對主機檔案進行操作的行為則不適合\n因為 Docker pipelines 是執行在 Docker 容器中，和實體主機是隔絕的，並不會直接影響主機上的檔案\n範例 kind: pipeline type: docker name: backend_dev steps: - name: submodules update image: alpine/git commands: - whoami - pwd - date - echo DRONE_REPO = ${DRONE_REPO} - echo DRONE_BRANCH = ${DRONE_BRANCH} - echo DRONE_COMMIT = ${DRONE_COMMIT} - echo DRONE_BUILD_NUMBER = ${DRONE_BUILD_NUMBER} - git submodule update --init --recursive trigger: branch: - dev event: - push 其他 runner Exec Runner 使用時機 不適合跑在容器內的專案，例如：MacOS 的專案\n不該使用的時機 由於 Exec runner 沒有和主機隔離，所有操作都是直接在服務建構的主機上操作\n如果專案和 Drone 服務沒有在同一台主機上，或是有人在專案內的 .drone.yml 加入危險的指令\n那會釀成悲劇，所以一般來說預設都使用 Docker runner\n並且 Exec runner 是 Beta 版本，並不建議使用在正式環境中\n範例 可以看到底下範例，pipeline 被觸發時會直接在主機上下指令！\n--- kind: pipeline type: exec name: default steps: - name: backend commands: - go build - go test - name: frontend commands: - npm install - npm test 以上就是常用的 Drone Runner 介紹，建議都是使用 Docker runner\n因為大部分所需要的操作都有現成的 Docker image 了\n沒有特別必要的話就別使用另外兩個 runner 直接對主機檔案系統操作，或是直接在主機下指令\n而 Kubernetes 我還沒有用過，所以並沒有介紹到 Kubernetes runner\n未來若有機會再補充\n",
    "ref": "/blog/202107-drone-cicd-4-advanced-runner/"
  },{
    "title": "[用 Drone 建立自動部署] 03 部署排程設定與權限管理",
    "date": "",
    "description": "透過 Drone 建立自動部署流程，部署排程設定與權限管理",
    "body": "使用 Drone 建立自己的自動部署服務\nDrone 是一套以 Golang 開發的一套 CI/CD 系統工具\n本篇進行部署排程設定與權限管理的教學\n定時執行 (Cron Job) 當初在設定排程的時候真的是各種坑，要是前面的服務啟動花了三天的話\n排程設定不斷查文件、看討論串、測試、除錯，整個大概花了半個月吧\n很多細節作者都只回在 gitter 或是論壇裡，並沒有寫進官方文件\n還有公司用的是 bitbucket，有些功能並不支援！\n自訂執行時間 服務本身的限制 Drone 1.0 最終版不給在介面上自訂因為容易出錯：來源 且最低重複執行時間半小時一次：來源 專案設定檔的設定方法 作者說明應該要用 CLI 定義好之後在專案的 .drone.yml 檔去設定觸發條件的 cron job 名稱\n而不是表達式：Cron job definition 表達式的時區居然是寫死的 官方說明排程的時區是使用 UTC 也就是 +0 時區，所以要自己換算：Cron Timezones The current implementation calculates the execution time based on UTC as opposed to local time.\n不過官方也說自訂排程時間不會在準確的時間被觸發，前後可能會差一點點：參考資料 建立 Cron Job 大部分教學都使用 Drone CLI，但是在官網發現可以用 API 建立： API drone cron create ，結果一樣\n首先要去 Drone 頁面右上的 User Settings 取得 Token 作為 Post 的 header\n打開 Postman 建立一個 POST /api/repos/{owner}/{repo}/cron 請求\n並在 Headers 頁籤加入 Token\nTocken key 是 Authorization\n而對應的 value 長得像 Bearer {一串英文數字} 的格式\nBody 則是設定 Cron Job 名稱和執行條件還有要執行的分支\n{ \u0026#34;name\u0026#34;: \u0026#34;every2hour\u0026#34;, \u0026#34;expr\u0026#34;: \u0026#34;0 0 */2 * * *\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;main\u0026#34; } 可以看到我的條件是 0 0 8-16,*/2 * * *，代表「8-16 點，每兩個小時執行一次」\n或是也可以設定成 0 0 10,12,14,16 * * *「每個 10 12 14 16 點」執行\n可以使用 線上工具 來依照條件產生\n注意！這邊作者使用的時間套件是包含秒數的 6 位數格式！\n查看 Cron Job Cron List 建立完成之後可以使用 GET /api/repos/{owner}/{repo}/cron 查看所有 Cron Job 列表\nCron Info 使用 GET /api/repos/{owner}/{repo}/cron/{name} 則可以查看指定 Cron Job 的詳細資訊\n回到 Drone 後台，點開專案的 settings 頁面會發現我們剛剛用 API 建立的 Cron Job 被加入了!\n等時間到就會執行 .drone.yml 中由指定 Cron Job 名稱觸發的 pipeline\n更新 Cron Job 更新Cron Job 使用 PATCH /api/repos/{owner}/{repo}/cron/{name}\nBody 帶入要改變的內容，例如把使用的分支換成 dev\n或是把執行時間換成每天的固定時間執行\n{ \u0026#34;name\u0026#34;: \u0026#34;every2hour\u0026#34;, \u0026#34;expr\u0026#34;: \u0026#34;0 0 2,4,6,8 * * *\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;dev\u0026#34; } 刪除 Cron Job 可以使用 DELETE /api/repos/{owner}/{repo}/cron/{name} 刪除之前建立的 Cron Job\n但是我更偏好用後台的 UI 介面按下 DELETE 就好\n另外一種操作方式是 Drone CLI，不過這次沒用上，提供給各位參考\nDrone CLI Cron CLI drone cron add 權限控管 如果沒設定使用者，服務上線到公開網址的話就是全世界都可以拿來使用：官方說明 Drone registration is open by default. This means any user can register an account and use the system.\n管理員權限設定 在 drone_server 建立 admin 才能管理其他帳號：DRONE_USER_CREATE - DRONE_USER_CREATE=username:ray247k,admin:true 使用者名單設定 藉由設定使用者名單來限制存取權限：官方文件 可以使用機構或是使用者 ID\n- DRONE_USER_FILTER=ray247k,lemon,JohnDoe 但如果版本控制使用的是 Bitbuctet 平台，則不支援 Organization 限制：討論串說明 所以只要有寫入權限就可以看到 setting 頁面\n使用 GitHub 測試，結果是可以使用組織進行權限控管的，並且不會開放 setting 分頁給所有人\n",
    "ref": "/blog/202106-drone-cicd-3-advanced-cron-job/"
  },{
    "title": "[用 Drone 建立自動部署] 02 部署觸發條件(pipeline)設定",
    "date": "",
    "description": "透過 Drone 建立自動部署流程，部署觸發條件(pipeline)設定",
    "body": "使用 Drone 建立自己的自動部署服務\nDrone 是一套以 Golang 開發的一套 CI/CD 系統工具\n本篇進行複數觸發條件設定，在不同觸發條件下觸發不同的部署步驟設定\n複數觸發條件(Multiple Conditions) 有時候專案中在特定分支要做不同的事件，這時候可以參考以下設定\n.drone.yml\n--- ################################################ # dev 每次推到分支就更新 # ################################################ kind: pipeline type: docker name: backend_dev steps: - name: submodules update image: alpine/git commands: - date - echo DRONE_REPO = ${DRONE_REPO} - echo DRONE_BRANCH = ${DRONE_BRANCH} - echo DRONE_COMMIT = ${DRONE_COMMIT} - echo DRONE_BUILD_NUMBER = ${DRONE_BUILD_NUMBER} - git submodule update --init --recursive - name: composer install image: composer:1.10.19 commands: - composer install --ignore-platform-reqs trigger: branch: - dev event: - push --- ################################################ # stage 根據排程設定執行 # ################################################ kind: pipeline type: docker name: backend_stage steps: - name: submodules update image: alpine/git commands: - date - echo DRONE_REPO = ${DRONE_REPO} - echo DRONE_BRANCH = ${DRONE_BRANCH} - echo DRONE_COMMIT = ${DRONE_COMMIT} - echo DRONE_BUILD_NUMBER = ${DRONE_BUILD_NUMBER} - git submodule update --init --recursive - name: composer install image: composer:1.10.19 commands: - composer install --ignore-platform-reqs trigger: event: - cron cron: - every2hour --- ################################################ # production 使用 git tag 發動部署 # ################################################ kind: pipeline type: docker name: backend_production steps: - name: submodules update image: alpine/git commands: - date - echo DRONE_REPO = ${DRONE_REPO} - echo DRONE_TAG = ${DRONE_TAG} - echo DRONE_COMMIT = ${DRONE_COMMIT} - echo DRONE_BUILD_NUMBER = ${DRONE_BUILD_NUMBER} - git submodule update --init --recursive - name: composer install image: composer:1.10.19 commands: - composer install --no-dev --ignore-platform-reqs trigger: event: - tag 如果 push dev 分支，則只會執行 dev_check_info 和 dev_run_update 兩個動作\n相對的 push testing 分支的行為則會等到指定排程 every2hour 被觸發才會執行\n如此就可以針對不同環境可能會偵測不同分支來做不同的操作，比較常見是啟動時的指令是否加上開啟除錯模式\n若是不同環境是部署在不同伺服器上，或是不同環境的部署流程不同的話是十分方便的\n每個 pipeline 都是獨立的，根據 trigger 的設定在不同條件下被觸發而執行不同步驟\n如果推送程式到 dev 分支，則只會觸發 backend_dev 這個 pipeline 以及內部的步驟 或是在版本控制中下 tag，當 webhook 監聽到新的 tag 被推送，則會觸發 backend_production\n也可以建立 cronjob 來進行排程定時執行\n例如 backend_stage 所設定的 testing 就是監聽名為 every2hour 的排程\n這部分之後會再獨立介紹相關的設定和使用方法\n更多的設定條件可以參考官方文件：Pipelines Conditions 了解更多關於 Pipeline：Pipelines Overview ",
    "ref": "/blog/202106-drone-cicd-2-advanced-pipeline-configuration/"
  },{
    "title": "[用 Drone 建立自動部署] 01 基本服務建置及串接 GitHub",
    "date": "",
    "description": "透過 Drone 建立自動部署流程，基本服務建置及串接 GitHub",
    "body": "使用 Drone 建立自己的自動部署服務\nDrone 是一套以 Golang 開發的一套 CI/CD 系統工具\n本篇進行基礎服務啟動設定，以及串接 GitHub\n為什麼使用 drone 支援各大 git repository：github、gitlab、bitbucket、gittea 等等\n只要你的專案是使用 git 版控，你就可以輕鬆整合 drone ci 流程是以 yml 檔描述的，非常好理解，且可以靈活調整\n只要有使用過 docker-compose 的經驗應該都可以快速上手 本身是以 Go 語言打造的，服務啟動速度非常快 是一個 docker base 的服務，可以快速移植到不同平台上運行\n尤其非常適合在 k8s 叢集的環境中運行 drone 的社群上已經有各種插件可以使用，也可以用各種語言自製客製化插件\n只要包裝成 image 就能輕鬆加入 ci 流程當中，非常方便 分為 server 和 runner，server 負責收集 git repo 的事件，當偵測到 pipeline 中定義好的條件時\n比如說某個 branch push，就會觸發pipeline 的流程，分派給不同種類的 runner 執行\n常見有 Docker runner、Kubernetes runner, SSH runner 等\n基礎建置 在本機環境使用 docker-compose 建立 Drone1.10 服務（因為 1.0 版沒有 ssh runner）\n並使用 ngrok 讓外部網路可以連線進入本機 8089 port，作為 github 的 webhook 的 callback 網址\n附註：中間 ngrok 重啟好幾遍，有些截圖的 ngrok 的網址可能會不同\n文章中只要是 ngrok.io 結尾的網址都是 ngrok 服務開通的對外網址\nSTEP 1 docker-compose.yml version: \u0026#39;3.7\u0026#39; services: drone-server: container_name: drone_server image: drone/drone:1.10 ports: - 8089:80 volumes: - /var/lib/drone:/data - /var/run/docker.sock:/var/run/docker.sock restart: always environment: - DRONE_GITHUB_CLIENT_ID=${DRONE_GITHUB_CLIENT_ID} - DRONE_GITHUB_CLIENT_SECRET=${DRONE_GITHUB_CLIENT_SECRET} - DRONE_AGENTS_ENABLED=true - DRONE_RPC_SECRET=${DRONE_RPC_SECRET} - DRONE_SERVER_HOST=${DRONE_SERVER_HOST} - DRONE_SERVER_PROTO=${DRONE_SERVER_PROTO} - DRONE_TLS_AUTOCERT=${DRONE_TLS_AUTOCERT} - DRONE_CRON_INTERVAL=1m - DRONE_USER_CREATE=${DRONE_USER_CREATE} - DRONE_USER_FILTER=${DRONE_USER_FILTER} drone-ssh-runner: container_name: drone-runner-ssh image: drone/drone-runner-ssh depends_on: - drone-server environment: - DRONE_RPC_HOST=${DRONE_SERVER_HOST} - DRONE_RPC_SECRET=${DRONE_RPC_SECRET} - DRONE_RPC_PROTO=${DRONE_SERVER_PROTO} - DRONE_RUNNER_CAPACITY=${DRONE_RUNNER_CAPACITY} drone-docekr-runner: container_name: drone_runner_docker image: drone/drone-runner-docker:1 depends_on: - drone-server volumes: - /var/run/docker.sock:/var/run/docker.sock environment: - DRONE_RPC_HOST=${DRONE_SERVER_HOST} - DRONE_RPC_SECRET=${DRONE_RPC_SECRET} - DRONE_RPC_PROTO=${DRONE_SERVER_PROTO} - DRONE_RUNNER_CAPACITY=${DRONE_RUNNER_CAPACITY} 可以在 docker-compose.yml 的同層用 .env 保存一些機密資料\n例如 ${DRONE_GITHUB_CLIENT_SECRET} 就可以從出版本控制中抽離\n關於設定的參數可以在 官方文件 了解更多\n設置 DRONE_CRON_INTERVAL=1m 讓 drone server 每一分鐘都去偵測有沒有需要執行的 cron\n預設是 30m，所以有人會遇到服務啟動之後 cron 延後被執行\n其實不是延後執行，而是 drone server 偵測未執行 cron 的行為還沒被觸發：參考資料 而在 .env 裡就直接定義名稱就好\n注意的是 DRONE_SERVER_HOST 不需要加上 protocol\n.env # GITHUB OAuth App 的設定 DRONE_GITHUB_CLIENT_ID= DRONE_GITHUB_CLIENT_SECRET= # 管理員帳號設定 DRONE_USER_CREATE=username:ray247k,admin:true # 具有存取權限的人，如果是 github 的話可以使用組織做設定。bitbucket 不行 DRONE_USER_FILTER=ray247k,lemon # Drone Server 的網址，這邊用 ngrok 開做範例 DRONE_SERVER_HOST=56662cd578da.ngrok.io # 如果沒有獨立網址，而是使用反向代理與自簽憑證的話，可能會因為驗證網域失敗報錯，這時候要改為 http 與 false DRONE_SERVER_PROTO=https DRONE_TLS_AUTOCERT=true # 隨便開心亂設定的密碼 DRONE_RPC_SECRET={亂數密碼} # 一次可以執行幾個 JOB，不可為 0 DRONE_RUNNER_CAPACITY=3 # 偵測未執行排程的間隔時間 DRONE_CRON_INTERVAL=1m DRONE_RPC_SECRET 可以使用指令來產生\nopenssl rand -hex 16 STEP 2 如果你本身有網址可以使用就不需要進行此步驟\nNgrok 開放 IP 讓外部連線 把剛剛架設的 drone 伺服器 localhost 的 8089 端口綁定到特定的 ngrok 網址\n這邊的網址等下需要複製貼上綁定到 Github OAuth App 上\nngrok http 8089 STEP 3 - 設定 Github 的 OAuth App 進入 github 的 OAuth App 設定頁面新增 OAuth 應用程式\n右上個人大頭貼-\u0026gt;settings-\u0026gt;左邊頁籤 Developer settings-\u0026gt;OAuth Apps\n開始新建 OAuth App\n填入剛剛建立好的 ngrok 網址，註冊 OAuth 應用程式\ncallback 網址設為 /login\n建立後就要開始串接 Drone CI 到 Github 了\nSTEP 4 修改 Drone 設定 點開剛剛建立的 github APP 設定\n修改剛剛 docker-compose.yml DRONE_GITHUB_CLIENT_ID 和 DRONE_GITHUB_CLIENT_SECRET\n對應頁面上的 Client ID 和 Client secrets 內容\n完成後重啟 drone 的 docker-compose.yml 服務，訪問你的 ngrok 網址查看\n驗證登入後代表你的 Drone CI 串接完成！可喜可賀！可喜可賀！\nSTEP 5 啟用服務 依照剛剛的步驟，應該可以開啟 ngrok 網址看到 Drone 的後台\n一進去是你所有的 Repository\n隨便點一個進去之後按下正中央的 ACTIVAE REPOSITORY 就可以在專案中啟用 webhook 啦\n如果想要確認的話，可以打開 Github 上剛剛的 Repository-\u0026gt;Settings-\u0026gt;Webhooks 應該會看到如圖上的畫面\n有一個 Webhook 正在使用中\n點進去可以看到更多設定，或是查看 Webhook 發送過的請求\n",
    "ref": "/blog/202106-drone-cicd-1-basic-usage/"
  },{
    "title": "Docker 常用指令",
    "date": "",
    "description": "介紹基本 Docker 操作常用指令",
    "body": "一些 Docker 上常用的指令和相關參數使用方法\n實際使用上一定不只這些指令\n服務基本指令 docker stats 顯示容器的資源使用統計 docker start 啟動一個或多個停止的容器 docker stop 停止一個或多個正在運行的容器 docker restart 重啟一個或多個容器 Log 常用指令 $ docker logs [OPTIONS] CONTAINER Options: --details 顯示詳細資料 -f, --follow 追蹤即時 log --since string 顯示自某個 timestamp「之後」的 log，或相對時間，如42m（即42分鐘） --tail string 從 log 末尾顯示多少行內容， 默認是all -t, --timestamps 顯示時間戳 --until string 顯示自某個 timestamp「之前」的 log，或相對時間：如42m（即42分鐘） 使用範例 查看某個時間之後的 log\n$ docker logs -t --since=\u0026#34;2018-02-08T13:23:37\u0026#34; {CONTAINER_ID} 顯示某個時間後的 log，且只要最後 100 行\n$ docker logs -f -t --since=\u0026#34;2018-02-08\u0026#34; --tail=100 {CONTAINER_ID} 查看最近 30 分鐘的 log\n$ docker logs --since 30m {CONTAINER_ID} 查看某個時間區間內的 log\n$ docker logs -t --since=\u0026#34;2018-02-08T13:23:37\u0026#34; --until \u0026#34;2018-02-09T12:23:37\u0026#34; CONTAINER_ID 執行容器 從本地環境的 image 建立 container\n如果不存在從 repository 訪問，private repo 必須要有「登入」行為\nimage的格式可以為[IMAGE NAME]:[TAG]\ndocker run 範例： # 執行nginx docker run -idt nginx # 執行nginx並且暴露port為8080 docker run -idt -p 8080:80 nginx # 執行nginx在8080，在失敗的時候會自動重啟動 docker run -idt -p 8080:80 --restart on-failure nginx # 執行nginx，結束後移除 docker run --rm -idt nginx 常用到的 flag `-d` detach 將 container 置於背景執行 `-i` interactive 維持 STDIN，可互動 `-t` 提供 tty 允許 container 使用 tty `-p` expose socket 對外:對內 port (ex -p 8080:80) `-p Host Port:Docker Port` `--restart` 失敗重啟(always-default, none, on-failure) `--rm` 關閉後 container 自動消滅，若不刪可能會不斷累積，即使已經死掉了 container 相關指令 列出所有活著的容器\ndocker ps 列出所有活的死的容器\ndocker ps -a 進到已存在、執行中的 container 執行指令\ndocker exec -ti nginx bash 取得 container 或是 image 的 Metadata\ndocker inspect {container name} 刪除 docker container\ndocker rm [CONTAINER] image 相關指令 列出所有 image\ndocker images 刪除指定 image\ndocker rmi [IMAGE] 如果對外開放要給別人用怎麼辦\ndocker run -i -t -d -p 80:80 nginx 如果服務遇到意外中斷\ndocker run -i -t -d -p 80:80 --restart always nginx 如果要連node.js\ndocker run -i -d -t -p 80:80 --link node nginx Volume 相關指令 列出所有 volume\ndocker volume ls 清除指定 volume\ndocker volume rm [OPTIONS] VOLUME [VOLUME...] 清除「全部」volume\ndocker volume prune 其他指令 docker build 從 Dockerfile 建立 docker image\n-f 手動指定 Dockerfile 名稱\n# 在目前的資料夾建立image，來源是Dockerfile docker build . -t image-name # 在目前的資料夾建立image，來源是Dockerfile-alt docker build . -t image-name -f Dockerfile-alt docker push / pull 將 docker image 從 repository 上拉/推上去\n要先登入 docker login\ndocker login 登入 docker repository\n",
    "ref": "/blog/202106-docker-common-commands/"
  },{
    "title": "[LeetCode] #11 Container With Most Water (Medium)",
    "date": "",
    "description": "LeetCode 第 11 題 Container With Most Water，難度 Medium",
    "body": "用 PHP 解 LeetCode 系列，Container With Most Water，屬於 Medium\n原始題目 Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai).\nn vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0).\nFind two lines, which, together with the x-axis forms a container, such that the container contains the most water.\nNotice that you may not slant the container.\nExample:\nInput: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Input: height = [1,1] Output: 1 Input: height = [4,3,2,1,4] Output: 16 Input: height = [1,2,1] Output: 2 題目分析 輸入 height 是一串正整數，代表木板高度 找出中間面積最大的兩個數字（容納最多水） 解題過程 這題難在找出中間邏輯，運算本身並不難\n使用雙指針這個方法，從頭尾向內夾找出最大值\n第一指針 p1 理所當然就是陣列初始鍵值 0，第二指針 p2 則是陣列最後一個鍵值\n又因為陣列鍵值是從 0 開始，所以是 陣列長度 - 1\n使用 while 迴圈，因為鍵值交叉後算出來的結果會和先前重複，所以不需要計算\n計算當前兩個指針之間的面積 $area，如果當前面積大於原先最大面積，則設定新最大面積\n因為最大容量是用比較短的一端決定，且向內移動勢必讓寬度下降，若兩端高度不變則面積也會變小\n所以比較兩個指針在陣列中的長度，長度較短的指針向中心移動\n在這個邏輯下，若指針向內移動找到更長的一端，面積才有變大的可能！\nclass Solution { /** * @param Integer[] $height * @return Integer */ function maxArea($height) { $p1 = 0; $p2 = count($height) - 1; $max_area = 0; while($p1 \u0026lt; $p2){ $area = ($p2 - $p1) * min($height[$p1], $height[$p2]); if ($area \u0026gt; $max_area) { $max_area = $area; } if($height[$p1] \u0026lt; $height[$p2]) { $p1++; } else { $p2--; } } return $max_area; } } 結果 ",
    "ref": "/blog/202105-leetcode-no11-container-with-most-water/"
  },{
    "title": "[LeetCode] #540 Single Element in a Sorted Array (Medium)",
    "date": "",
    "description": "LeetCode 第 540 題 Single Element in a Sorted Array，難度 Medium",
    "body": "用 PHP 解 LeetCode 系列，Single Element in a Sorted Array，屬於 Medium\n原始題目 You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.\nFollow up: Your solution should run in O(log n) time and O(1) space.\nExample:\nInput: nums = [1,1,2,3,3,4,4,8,8] Output: 2 Input: nums = [3,3,7,7,10,11,11] Output: 10 題目分析 一個排序過的純整數陣列，其中除了一個數字外，其他數字都是兩兩一組 找出落單的那個整數 解題過程 第一種是用 for 迴圈的做法\n因為陣列為排序好的內容，且只有一個數字單一出現\n所以可以使用 for 迴圈，每次計數器 +2 然後和下一個數字比較。例如 n+1 數字等於 n，則判斷 n+2 和 n+3 是否相等\n若不相等代表該數字只出現一次\n另一種做法是用 foreach 迴圈\n判斷所當前數字和下一個數字相等，則記錄在陣列中\n若當前數字不等於下一個數字，則和陣列比對\n若數字也不在陣列紀錄中，則代表該數字和下一位數不相等，且尚未出現過！\n依據題目規則，可以判斷是唯一數字\n我覺得這種做法比較有彈性\n萬一之後變成有數字會出現兩次以上，或是不只一個數字只出現一次的情況下程式也不需大量調整\n故最後採用第二種方法\nclass Solution { /** * @param Integer[] $nums * @return Integer */ function singleNonDuplicate($nums) { $skip = []; foreach($nums as $key =\u0026gt; $num) { if (isset($nums[$key + 1]) \u0026amp;\u0026amp; $num == $nums[$key + 1]) { $skip[] = $num; } elseif( ! in_array($num, $skip)) { return $num; } } } } 結果 ",
    "ref": "/blog/202105-leetcode-no540-single-element-in-a-sorted-array/"
  },{
    "title": "[LeetCode] #791 Custom Sort String (Medium)",
    "date": "",
    "description": "LeetCode 第 791 題 Custom Sort String，難度 Medium",
    "body": "用 PHP 解 LeetCode 系列，Custom Sort String，屬於 Medium\n原始題目 order and str are strings composed of lowercase letters. In order, no letter occurs more than once.\norder was sorted in some custom order previously. We want to permute the characters of str so that they match the order that order was sorted.\nMore specifically, if x occurs before y in order, then x should occur before y in the returned string.\nReturn any permutation of str (as a string) that satisfies this property.\nNote:\norder has length at most 26, and no character is repeated in order. str has length at most 200. order and str consist of lowercase letters only. Example:\nInput: order = \u0026#34;cba\u0026#34; str = \u0026#34;abcd\u0026#34; Output: \u0026#34;cbad\u0026#34; Explanation: \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; appear in order, so the order of \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; should be \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, and \u0026#34;a\u0026#34;. Since \u0026#34;d\u0026#34; does not appear in order, it can be at any position in the returned string. \u0026#34;dcba\u0026#34;, \u0026#34;cdba\u0026#34;, \u0026#34;cbda\u0026#34; are also valid outputs. 題目分析 order 指定了特定字母之間的順序 輸入的 str 如果包含 order 的字母，則要照順序排列 不在 order 中的剩餘字母則直接接到整理好的字串後面後回傳 解題過程 看起來很簡單，但是實際開始解才發現要考慮的細節很多！\n第一次解題看到範例輸入的 order = \u0026quot;cba\u0026quot;, str = \u0026quot;abcd\u0026quot;\n直覺就是把 order 遍歷一遍，找尋每一個字母有沒有出現在 str 裡面？\n有的話存進結果字串，並且從 str 字串中移除該字母\n最後再將 str 剩下的字母，也就是不在 order 字串中的字母們補上\n這樣的確可以完成這個 testcase 的預期結果 Output = \u0026quot;cbad\u0026quot;\n下一組輸入是 order = \u0026quot;cbafg\u0026quot;, str = \u0026quot;abcd\u0026quot;，並期望得到 Output = \u0026quot;cbad\u0026quot; 也通過了\nclass Solution { /** * @param String $order * @param String $str * @return String */ function customSortString($order, $str) { $order_array = str_split($order); $str_array = str_split($str); foreach($order_array as $char) { $key = array_search($char, $str_array); if ( ! ($key == false)) { $result .= $char; unset($str_array[$key]); } } $result .= implode(\u0026#39;\u0026#39;, $str_array); return $result; } } 事情沒有這麼簡單！下一組輸入是 order = \u0026quot;kqep\u0026quot;, str = \u0026quot;pekeq\u0026quot;，期望得到 Output = \u0026quot;kqeep\u0026quot;\n但是依照這個邏輯我們回傳了 Output = \u0026quot;kqepe\u0026quot;，因為 str 中 e 出現了兩次！\n而我們遍歷的 order 只有一個 e\n如此遍歷 order 是不可行了，題目說 order 每個字母最多出現一次，於是轉換思路改為遍歷輸入字串 str\n首先遍歷輸入字串 str 判斷當前字母是不是存在 order 字串中 若有則存入一個二維陣列，該陣列的第一維是該字母在 order 字串中的位置\n使用二維陣列是為了處理 str 字串中字母重複出現的情境 若該字母不存在 order 中，則存入剩餘字串的變數中 將剛剛的二維陣列依照第一維的值(在 order 中的順序)排序，由小到大(必須保留鍵值) 遍歷二維陣列的每一組字母集合，將其串成字串，並串上剩餘字串 於是這個 testcase 就通過了！以下是完成之後的完整程式碼\nclass Solution { /** * @param String $order * @param String $str * @return String */ function customSortString($order, $str) { $order_array = str_split($order); $str_array = str_split($str); $result_array = []; $result = \u0026#39;\u0026#39;; $else_char = \u0026#39;\u0026#39;; foreach($str_array as $char) { if (in_array($char, $order_array)) { $key = array_search($char, $order_array); $result_array[$key][] = $char; } else { $else_char .= $char; } } ksort($result_array); foreach ($result_array as $char_nub) { $result .= implode($char_nub); } $result .= $else_char; return $result; } } 結果 ",
    "ref": "/blog/202105-leetcode-no791-custom-sort-string/"
  },{
    "title": "伺服器壓力測試 - 使用 Apache Bench",
    "date": "",
    "description": "使用 Apache Bench 進行伺服器壓力測試，測試伺服器性能",
    "body": "伺服器壓力測試，上線前一定要要做，不做不行！你們想想\n你加班幾個月、系統上了線，吃著火鍋還唱著歌，突然主機就被流量灌倒了！\n所以，有事先壓測的系統，才是好系統！\n上線前常常被問到伺服器可以承擔多大的業務，又或是沒人問\n但是有一天服務突然發爐，一次湧進大批使用者\n老闆以為要發大財了，但是先迎接的是伺服器 CUP 使用率超過 100% 然後服務中斷的客訴\n這次介紹的工具可以幫助我們事先發現這個問題，提前做好心理準備做好應變措施\n不論是透過加大主機等級或是限流等手段，來避免服務運行中斷\nApache Bench 在 MacOS 預設已經安裝了 Apache Bench 又簡稱為「ab」\n跟 A/B test 是不一樣的東西，Apache Bench 是 Apache 開發的其中一個開源測試工具\n主要用來測試網站或 API 伺服器負載的極限，透過同時間傳送大量請求到目標使伺服器負載增加\n並查看執行後伺服器的性能測試結果對主機進行調整\n必須謹慎使用，因為其原理和 DDoS (阻斷服務攻擊) 一樣是在於每秒鐘發出大量請求到伺服器！\n使用 使用 ab \u0026lt;url\u0026gt; 開始對某一網址做測試，有很多參數可以使用\n常用參數 使用ab -h指令可以看到\nUsage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform -c concurrency Number of multiple requests to make at a time -t timelimit Seconds to max. to spend on benchmarking This implies -n 50000 -s timeout Seconds to max. wait for each response Default is 30 seconds -b windowsize Size of TCP send/receive buffer, in bytes -B address Address to bind to when making outgoing connections -p postfile File containing data to POST. Remember also to set -T -u putfile File containing data to PUT. Remember also to set -T -T content-type Content-type header to use for POST/PUT data, eg. \u0026#39;application/x-www-form-urlencoded\u0026#39; Default is \u0026#39;text/plain\u0026#39; -v verbosity How much troubleshooting info to print -w Print out results in HTML tables -i Use HEAD instead of GET -x attributes String to insert as table attributes -y attributes String to insert as tr attributes -z attributes String to insert as td or th attributes -C attribute Add cookie, eg. \u0026#39;Apache=1234\u0026#39;. (repeatable) -H attribute Add Arbitrary header line, eg. \u0026#39;Accept-Encoding: gzip\u0026#39; Inserted after all normal header lines. (repeatable) -A attribute Add Basic WWW Authentication, the attributes are a colon separated username and password. -P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password. -X proxy:port Proxyserver and port number to use -V Print version number and exit -k Use HTTP KeepAlive feature -d Do not show percentiles served table. -S Do not show confidence estimators and warnings. -q Do not show progress when doing more than 150 requests -l Accept variable document length (use this for dynamic pages) -g filename Output collected data to gnuplot format file. -e filename Output CSV file with percentages served -r Don\u0026#39;t exit on socket receive errors. -m method Method name -h Display usage information (this message) -I Disable TLS Server Name Indication (SNI) extension -Z ciphersuite Specify SSL/TLS cipher suite (See openssl ciphers) -f protocol Specify SSL/TLS protocol (TLS1, TLS1.1, TLS1.2 or ALL) -E certfile Specify optional client certificate chain and private key 其中最常用的參數是\n-n：測試時執行的 request 數量，預設為 1 -c：一次執行下同時的 request 數量，模擬同時在線使用者數，預設為 1 -e output.csv：將測試的效能原始資料匯出成叫做 output.csv 的 CSV 檔 參考來源：使用 ApacheBench 進行網站的壓力測試 [補充] 調整 php-fpm 參數 蠻有趣的調校經驗，php fpm 的執行緒不太夠用\n沒遇到不會特別研究，先筆記一下：PHP FPM Max Children 再搭配這這篇文章的說明：Linux、nginx、php-fpm 連線數優化 如果是使用 docker 容器的話則是進到 php-fpm 的容器裡，找到/usr/local/etc/php-fpm.d/www.conf設定檔\n可以像是 nginx config 檔案一樣從外部調整後掛載進來，或是在 Dockerfile 打包時候就設定進去\n",
    "ref": "/blog/202105-web-server-stress-testing/"
  },{
    "title": "[LeetCode] #1833 Maximum Ice Cream Bars (Medium)",
    "date": "",
    "description": "LeetCode 第 1833 題 Maximum Ice Cream Bars，難度 Medium",
    "body": "用 PHP 解 LeetCode 系列，Maximum Ice Cream Bars，屬於 Medium\n原始題目 It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nNote: The boy can buy the ice cream bars in any order.\nExample:\nInput: costs = [1,3,2,4,1], coins = 7 Output: 4 Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7. Input: costs = [10,6,8,7,7,8], coins = 5 Output: 0 Explanation: The boy cannot afford any of the ice cream bars. Input: costs = [1,6,3,1,2,5], coins = 20 Output: 6 Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18. 題目分析 輸入所有冰淇淋的價錢列表 costs，以及男孩擁有的所有錢 coins 計算男孩最多可以買幾支冰淇淋 解題過程 這邊採用所謂的：貪婪演算法 ，理論上能買最多冰淇淋的情況下就是全部買便宜的\n所以先對輸入的冰淇淋價錢列表 costs 做排序，排序完之後就是簡單的計算\n當剩餘的錢比冰淇淋多，可購買冰淇淋數量就 +1，並且扣掉買冰的錢\n一般會做 coins \u0026gt;= 0 的判斷\n如果金額小於等於 0，合理推斷他不可能再買任何冰淇淋\n但是這樣會多一個判斷式，執行時間和記憶體用量反而會上升\n原本以為用 break 終止迴圈會更省資源的！\n在一般情況下也不可能存在價錢是負數的冰淇淋，所以就不做剩餘金額判斷\n如果不是特別要跑數字還是應該加一下，比較安全\nclass Solution { /** * @param Integer[] $costs * @param Integer $coins * @return Integer */ function maxIceCream($costs, $coins) { sort($costs); $ice_cream_num = 0; foreach($costs as $cost) { if($coins \u0026gt;= $cost) { $ice_cream_num += 1; $coins -= $cost; } } return $ice_cream_num; } } 結果 ",
    "ref": "/blog/202105-leetcode-no1833-maximum-ice-cream-bars/"
  },{
    "title": "[LeetCode] #1732 Find the Highest Altitude (Easy)",
    "date": "",
    "description": "LeetCode 第 1732 題 Find the Highest Altitude，難度 Easy",
    "body": "用 PHP 解 LeetCode 系列，Find the Highest Altitude，屬於 Easy\n原始題目 There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes.\nThe biker starts his trip on point 0 with altitude equal 0.\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i and i + 1 for all (0 \u0026lt;= i \u0026lt; n).\nReturn the highest altitude of a point.\nExample:\nInput: gain = [-5,1,5,0,-7] Output: 1 Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1. Input: gain = [-4,-3,-2,-1,4,3,2] Output: 0 Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0. 題目分析 輸入一個陣列，代表一個自行車手的海拔變化。從 0 開始騎 每一個點代表和前一個點的海拔「差距」 回傳最高海拔的點 解題過程 用差異計算出當前的真實海拔存進陣列\n再取出最大值，有想過把海拔全部存進陣列，再用 max 函數\n但是想想這樣有點偷懶，而且用陣列儲存後用函式判斷對記憶體負擔可能比較大\n最後改成用單一變數去紀錄最高海拔\nclass Solution { /** * @param Integer[] $gain * @return Integer */ function largestAltitude($gain) { $current_altitude = 0; $max = 0; foreach($gain as $k =\u0026gt; $v) { $current_altitude += $v; if ($current_altitude \u0026gt; $max) { $max = $current_altitude; } } return $max; } } 結果 ",
    "ref": "/blog/202105-leetcode-no1732-find-the-highest-altitude/"
  },{
    "title": "[LeetCode] #1 Two Sum (Easy)",
    "date": "",
    "description": "LeetCode 第 1 題 Two Sum，難度 Easy",
    "body": "用 PHP 解 LeetCode 系列，這次是經典題目 Two Sum，屬於 Easy\n原始題目 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample:\nInput: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1]. Input: nums = [3,2,4], target = 6 Output: [1,2] Input: nums = [3,3], target = 6 Output: [0,1] 題目分析 輸入一個還有多個數字的陣列，以及預期數字 找出陣列中兩數和等於預期數字的值，並用陣列方式回傳兩個數字在陣列中的鍵值 解題過程 直覺的暴力解是兩個迴圈嵌套，類似九九乘法的做法。但是這麼做時間複雜度會很高\n並且內層迴圈會重複遍歷當前鍵值的數字，每次外層迴圈都要先建立新的內層陣列物件才能比對\n對記憶體使用也會增加\n最終使用一次迴圈的解決方案\n遍歷傳入的陣列，比對 target 減掉當前數字的差值是否存在陣列剩餘的數字中\n為什麼說是 剩餘 的數字中呢？先看完程式碼再繼續說明\nclass Solution { /** * @param Integer[] $nums * @param Integer $target * @return Integer[] */ function twoSum($nums, $target) { foreach ($nums as $k1 =\u0026gt; $v1) { unset($nums[$k1]); if ($k2 = array_search($target - $v1, $nums)) { return [$k1, $k2]; } } return []; } } 如果不使用 unset 永久把數字從陣列排除掉\nunset($nums[$k1]); 在輸入 inpout = [3, 3], target = 6，預期結果為 [0, 1] 的時候\n會因為 array_search 在查詢值等於 3 (6 - 3) 的數字的時候，因為第一個數字就是 3\n而造成 $k2 = 0 而輸出 [0, 0]！\n",
    "ref": "/blog/202105-leetcode-no1-two-sum/"
  },{
    "title": "透過 Cloudflare 設定子網域，並客製 GitHub Page 網址",
    "date": "",
    "description": "購買網址後可設定子網域給不同網站使用，本篇以 Cloudflare + GitHub Page 靜態網站為例",
    "body": "之前已經買好了自己的網址，接著要利用 Cloudflare DNS 服務建立子網域\n並且設定給指定的 GitHub Page 專案作為客製網址\n學會這項技能之後，只要有一組主要網址，就可以根據需求產生不同的子網域網址\n各家 DNS 服務提供商都有這個功能，本篇以 Cloudflare 為例\n1. 設定子網域 前往 cloudflare 管理後台，點選 DNS 頁籤\n建立 DNS 紀錄，選擇類型是 CNAME，並指向自己的網域\n2. 設定 GitHub Page CNAME 在靜態網站的根目錄下建立一個檔名為 CNAME 的檔案，並上傳至 GitHub\n內容為子域名的完整網址，像我就是 tech.ray247k.com\n3. 設定 GitHub Page 網址 前往專案 Settings \u0026gt; Pages 頁籤中 Custom domain 區塊\n貼上剛剛在 cloudflare DNS 加入且上傳到專案 CNAME 檔案中的完整網址\n如此就完成了在 cloudflare 建立子網域，並自訂 GitHub Page 的網址\n",
    "ref": "/blog/202105-set-custom-domain-for-github-page/"
  },{
    "title": "設定 Cloudflare 免費 CDN，並啟用 DNS 代管",
    "date": "",
    "description": "從 Google Domains 把 DNS 代管交給 Cloudflare 管理",
    "body": "Google Domains 服務原本就有網域名稱伺服器(Domain Name System, DNS)服務\n透過 DNS 可以管理你的域名，加子網域什麼的\n之所以會把 DNS 轉到 Cloudflare 是因為要用到 Cloudflare 提供的 CND (Content Delivery Network) 以及快取\n如此可以增加網站的載入速度，節省伺服器資源。雖然我用的是 GitHub Page，伺服器資源不用在意\n之後再寫一篇來說明怎麼設定子網域並且設定給 GitHub Page\n有這項技能你只要有一個網域，就可以一直生出新的網址囉！\n就像我買的 ray247k.com，這個部落格的網址是 tech.ray247k.com 就是子網域的應用\n所以一開始才選擇 .com 的頂級網域，而不是 .dev\n設定 cloudflare 代管子網域和 DNS 1. 註冊 cloudflar 沒什麼難度，就照著網站流程註冊就好\n2. 跟著 cloudflare 引導加入網站(Domain) 把之前買的網址加入管理列表\n3. 調整 DNS 伺服器 加入網站後我們會在 cloudflare 看到這個提示\n接著去 Google Domain 那邊 DNS 的頁籤畫面\n可以看到預設的 DNS 是上一步驟中 cloudflare 叫我們移除的 DNS 伺服器\n點「使用自訂名稱伺服器」換成他給的兩個網址即可\n4. 收到信通知網站 cloudflare 已經啟用 5. 啟用一律使用 HTTPS 將所有透過「http」協定的所有請求重新導向至「https」\n因為 cloudflare 有預設的 SSL/TLS 憑證，並不用自己購買就可以開啟 https\n如此在瀏覽器網址最前面有「鎖頭」顯示為安全的連線！\n我們只需要做去啟用重新導向的服務\n前往SSL/TLS 頁籤，往下滑看到「一律使用HTTPS」把他點成開啟，然後等待陣子讓設定生效\n啟用之後，就算你使用 http 造訪網頁也會自動導轉到 https 開頭的網頁囉！\n",
    "ref": "/blog/202105-cloudflare-dns-add-domain/"
  },{
    "title": "如何從 Google Domains 購買屬於自己的網址",
    "date": "",
    "description": "購買屬於自己的網址 - 使用Google Domains 教學",
    "body": "以前都一直是使用免費的部落(blogger)，隨著近幾年個人品牌意識崛起，以及覺得原本部落格不敷使用\n且搬家非常不方便，還有不能自訂 SEO 和埋設追蹤碼。在媒體業做過就會想自己動手處理這些\n當初一度從 blogger 搬到 medium，又搬回 blogger轉移十分麻煩\n而且還有程式碼內容格式會跑掉，以及想都用 markdown 語法紀錄等等原因\n興起了自架的想法，一方面也是想要作為展現自己的能力的平台\n最終決定使用 Hugo 這套框架來自架部落格\n想好了要自架之後面臨有好幾個選項，直接架在 github page 並使用預設的網址看來很方便，而且也沒什麼缺點\n不過就是想要有個「自己的」感覺，不寄人籬下。未來萬一又不自架了，網址的 SEO 是自己可以帶著走的\n前言說到這，來開始買網址\ngoogle domain 網址可以在很多地方買到，從最有名的 Godaddy 到最不推薦的 PChome\n這次選擇 Google Domains 這個服務，主要就是想嚐鮮，試試看別人沒用過的服務\n並且 Godaddy 第一年雖然便宜，但是第二年價錢調漲之後反而不如 Google Domains 每年固定的價錢\n當然也可以第一年買 Godaddy，快到期再轉移到 Google Domains。這樣似乎是最便宜的做法\n但是我懶得轉換，不想要未來為了轉換多花心思\n1. 查詢想買的網址有沒有被註冊 前往：Google Domains 查詢你想買的網址\n以我現在使用的網址為例，可以看到不同頂級網域會有不同價錢\n選擇你喜且順眼的，不建議使用太奇怪的名稱\n開發者的話，可以考慮看看 Google Domains 獨家販賣的 .dev！\n但是因為我是要多個站用子域名共用的（之後會有發一篇教手把手教學），不一定全部是面向開發者\n所以最後還是選擇了每年固定 12 美金的 .com 的域名\n不要因為一時的中二病讓自己的網站變成黑歷史！但是我承認我有查奇怪的名稱，例如 .in 這個頂級域名\n教練！我好想要 gg.in.in這個網址，但是我真的只有查而已，信我！因為 in.in 不給買\n2. 前往購物車準備結帳 就跟著網站步驟輸入資料＋按下一步，最好都照實填寫\n畢竟是自己個人品牌用的網域，真的出問題還是要能連絡上比較好\n隱私保護服務也要啟用，這服務在 Godaddy 可是要收錢的呢！\n╰(⊙Д⊙)╮佛心公司╭(⊙Д⊙)╯\n╭(⊙-⊙)╯佛心公司╰(⊙-⊙)╮\n建議開啟自動續約功能，否則要是突然某一天網址沒續約不能使用導致網站連不上可就麻煩了\n之前某科技內容網站就因為沒續約，網站一整個早上無法造訪\n一開始以為是程式部署出問題，查了半天發現是網址到期沒續約而鬧了笑話\nGoogle Domains 的結帳頁面好像有改版過\n我看網路其他文章，在最後輸入信用卡號的時後都是輸入完卡號就直接送出結帳\n而我是遇到他要我輸入卡號外還要輸入 zip code，而且必須是美國的格式\n如果你們也有遇到需要輸入 zip code 的情況\n我是使用 90004，這是一個 Los Angeles\tLos Angeles\tCalifornia (CA) 的郵遞區號\n結帳完成之後應該就會收到信告訴你可以開始使用剛剛買到的網址囉！\n其他關於怎麼設定 Github Page 自訂網址，和使用 cloudflare 管理子網域就留在之後的文章說明了\n",
    "ref": "/blog/202105-how-to-buy-a-domain-from-google/"
  },{
    "title": "設定 ssh 金鑰登入遠端主機",
    "date": "",
    "description": "使用 ssh key 登入遠端主機而不使用密碼登入",
    "body": "一般登入伺服器是使用帳號與密碼進行登入，但是密碼可能會因為抄錄或是傳遞給人而外洩\n安全性的程度會比較沒有像SSH key 那麼安全，而且使用SSH key 登入可以就不用每次手動輸入密碼\n建立登入端的 ssh key 使用者端建立 ssh key，使用指令 ssh-keygen 注意：ssh key 要是 RSA 的格式，如果是 OPENSSH 會不斷的報錯\n參考資料：mac majave 10.14.1 ssh-keygen 金鑰格式問題 預設會產生在 .ssh/ 路徑下\n如果是用複製別人的 id_rsa 和 id_rsa.pub 的話需要重新設定權限，否則會報錯\nchmod 600 id_rsa chmod 644 id_rsa.pub 權限說明 -rw------- (600) -- 只有屬主有讀寫權限。 -rw-r--r-- (644) -- 只有屬主有讀寫權限；而屬組用戶和其他用戶只有讀權限。 -rwx------ (700) -- 只有屬主有讀、寫、執行權限。 -rwxr-xr-x (755) -- 屬主有讀、寫、執行權限；而屬組用戶和其他用戶只有讀、執行權限。 -rwx--x--x (711) -- 屬主有讀、寫、執行權限；而屬組用戶和其他用戶只有執行權限。 -rw-rw-rw- (666) -- 所有用戶都有文件讀、寫權限。這種做法不可取。 -rwxrwxrwx (777) -- 所有用戶都有讀、寫、執行權限。更不可取的做法。 以下是對目錄的兩個普通設定： drwx------ (700) - 只有擁有者可在目錄中讀、寫。 drwxr-xr-x (755) - 所有用戶可讀該目錄，但只有擁有者才能改變目錄中的內容 遠端主機設定 登入遠端主機之後，檢查使用者家目錄是否存在 ./ssh/authorized_keys 檔案\n若沒有則自行建立，並設定權限 chmod 600 authorized_keys\n檔案內容為剛剛產生的 id_res.pub 的內容\n範例：\nssh-rsa AABAB3NzaC1yc2Gmy80/{...中略...}/UD9CBSzNAya7r6w== 補充 讓雲端主機可以存取版本庫 建立 GCP 使用者後，依照上面做法產生 ssh key 把 public key 加到版本庫的 ssh key 列表中 ",
    "ref": "/blog/202104-use-ssh-key-login-remote-server/"
  },{
    "title": "雲端主機啟動 Docker 服務",
    "date": "",
    "description": "介紹如何在雲端主機啟用 docker 服務",
    "body": "新開主機啟用 docker 與 docker-compose 服務的操作步驟\n安裝 Docker sudo apt-get install docker.io sudo apt install docker.io 將使用者加入群組 此操作可以讓使用者不需要 sudo 就執行 docker 指令，為非必要步驟\nsudo groupadd docker # 先確定有 docker 這個使用者群組 sudo usermod -a -G docker $USER # 當前使用者加入 docker 群組 # 或是 sudo usermod -a -G docker user_name # 將使用者帳號「user_name」加入群組，當有多個使用者的時候很好用 完成後記得重新登入遠端主機\nref: Ubuntu Linux 安裝 Docker 步驟與使用教學 也有人直接將使用者加入 sudoer 群組中，有一樣的結果\n安裝 docker-compose sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version ref: Install Docker Compose 如此就可以在新開的雲端主機進行 Docker 容器的操作\n",
    "ref": "/blog/202103-enable-docker-service-in-remote-server/"
  },{
    "title": "PostgreSQL 資料庫建置 - 使用 Docker",
    "date": "",
    "description": "介紹如何使用 Docker 建置 PostgreSQL 資料庫",
    "body": "使用 Docker 來建置一個 PostgreSQL 資料庫\n包含 資料庫建置、資料持久化、使用 GUI 操作資料庫\nPostgreSQL 基礎教學：後端前進PostgreSQL 系列 環境建置 - 使用 Docker-compose 使用的映像檔：postgres: alpine 參考文章：Getting Started with PostgreSQL using Docker-Compose docker-compose.yml version: \u0026#39;3\u0026#39; services: postgres: container_name: postgres ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:alpine\u0026#34; volumes: - database-data:/var/lib/postgresql/data # persist data even if container shuts down restart: always environment: POSTGRES_USER: superuser POSTGRES_PASSWORD: superpassword POSTGRES_DB: demo_db volumes: database-data: # named volumes can be managed easier using docker-compose 啟動容器：\ndocker-compose up GUI 安裝 因為 sequel ace 不支援 PostgreSQL 所以另外裝一個 GUI 來用\n安裝 DBeaver 會需要安裝 JAVA 包\nbrew install --cask dbeaver-community 存取在遠端的 PostgreSQL container 取得該遠端的對外 ip 作為 host 之後連線到指定的 port (5432)\n就可以在其他機器上存取 PostgreSQL container\n資料持久化 (persist data) 官方文件說明 使用docker-compose啟動服務時，初始化資料庫和資料(以Mysql為例) Different Types of Volumes named volume： docker-compose up 啟動容器 docker volume ls 確認有建立 volume docker-compose stop 停止容器 docker-compose up，使用 GUI 連線容器確認資料有被重新掛載 docker-compose down，移除容器 docker ps -a 確認容器確實被移除 docker-compose up，volume 成功掛載回去 host volume 調整容器內 volume 目標資料夾位置到本機特定資料夾下\n如果有多台容器需要一起掛載同一份資料：官方文件 這個做法使用 docker volume ls 就不會有結果，要自己去看指定的路徑。因為管理 volume 已經不是透過 docker\nversion: \u0026#39;3\u0026#39; services: postgres: container_name: postgres ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:alpine\u0026#34; volumes: - ./database_data:/var/lib/postgresql/data # persist data even if container shuts down restart: always environment: POSTGRES_USER: superuser POSTGRES_PASSWORD: superpassword POSTGRES_DB: database_name 調整 yml 檔 service 內 volumes，改為指定路徑 docker-compose up 啟動容器 使用路徑管理 volume 後 docker volume ls 不會有反應 查看指定路徑 ./database_data，volume 檔案成功寫入 docker-compose up，使用 GUI 連線容器確認資料有被重新掛載 docker-compose down，用 docker ps -a 確認 container 確實被移除 docker-compose up，volume 成功掛載回去 補充 如果在同一台機器上想要啟用多個 PostgreSQL 容器\n則 5432 port 會被佔用，當然可以將外部 port 改為不衝突的 port\n但是內部 port 使用的依然是 5432 如果在容器網路內直接溝通，例如 Laravel 的 .env 設定的 port\n當透過容器外部網路線連線時使用調整後錯開的 port 連線正常\n但是當執行 php artisan migrate 之類指令，執行者是容器時\n要使用的卻是內部的 5432 port，如此在管理上會十分麻煩\n此情境下可以透啟動容器時指定內部運行的 port 來解決\npostgre: container_name: stage_postgre ports: - \u0026#34;5430:5430\u0026#34; image: \u0026#34;postgres:12.6\u0026#34; volumes: - /project/database/stage/database_data:/var/lib/postgresql/data # persist data even if container shuts down command: -p 5430 environment: POSTGRES_USER: ${DB_USER} POSTGRES_PASSWORD: ${DB_PASSWORD} POSTGRES_DB: ${DB_NAME} restart: always 如上面的設定中 command: -p 5430 指定了內部 postgres 使用的 port\n所以在 ports: 設定中就直接將外部 port 5430 指定給內部的 port 5430\n這樣不管在容器內或外部都可以使用一樣的 port 來進行連線\n使用 GUI 存取在遠端的 PostgreSQL container 取得該遠端的對外 ip 作為 host 之後連線到指定的 port (5432)\n就可以在其他機器上存取 PostgreSQL container\n",
    "ref": "/blog/202103-build-postgresql-database-useing-docker/"
  },{
    "title": "反向代理 - 在 Docker 環境建置",
    "date": "",
    "description": "你可能知道反向代理，但你試過在 Docker 做嗎",
    "body": "反向代理的基本說明，以及在 Docker 容器環境中如何建置反向代理\n反向代理說明 系統設計 - 正向代理跟反向代理 不同實體主機 使用 nginx proxy-pass 目標 使用者造訪指定網頁路徑 /new_path 或是整個跳轉 / 設定測試機 nginx proxy_pass 使其跳轉到其他主機專案相同路徑下 確認使用者 IP 沒有被變成為代理伺服器的 IP 確認在代理目標的專案可以讀取 Cookie 確認 Post 請求的 payload 也會被轉送過去 設定 nginx config 第一台主機的 nginx 設定 # 把所有前往 domain/new_path 的請求反向代理到另一台主機上 location /new_path { # 要代理到哪個網址 proxy_pass http://laravel55.test.com; # 傳送使用者真實 IP 到目標主機 proxy_set_header X-Real-IP $remote_addr; # 設定伺服器為代理前的伺服器，否則 HTTP_HOST 會變成 proxy 那台代理伺服器的位址 proxy_set_header Host $host; # 設定 cookie 轉發 proxy_set_header Cookie $http_cookie; # 用來確認最初的用戶端原始 ip 位置 proxy_set_header X-Forwarded-Host $host; # 記錄從使用者端出來經過的每個代理 X-Forwarded-For: \u0026lt;client\u0026gt;, \u0026lt;proxy1\u0026gt;, \u0026lt;proxy2\u0026gt; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 識別網路連線協定 proxy_set_header X-Forwarded-Proto $scheme; # 隱藏伺服器資訊 proxy_hide_header Server; proxy_hide_header X-Powered-By; # 因為自行加大 header 所以把空間也加大 proxy_headers_hash_bucket_size 128; proxy_headers_hash_max_size 512; } 第二台主機的 nginx 設定 server { listen 80; server_name ray200; root /home/toc/www/laravel55/public; access_log /var/log/nginx/www/laravel55.access.log; error_log /var/log/nginx/www/laravel55.error.log; index index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~* \\.(jpg|jpeg|gif|css|png|js|ico|html|svg|ttf|woff|woff2|eotD)$ { access_log off; expires max; } location ~ \\.php$ { include snippets/fastcgi-php.conf; # php-fpm 的位置 fastcgi_pass 127.0.0.1:9000; } } 注意事項 server_name必須要是 proxy_pass 過來那台的 domain\n如果不這樣設定，proxy_pass 過來會進到預設的 server_name 下 在程式中判斷真實 IP 的方法要改成讀讀取 header 中的x-real-ip才是真實使用者 ip 位置 確認 cookie 可以讀取 如果設定 nginx 有設定proxy_set_header Cookie $http_cookie;\n那dump($_COOKIE);可以取得 cookie，但是 Laravel 內建的request()-\u0026gt;cookie();卻沒有取到值\n因為 Laravel 預設的 web middleware \\App\\Http\\Middleware\\EncryptCookies::class, 中\n要求 cookie 是加密過後的，如果沒有加密當然就讀不到\n解決方案一個是在 class EncryptCookies中的$except加入要排除的 cookie 名稱\n另一個就是直接把 middleware 註解掉，解決發生問題的 code\n使用 Docker 會點進這篇文章應該是比較想知道這部分\n架構示意圖 參考資料：How to set up NGINX Docker Reverse Proxy? 步驟 1. 手動建立 network 反向代理會根據載入的設定檔把請求導向到指定的容器名稱內\n故代理的目標容器必須在同一網路內，才能直接使用容器名稱做代理目標\n因為不想讓 network 前面帶上 prefix，還有避免依賴，所以手動建立 network\ndocker network create nginx-network 這個情境屬於來自外部的 nginx-proxy，要多給一個external network 有需要連接到這個 network 裡面的服務都要設定\nnetworks: default: external: name: nginx-network 如此就可以讓不同 docker-compose.yml 中的服務互相溝通：官方說明 2. 建立測試用的服務 因為懶得建太複雜的服務，所以抓現成的「portainer」服務來做為 proxy 的目標\n只是為了要有一個只要 docker-compose up 就可以運行的服務，也可以換成自己比較熟的映像檔\n為了測試從 80 port poxy 到其他 port，所以這邊開在 8080 port\n服務啟動之後可以先去localhost:8080查看 portainer 服務有沒有啟動\nversion: \u0026#39;3\u0026#39; networks: default: external: name: nginx-network services: portainer: container_name: nginx_test_portainer image: portainer/portainer-ce command: -H unix:///var/run/docker.sock restart: always ports: - 8080:9000 volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data volumes: portainer_data: 3. Nginx 的 proxy 設定 3.1 設定docker-compose.yml version: \u0026#39;3\u0026#39; networks: default: external: name: nginx-network services: nginx: container_name: test_nginx image: nginx:1.18 ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - ./conf.d/:/etc/nginx/conf.d/ - ./ssl/:/ssl/ 3.2 設定 mount 進去給反向代理伺服器使用的 nginx config 可以看到底下設定中，我們把所有發往「test.example」網址的請求都轉到\nhttp://nginx_test_portainer:9000\n在容器中使用的模式是\nhttp://{container_name}:{port}\n可以看到「container_name」對應了上面建立測試服務 時候使用的容器名稱\n而「port」對應到了容器的內部 port！\n這邊特別把上面的容器內外使用的 port 區隔開來顯示差別，我們代理的目標是內部的 9000 port\n而不是對外的8080port\nserver { listen 80; listen [::]:80; server_name test.example; return 301 https://$host$request_uri; } server { listen 443 ssl; listen [::]:443 ssl; server_name test.example; ssl_certificate /ssl/ssl.crt; ssl_certificate_key /ssl/ssl.key; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { proxy_set_header Host $host; proxy_set_header Cookie $http_cookie; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $host; proxy_pass http://my_portainer:9000; } } 要特別注意的是，這邊 proxy_pass 目標網址中的http://不可以省略！\n如果轉址過去的網址有自己的 https 證書驗證(例如另一個 nginx 環境)，則必須改成https://開頭\n參考資料：What value should I use for Nginx proxy_pass running in Docker? 3.3 編輯etc/hosts 127.0.0.1 test.example 接著啟動 nginx 服務，用瀏覽器開啟剛剛設定的test.example\n正確設定的話，監聽 80 port 的 nginx 服務應該會把所有目標是 test.example 的請求\n利用 proxy_pass 送到 portainer 容器的指定 port，所以畫面上會顯示 portainer 服務的畫面\n要在所有服務都啟動之後再啟動反向代理服務，否則會報錯指出被代理的容器目標不存在\n注意事項 如果要把全部沒有匹配到的server_name請求統一處理\n可以在指定的 nginx config 加上 default_server 定義\n如果沒有定義 default_server，則第一個 server 會被預設成 default server\nserver { listen 8080 ssl default_server; listen [::]:8080 ssl default_server; ssl_certificate /ssl/ssl.crt; ssl_certificate_key /ssl/ssl.key; # Virtual Host Domain server_name _; # where code is root /var/project/dev/www/my_backend/public; index index.php index.html index.htm; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri /index.php =404; fastcgi_pass dev_php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ /\\.ht { deny all; } } 因為要處理沒有被其他 server_name 捕獲的請求\n所以 server_name 就不是什麼重點，可以用「_, __, ___」都可以\n這個情境會發生在當前端的 API 設定檔使用的路徑網址是指定後端容器名稱的時候\n因為不是使用網址經過反向代理轉發，而是直接將請求發至容器\n而這個 nginx 容器中又有多個 server config 設定\n所以 nginx 沒有「server_name」可以判斷要使用哪個 config 設定\n案例說明 同一個 nginx 容器(dev_nginx) 裡面有多個 server config\nalex_backend john_backend dev_backend 如果現在有一個在同樣 docker network 的前端容器要打 API 到 dev_backend\n他會在設定檔指定網址是 dev_nginx\n這時候問題就來了，當 dev_nginx 收到這個請求會不知道是發給誰的\n如果沒有設定 default_server，就會把請求派發給第一個 server，也就是 alex_backend\n這不是我們要的結果\n所以會把「dev_backend」設定為「default_server」\n如此之後，只要是送進這個容器的請求\n若沒有被其他設定檔捕獲，就會被送進 dev_backend 處理\n",
    "ref": "/blog/202102-reverse-proxy-in-docker-service/"
  },{
    "title": "Laravel 執行環境建置",
    "date": "",
    "description": "介紹 Laravel 執行環境所需要的環境設定，包含 composer 安裝",
    "body": "開發 Laravel 專案所需要做的設定與套件安裝，不論是在遠端主機或是本機都適用\n更新套件包 sudo apt-get update 安裝 composer php -r \u0026#34;copy(\u0026#39;https://getcomposer.org/installer\u0026#39;, \u0026#39;composer-setup.php\u0026#39;);\u0026#34; php -r \u0026#34;if (hash_file(\u0026#39;sha384\u0026#39;, \u0026#39;composer-setup.php\u0026#39;) === \u0026#39;756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3\u0026#39;) { echo \u0026#39;Installer verified\u0026#39;; } else { echo \u0026#39;Installer corrupt\u0026#39;; unlink(\u0026#39;composer-setup.php\u0026#39;); } echo PHP_EOL;\u0026#34; php composer-setup.php php -r \u0026#34;unlink(\u0026#39;composer-setup.php\u0026#39;);\u0026#34; 執行結果 Composer (version 2.0.12) successfully installed to: //composer.phar Use it: php composer.phar 將指令改成全域 執行後可以直接使用 composer 指令操作\n很方便，建議要執行這個步驟\nmv composer.phar /usr/local/bin/composer 安裝 PHP extension 以 PHP 版本 7.4 的主機為例\n要在容器外運行 composer install，需要安裝以下 extension\nphp7.4-mbstring php7.4-cli php7.4-gd ext-dom(php-xml) zip unzip php7.4-zip apt install php7.4-cli apt-get install mbstring ext-dom zip unzip php7.4-zip php7.4-mbstring php-xml php7.4-gd 安裝資料庫對應的 extension 依照專案使用的資料庫自行安裝\n例如：\nphp7.4-pgsql php7.4-mysql php artisan 必要套件 php artisan 要在 php 指令介面(php Command Line Interface) 下執行\n所以必須依照自身 php 版本安裝 cli 套件\napt install php7.4-cli 以上就是建置 Laravel 環境所需要的最基本設定\n若是容器化的使用者，在打包 php 映像檔的時候一併執行即可\n",
    "ref": "/blog/202102-laravel-environment-basic-settings/"
  },{
    "title": "Ngrok 讓 localhost 可以被外部連線",
    "date": "",
    "description": "Ngrok 開發測試 webhook 的利器",
    "body": "ngrok 做為一個轉發的伺服器，他可以把外界的請求轉發到你指定的 Port\n使用的背景原理是連接到 ngrok 雲端伺服器將你本機指定的地址公開\n再將由 ngrok 一串公開的網址來存取內容\n他的優點是快速而且還提供了 https 的服務讓你使用上更安全，甚至你還可以設置密碼保護\n官方文件與載點：https://ngrok.com/download 安裝 Mac brew install ngrok Linux 確認自己的主機硬體架構\ncat /proc/cpuinfo 再去官網下載指定檔案依照官網安裝 或是直接使用 snap 安裝\nsudo apt update sudo apt install snapd sudo snap install ngrok 使用 啟動並監聽 8080 Port\nngrok http 8080 就可以看到對外開放的網址\n註冊 ngrok 不註冊的話過一段時間就會被斷線，開發階段使用免費版本就足夠了\nNgrok authtoken 頁面 複製 Authtoken 之後到 terminal 輸入\nngrok authtoken {Your Authtoken} 看到以下訊息代表認證完成\nAuthtoken saved to configuration file: /Users/user_name/.ngrok2/ngrok.yml ",
    "ref": "/blog/202102-ngrok-share-your-local-development-site/"
  },{
    "title": "Portainer - 視覺化管理 Docker 的工具",
    "date": "",
    "description": "介紹如何使用 Portainer 視覺化管理 Docker 服務",
    "body": "本機開發大部分使用指令操作，或是使用 Docker 本身的 GUI 介面管理服務\nPortainer 是一個 open-source 的 UI tool\n可以查看 docker image, container，並執行 start, stop, restart, remove 等動作\n也可查看每個 container 的 log 及 error\n在雲端主機上啟動服務的話，即使沒有 Docker 執行權限的人也可以透過帳號密碼登入\n使用視覺化的介面進行 Docker 服務的各種管理\nDockerhub image: portainer/portainer-ce docker-compose.yml version: \u0026#39;3\u0026#39; services: portainer: image: portainer/portainer-ce command: -H unix:///var/run/docker.sock restart: always ports: - 9000:9000 - 8000:8000 volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data volumes: portainer_data: 為了 edge agent 而開啟 8000 port：文件說明 補充 如果遠端主機不想開放 port 造成任意使用者都有機會開啟後台畫面\n可以使用超外道的連線方式：How to Create SSH Tunneling or Port Forwarding in Linux ssh -i ~/.ssh/id_rsa -L 8081:localhost:9000 ray@{你的遠端主機 IP} 在容器啟動後可以在本機終端機執行\n接著就可以在本機 localhost:8081 看到我們在遠端主機的 9000 port\n原理是透過 ssh 連線將本機 8081 port 的請求轉發到遠端主機的 9000 port\n這個方法不論遠端防火牆有沒有開放該 port 都可以執行，十分不講武德\n也不限於 Portainer 服務才能使用\n",
    "ref": "/blog/202101-portainer-open-source-container-management-gui/"
  },{
    "title": "Docker 筆記 3 - docker-compose",
    "date": "",
    "description": "介紹如何使用 docker-compose 管理多個容器",
    "body": "如果同時要管理彼此是有關連的多個 docker 容器，單純使用 docker 指令必須要自行記得容器之間的關聯\n而使用 docker-compose，則可以輕鬆定義多容器服務\n簡介 Docker for Mac 預設 python 所寫成的工具 由yaml定義 設定檔為 docker-compose.yml 依賴 docker 版本 官方文件：docker-compose 設定檔構成 docker-compose.yml 由兩個部分所構成\nversion（版本要字串） services key -\u0026gt; DNS name(hostname) docker-compose 範例 其他工具 docker-swarm 看成 kubernetes 的分身 落地方便（kubernetes 準備工作很多） 高可用性 HA 價格便宜 組成（Node）\n分兩個節點。 Manager： 分派任務給 worker node 同時也是 worker node 控制整個 Docker Swarm 的部署 主控制節點 如果死掉，整個 docker swarm 就死掉了 可以有多台 manager，但只有一台 \u0026amp;*$%^^#??? Worker： 被分派任務 不會主動分派任務 不知道其他 worker node 可以隨時 rolling update。 在所有 node 底下： Service： 一個Service包含一種container Service啟動不代表container啟動 可以對container進行health check Service可以啟動複數個container(replicas) Task 主要是由Service帶起來的 代表在docker container內執行的指令 task會在node上到執行結束為止 ",
    "ref": "/blog/202101-docker-note-3-introduce-docker-compose/"
  },{
    "title": "Docker 筆記 2 - 基本使用",
    "date": "",
    "description": "Docker 的基本使用方法",
    "body": "容器化可以隔離不同環境，將環境打包後工程師可以專注開發，不用花過多心力在開發環境安裝上\n而 Docker 是目前非常成熟且流行的一個容器化技術\n玩轉docker指令 查看容器資訊 docker ps 列出所有運行中的容器 docker ps -a 列出所有存在的容器 看 log docker logs [CONTAINER] 印出 log docker logs -f [CONTAINER] 持續印出最新 log 執行容器 從本地環境的 image 建立 container\n如果不存在從 repository 訪問，private repo 必須要有「登入」行為\nimage的格式可以為[IMAGE NAME]:[TAG]\ndocker run 範例： # 執行nginx docker run -idt nginx # 執行nginx並且暴露port為8080 docker run -idt -p 8080:80 nginx # 執行nginx在8080，在失敗的時候會自動重啟動 docker run -idt -p 8080:80 --restart on-failure nginx # 執行nginx，結束後移除 docker run --rm -idt nginx 常用到的 flag -d detach 將 container 置於背景執行 -i interactive 維持 STDIN，可互動 -t 提供 tty 允許 container 使用 tty -p expose socket 對外:對內 port (ex -p 8080:80) -p Host Port:Docker Port --restart 失敗重啟(always-default, none, on-failure) --rm 關閉後 container 自動消滅，若不刪可能會不斷累積，即使已經死掉了 常用指令 進入運行中的容器，並開啟終端機指令介面\ndocker exec -ti [CONTAINER] bash 取得 container 或是 image 的 Metadata\ndocker inspect [CONTAINER] 刪除 docker container\ndocker rm [CONTAINER] 刪除 docker image\ndocker rmi [IMAGE] 查看容器運行 process\ndocker top [CONTAINER] 其他指令 使用 Dockerfile 建立 docker image\n-f 手動指定 Dockerfile 名稱\n# 在目前的資料夾建立image，來源是Dockerfile docker build . -t image-name # 在目前的資料夾建立image，來源是Dockerfile-alt docker build . -t image-name -f Dockerfile-alt 將 docker image 從 repository 上拉/推上去\n要先登入 docker login\ndocker push / pull 登入 docker repository\ndocker login 怎麼寫自己的dockerfile 先註冊 Docker Hub Alpine Linux 體積非常的小 (5MB) 有完整的Linux架構 豐富的元件支援 常見 Dockerfile 命令 基本 FROM：指定基底 image，不指定版本的話預設都是 latest RUN： docker build 時候執行命令，裝一些相依套件。 每一個 RUN 都是獨立事件 ARG： container docker build 時的建置參數 無法在 container 中被使用 ENV： printenv 容器內使用的環境變數 格式：ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; 或是 ENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt; 檔案複製 COPY： 複製「來源文件\\目錄」到的容器中的「文件\\目錄」中 COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;source path\u0026gt;... \u0026lt;dist path\u0026gt; dist path 可以是 Container 內的絕對路徑，也可以是相對於 WORKDIR 的相對路徑 會保留來源數據的各種屬性 ADD： 強化版的 COPY ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;source path\u0026gt;... \u0026lt;dist path\u0026gt; 允許 source path 是一個 URL 文件權限自動設置為 600 執行指令 ENTRYPOINT： Container 起來預設會執行的指令 最後指令，啟動時要保持在前景的指令 CMD： container起來預設會執行的指令（或參數） ENTRYPOINT, CMD 同時存在 CMD 當參數使用 WORKDIR(cd + mkdir): 初始容器內工作目錄 指令差異 ARG vs ENV ARG 由建立 image 的時候帶入\ndocker build . --build-arg FOO=bar ENV是在docker container內作為環境變數使用\nCMD vs ENTRYPOINT ENTRYPOINT 在 container 啟動時預設執行 CMD 在 ENTRYPOINT 存在時作為參數使用\nFROM ubuntu ENTRYPOINY [\u0026#34;ping\u0026#34;] CMD [\u0026#34;localhost\u0026#34;] COPY vs ADD COPY 適用在將本地端的檔案複製到container內\nADD 適用將遠端的檔案複製到container內\n除錯 docker: Got permission denied\n這個錯誤是因為當前使用者的權限不足\n可以將使用者提升至 root 保證權限\n但是比較安全且正確的做法應該是\n建立 docker 執行群組 將使用者加入 docker 群組 指令如下，需要退出重新登錄後才會生效！\nsudo groupadd docker sudo usermod -aG docker user_name ",
    "ref": "/blog/202101-docker-note-2-basic-usage/"
  },{
    "title": "Docker 筆記 1 - 認識 Docker",
    "date": "",
    "description": "介紹什麼是 Docker，以及容器化技術",
    "body": "容器化可以隔離不同環境，將環境打包後工程師可以專注開發，不用花過多心力在開發環境安裝上\n而 Docker 是目前非常成熟且流行的一個容器化技術\n將OS做為 Application 化\n所有 container 只能允許一個指令執行\n預設權限都會是 root\n商業來說\n方便部署 可攜性 容器進化史 What is a Container? 名詞介紹 Stateful Stateless：在未設的前提之下，每次建立時會消除舊的資料 Repository 就像是 apt、brew 或是 yum 的來源一樣 存了很多 image (Package) Image 相當於 Package 產生特殊的 cache，本地有 cache 的話，就不需再從 Respository (如 Docker hub) 抓 Container 由 image 建立而成 相當於一個一個的程式，可以持續執行 必須要有一個 foreground 在跑的程式 Network none：沒有網路 bridge：區網 overlay：不同網段 container：Docker 預設的網路連線, 無法由外部直接進來 host：與本機共用網路介面 Volume Docker 內的持久化(Stateful)空間，可以 stateful 的秘密(空間) 等同本機空間 架構 生命週期 client 呼叫 docker daemon docker daemon 與 host network / host cgroups 溝通 判斷 docker container 是否存在 從 local image 將 layer 解開 如果 local image 不存在的話從 repository 拿 建立 docker container 學習資源 線上練習環境：Play with Docker Docker 基本觀念與使用教學：自行建立 Docker 影像檔 - G. T. Wang 鸟瞰Docker 30 天與鯨魚先生做好朋友 ",
    "ref": "/blog/202101-docker-note-1-what-is-docker/"
  },{
    "title": "[Express+Vue 搭建電商網站] 22 使用 Docker 將專案容器化",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用 Docker 將專案容器化",
    "body": "接著我們會把整個專案使用 Docker 來將服務容器化，也會在 MongoDB 設定身份驗證機制\n如果對 Docker 不熟的話必須先去了解，才有辦法進行\n或是直接跳過這個章節 交給熱心的攤主處理\n在這邊我們會用到三個容器\nnginx 伺服器：處理 Vue 框架實現的前端靜態頁面 api：運行我們使用 Express 建立的 API 服務 db：就是一個運行 MongoDB 資料庫的容器 流程會變成\n資料進來由 nginx 分派，如果是前端或是靜態資源就直接從 nginx 回傳\n若是 API 類型的請求則轉交給 API 容器處理後再回傳資料。\n這種架構有以下優勢\n透過 nginx 過濾非法請求 解決前後端跨域問題，因為兩者間都透過相同端點訪問 可以輕鬆擴增伺服器大小，並且使用 Nginx 做負載平衡 前端容器化 首先容器化的是先前用 Vue 寫的前端專案，將專案打包成靜態頁面\nnpm run build 接著增加 nginx 設定檔 client/config/nginx.conf\nserver { listen 80; root /www; index index.html; sendfile on; sendfile_max_chunk 1M; tcp_nopush on; gzip_static on; location /api/v1 { proxy_pass http://api:3000; } location / { try_files $uri $uri/ /index.html; } } 其中要特別注意的是 location 規則\n請求目標如果是 /api/v1，那就把請求傳到 api 容器裡 請求目標 /，則直接回傳靜態頁面 index.html 然後要回頭稍微修改一下前端訪問後端的網址，打開 client/src/store/actions.js 修改 API_BASE 成\nconst API_BASE = \u0026#39;/api/v1\u0026#39;; 這樣改了之後前端在對 API 發起請求時就是取決於當前頁面的網址，而不是固定的 http://localhost:3000/api/v1\n接著就是要撰寫 Docker 相關設定\n首先建立 client/src/Dockerfile\nFROM nginx:1.13 # 刪除預設的 Nginc 設定 RUN rm /etc/nginx/conf.d/default.conf # 加入自己定義的 Nginx 設定檔 COPY config/nginx.conf /etc/nginx/conf.d/ # 將前端靜態檔案映射到容器的 /www 目錄下 COPY dist /www 接著建立 client/.dockerignore，裡面只有短短一行\nnode_modules 代表不 mount 進 docker 的資料夾\n後端容器化 前端容器化之後，接著準備進行後端的容器化。首先把寫死的 MongoDB 連線字串透過環境變數注入，修改 server/app.js 連線資料庫的部分成\nmongoose.connect(process.env.MONGO_URI || `mongodb://localhost:27017/test`); 接著一樣新建 server/Dockerfile\nFROM node:10 # 指定工作目錄為 /usr/src/app，接下来的指令全部在這個路徑下操作 WORKDIR /usr/src/app # 將 package.json 複製到根目錄 COPY package*.json ./ # 安裝 npm 依賴 RUN npm install # 複製全部程式內容 COPY . . # 設定環境變數 ENV NODE_ENV=production ENV MONGO_URI=mongodb://db:27017/test ENV HOST=0.0.0.0 ENV PORT=3000 # 曝露出 3000 port EXPOSE 3000 # 設定映像檔內執行的指令 CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] 和前端一樣建立 server/.dockerignore 確定不會把 node_modules 給映射進容器裡\n裡面也只有一行：\nnode_modules Docker Compose Docker Compose 可以讓我們很好的管理 docker 容器，只需要透過一個 YAML 檔就可以修改設定。\n在專案的根目錄下建立（跟 client 和 server 兩個資料夾同層）docker-compose.yml\nversion: \u0026#39;3\u0026#39; services: db: image: mongo restart: always api: build: server restart: always ports: - 3000:3000 nginx: build: client restart: always ports: - 8080:80 可以看到我們建立了三個 service，對應到前面說的 db、api、nginx\ndb：指定使用 mongo 映像檔，然後當服務意外停止則總是重啟 api：映像檔透過 server 資料夾內來建立，對外 port 為 3000:3000 nginx：映像檔透過 client 資料夾內來建立，對外 port 為 8080:80，外部的 8080 port 會指向到內部 80 port 如果 docker-compose.yml 中的 service 使用 image 指定映像檔，則會去Docker Hub 上拉回指定的映像檔\n若是使用 build 則會根據指定目錄下的 Dockerfile 來建立映像檔。\n接著就是測試的時間！打開 Docker 之後，在終端機輸入\ndocker-compose up --build 第一次執行會多花一些時間，因為先前提過的要從Docker Hub 上拉回指定的映像檔，如下圖\n可以藉由\ndocker ps 來觀察目前所有的容器狀態，看起來沒問題的話就可以開啟 localhost:8080 來看看專案是不是跟原本一樣\nMongoDB 身份驗證 在之前的設定中我們的 MongoDB 資料庫並沒定任何身份驗證\n所以任何人只要能夠發送請求到資料庫都可以對資料庫做修改，這是一個可怕的資安問題！\n接著我們要來搞定 MongoDB 的身份驗證，增加系統的安全性\n修改 MongoDB 連線設定 打開 server/app.js，修改連線資料庫的部分成以下\nongoose.connect(process.env.MONGO_URI || `mongodb://localhost:27017/test`, { useNewUrlParser: true, useUnifiedTopology: true, user: process.env.MONGO_USER, pass: process.env.MONGO_PASSWORD, }); 這代表\nuseNewUrlParser：使用新的 MongoDB 驅動 URL 解析器 useUnifiedTopology：使用新的連線管理引擎，支持重新連線，這樣可以大大提升連線穩定性 user：連線的使用者名稱，通過環境變數注入 pass：連線使用的密碼，通過環境變數注入 Dockerfile 中注入環境變數 在 server/Dockerfile 中加入下面的環境變數：\nENV NODE_ENV=production ENV MONGO_URI=mongodb://db:27017/admin ENV MONGO_USER=mongoadmin ENV MONGO_PASSWORD=secret ENV HOST=0.0.0.0 ENV PORT=3000 可以發現一些不同的地方，調整了 MONGO_URI，把預設的 test 換成 admin\n這是為了啟用驗證功能並且使用 admin 作為 Authentication Database 的使用者\n設定 Docker Compose 預設密碼 接著在 docker-compose.yml 裡面幫 db 服務加入預設密碼的環境變數\ndb: image: mongo restart: always environment: MONGO_INITDB_ROOT_USERNAME: mongoadmin MONGO_INITDB_ROOT_PASSWORD: secret 測試 首先使用\ndocker-compose down --volumes 不只關閉了原本運行中的 docker 容器，還透過 --volumes 把原本的建立 MongoDB 的容器徹底刪除\n若不這麼做，之後重啟容器會跳過初始化使用者的過程，這樣我們的驗證資料庫就沒辦法被建立，而會載入之前的資料\n接著重新啟動容器\ndocker-compose up --build 應該會看到網頁一切正常，不過資料庫已經有了驗證，不是「裸奔」的狀態了\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202012-express-vue-build-ecommerce-22-docker-containerized/"
  },{
    "title": "[Express+Vue 搭建電商網站] 21 使用 Element UI 加入載入過動畫",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 套用 Element UI 加入載入動畫",
    "body": "等待的時候很無聊，所以我們加點動畫\n基本的動畫是用來告訴使用者動作執行結果，做到這樣使用者才知道自己剛剛做的事情有沒有完成\nManufactureForm 組件 在這個組件中，會在使用者新建或是修改製造商資訊後，當後端完成處理前出現 Loading 的動態效果\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;manufacturerInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; label-width=\u0026#34;180px\u0026#34; v-loading=\u0026#34;loading\u0026#34; element-loading-text=\u0026#34;Loading...\u0026#34; element-loading-spinner=\u0026#34;el-icon-loading\u0026#34; element-loading-background=\u0026#34;rgba(0, 0, 0, 0.8)\u0026#34; \u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;manufacturerData.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; native-type=\u0026#34;submit\u0026#34; @click=\u0026#34;onSubmit\u0026#34; \u0026gt;Update Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;model\u0026#34;, \u0026#34;isEditing\u0026#34;], data() { return { manufacturerData: { name: \u0026#34;\u0026#34; } }; }, created() { this.manufacturerData = this.model; }, watch: { model(val) { this.manufacturerData = val; } }, computed: { loading() { return this.$store.state.showLoader; } }, methods: { onSubmit() { this.$emit(\u0026#34;save-manufacturer\u0026#34;, this.manufacturerData); } } }; \u0026lt;/script\u0026gt; 使用 element-ui 组件庫提供的指令 v-loading 來判斷 loading 是否為真來決定是否要顯示載入動畫\n而 loading 這個 computed 屬性使用 store.state.showLoader 的資料\n同時也把當初在 ProductForm 中解決過「無法修改標單內容」的問題用同樣方法解決了\nProductForm 組件 當然啦，製造商表單的效果在 ProductForm 中應該也要有\n接著就打開 ProductForm 組件進行編輯\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;productInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; label-width=\u0026#34;180px\u0026#34; v-loading=\u0026#34;loading\u0026#34; element-loading-text=\u0026#34;Loading...\u0026#34; element-loading-spinner=\u0026#34;el-icon-loading\u0026#34; element-loading-background=\u0026#34;rgba(0, 0, 0, 0.8)\u0026#34; \u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Price\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.price\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Manufacturer \u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;modelData.manufacturer.name\u0026#34; clearable placeholder=\u0026#34;請選擇製造商\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34; :label=\u0026#34;manufacturer.name\u0026#34; :value=\u0026#34;manufacturer.name\u0026#34; \u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Image \u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.image\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Description \u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;modelData.description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; native-type=\u0026#34;submit\u0026#34; @click=\u0026#34;onSubmit\u0026#34; \u0026gt;Update Product\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Product\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { modelData: { manufacturer: { name: \u0026#34;\u0026#34; } } }; }, props: [\u0026#34;model\u0026#34;, \u0026#34;manufacturers\u0026#34;, \u0026#34;isEditing\u0026#34;], created() { const product = this.model; this.modelData = { ...product, manufacturer: { ...product.manufacturer } }; }, watch: { model(val) { this.modelData = val; } }, computed: { loading() { return this.$store.state.showLoader; } }, methods: { onSubmit() { // 表單中只有 modelData.manufacturer.name，但後端需要整個製造商物件，所以要找出對應的製造商物件寫入到 modelData 中 const manufacturer = this.manufacturers.find( item =\u0026gt; item.name === this.modelData.manufacturer.name ); this.modelData.manufacturer = manufacturer; this.$emit(\u0026#34;save-product\u0026#34;, this.modelData); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .productInfo { padding-top: 10px; } .form { margin: 0 auto; width: 500px; } .el-input__inner { height: 60px; } \u0026lt;/style\u0026gt; 在這個組件中我們也加入了 loading() 這個 computed 屬性\n實現提示功能 在組件中加入功能後，我們要實際把提示功能完成\n首先打開 src/store/actions.js 加入提示訊息的功能\nimport axios from \u0026#39;axios\u0026#39;; import { Message } from \u0026#39;element-ui\u0026#39;; import { ADD_PRODUCT, ADD_PRODUCT_SUCCESS, PRODUCT_BY_ID, PRODUCT_BY_ID_SUCCESS, UPDATE_PRODUCT, UPDATE_PRODUCT_SUCCESS, REMOVE_PRODUCT, REMOVE_PRODUCT_SUCCESS, ALL_PRODUCTS, ALL_PRODUCTS_SUCCESS, ALL_MANUFACTURERS, ALL_MANUFACTURERS_SUCCESS, MANUFACTURER_BY_ID, MANUFACTURER_BY_ID_SUCCESS, ADD_MANUFACTURER, ADD_MANUFACTURER_SUCCESS, UPDATE_MANUFACTURER, UPDATE_MANUFACTURER_SUCCESS, REMOVE_MANUFACTURER, REMOVE_MANUFACTURER_SUCCESS, } from \u0026#39;./mutation-types\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; export const productActions = { allProducts({ commit }) { commit(ALL_PRODUCTS) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { commit(ALL_PRODUCTS_SUCCESS, { products: response.data, }); }) }, productById({ commit }, payload) { commit(PRODUCT_BY_ID); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(PRODUCT_BY_ID_SUCCESS, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(REMOVE_PRODUCT); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`) .then(() =\u0026gt; { // 回傳 productId，用來刪除對應商品 commit(REMOVE_PRODUCT_SUCCESS, { productId, }); Message({ message: \u0026#39;產品刪除完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;產品刪除失敗\u0026#39;); }) }, updateProduct({ commit }, payload) { commit(UPDATE_PRODUCT); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product) .then(response =\u0026gt; { commit(UPDATE_PRODUCT_SUCCESS, { product: response.data, }); Message({ message: \u0026#39;商品更新成功\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;商品更新失敗\u0026#39;); }) }, addProduct({ commit }, payload) { commit(ADD_PRODUCT); const { product } = payload; axios.post(`${API_BASE}/products`, product) .then(response =\u0026gt; { commit(ADD_PRODUCT_SUCCESS, { product: response.data, }) Message({ message: \u0026#39;已新建商品\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;商品建立失敗\u0026#39;); }) } }; export const manufacturerActions = { allManufacturers({ commit }) { commit(ALL_MANUFACTURERS); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(ALL_MANUFACTURERS_SUCCESS, { manufacturers: response.data, }); }) }, manufacturerById({ commit }, payload) { commit(MANUFACTURER_BY_ID); const { manufacturerId } = payload; axios.get(`${API_BASE}/manufacturers/${manufacturerId}`).then(response =\u0026gt; { commit(MANUFACTURER_BY_ID_SUCCESS, { manufacturer: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(REMOVE_MANUFACTURER); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`) .then(() =\u0026gt; { // 回傳 manufacturerId，用來刪除對應的製造商 commit(REMOVE_MANUFACTURER_SUCCESS, { manufacturerId, }); Message({ message: \u0026#39;製造商刪除完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商刪除完成失敗\u0026#39;); }) }, updateManufacturer({ commit }, payload) { commit(UPDATE_MANUFACTURER); const { manufacturer } = payload; axios.put(`${API_BASE}/manufacturers/${manufacturer._id}`, manufacturer) .then(response =\u0026gt; { commit(UPDATE_MANUFACTURER_SUCCESS, { manufacturer: response.data, }); Message({ message: \u0026#39;製造商更新完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商更新失敗\u0026#39;); }) }, addManufacturer({ commit }, payload) { commit(ADD_MANUFACTURER); const { manufacturer } = payload; axios.post(`${API_BASE}/manufacturers`, manufacturer) .then(response =\u0026gt; { commit(ADD_MANUFACTURER_SUCCESS, { manufacturer: response.data, }); Message({ message: \u0026#39;製造商建立完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商建立失敗\u0026#39;); }) } } 首先導入了 element-ui 组件庫提供的 Message 提示訊息組件\n接著在各個操作中加入提示訊息的物件，成功或失敗都會回傳對應的訊息\n接著開啟 src/store/mutations.js 做部分內容修改，為的是修改購物車的提示訊息\nexport const cartMutations = { [ADD_TO_CART](state, payload) { const { product } = payload; state.cart.push(product); Message({ message: \u0026#39;成功加入購物車\u0026#39;, type: \u0026#39;success\u0026#39; }) }, [REMOVE_FROM_CART](state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) Message({ message: \u0026#39;已從購物車移除商品\u0026#39;, type: \u0026#39;success\u0026#39; }) }, } 同樣導入了 element-ui 组件庫提供的 Message 提示訊息組件\n當使用者加入或移除購物車商品時就會收到提示了！\n結果看起來像這樣，十分酷炫有型\n重構到這邊，測試起來似乎又有點什麼問題\n那就是在表單按下更新後，看到了更新成功的訊息，但畫面上的資料似乎沒有同步成最新的\n當資料出現問題，應該依據 Vue 的單向資料流原則來修正\n使用者更新資料後，應該從後端同步更新資料到狀態池中進行渲染\n因此我們要修改的就是 src/store/actions.js 的內容\n可以大膽的猜測，是因為後端請求結束後 action 提交到 mutations.js 中的不是修改後的最新資料\n所以才沒有改變狀態池中的物件\n修改 src/store/actions.js 檔案中更新數據的部分\n兩個方法在不同的常數中，但為了節省版面就只展示其中關鍵的方法\nupdateProduct({ commit }, payload) { commit(UPDATE_PRODUCT); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product) .then(() =\u0026gt; { commit(UPDATE_PRODUCT_SUCCESS, { product: product, }); Message({ message: \u0026#39;商品更新成功\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;商品更新失敗\u0026#39;); }) }, updateManufacturer({ commit }, payload) { commit(UPDATE_MANUFACTURER); const { manufacturer } = payload; axios.put(`${API_BASE}/manufacturers/${manufacturer._id}`, manufacturer) .then(() =\u0026gt; { commit(UPDATE_MANUFACTURER_SUCCESS, { manufacturer: manufacturer, }); Message({ message: \u0026#39;製造商更新完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商更新失敗\u0026#39;); }) }, 可以看到我們不理會 axios 返回的結果\n直接使用原本作為 payload 去執行 API 的資料回傳到 mutations 來修改狀態\n所以接著就要修改 mutations.js，將新的資料同步到狀態池中\n也是針對更新的部分做局部修改，將最新的資料同步到狀態池中\n[UPDATE_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { product: newProduct } = payload; state.products = state.products.map(product =\u0026gt; { if (product._id === newProduct._id) { return newProduct; } return product; }); state.product = newProduct; }, [UPDATE_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer: newManufacturer } = payload; state.manufacturers = state.manufacturers.map(manufacturer =\u0026gt; { if (manufacturer._id === newManufacturer._id) { return newManufacturer; } return manufacturer; }); state.manufacturer = newManufacturer; }, 於是我們就修好了表單的修改功能並直接顯示最新資料！\n這就是在實際開發中使用 element-ui 組件庫套用在前端樣板中的流程，並且一步一步的進行了重構\n到了這邊整個專案基本上已經可以正常運行了，使用者的體驗也得到的明顯的改善！\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202011-express-vue-build-ecommerce-21-elemen-ui-loading-animation/"
  },{
    "title": "[Express+Vue 搭建電商網站] 20 重構後的頁面功能恢復",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 重構後的頁面功能恢復",
    "body": "要是你跟老闆說：現在我們專案的畫面好看了，但是功能全壞了\n老闆應該會一臉問號問你在講什麼？\n廢話不多說，趕快來修好上一篇中被我們弄壞的功能！\n修復雙向綁定的問題 上一篇中有提過 element-ui 的輸入組件不接受 v-model 的功能\n所以為了雙向綁定資料，我們需要利用其他方法\nEdit 組件 首先打開 Edit 組件進行修復\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-form @save-product=\u0026#34;updateProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; :isEditing=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { created() { const { name = \u0026#34;\u0026#34; } = this.modelData || {}; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, model() { const product = this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); const res = { ...product, manufacturer: { ...product.manufacturer } }; return res; } }, methods: { updateProduct(product) { this.$store.dispatch(\u0026#34;updateProduct\u0026#34;, { product }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 這一步中我們又將 data 屬性中的 model 給恢復到了 computed 中，用來暫存 model 物件的資料提高效能\n而雙向綁定的問題會在其中的 ProductForm 解決\nProductForm 組件 我們來嘗試另一種方式修復雙向綁定，先看程式碼\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;productInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; label-width=\u0026#34;180px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Price\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.price\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Manufacturer \u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;modelData.manufacturer.name\u0026#34; clearable placeholder=\u0026#34;請選擇製造商\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34; :label=\u0026#34;manufacturer.name\u0026#34; :value=\u0026#34;manufacturer.name\u0026#34; \u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Image \u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.image\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Description \u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;modelData.description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Update Product\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Product\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { modelData: { manufacturer: { name: \u0026#34;\u0026#34; } } }; }, props: [\u0026#34;model\u0026#34;, \u0026#34;manufacturers\u0026#34;, \u0026#34;isEditing\u0026#34;], created() { const product = this.model; this.modelData = { ...product, manufacturer: { ...product.manufacturer } }; }, watch: { model(val) { this.modelData = val; } }, methods: { onSubmit() { const manufacturer = this.manufacturers.find( item =\u0026gt; item.name === this.modelData.manufacturer.name ); this.modelData.manufacturer = manufacturer; this.$emit(\u0026#34;save-product\u0026#34;, this.modelData); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .productInfo { padding-top: 10px; } .form { margin: 0 auto; width: 500px; } .el-input__inner { height: 60px; } \u0026lt;/style\u0026gt; 在上面的程式中，不直接使用父組件的 model 作為表單的資料物件\n而是在目前的組件中自訂一個新的 modelData 物件\n並且在組件剛被建立時就先從父組件取得 modle 物件，暫定為 product\n然後將 product 需要用到的屬性解構給 modelData 物件\n這樣就避免了表單物件操作 computed，但這只解決了一半問題，說好的雙向綁定呢？\n所以我們要透過監測組件的變化，利用 watch 方法監測使用者輸入\n並且將新的資料儲存到 modelData 物件中，這樣就完成雙向綁定啦！而且表單也可以隨意編輯\n商品資訊表單錯誤問題 當修改或是新建表單時，會看到錯誤的提示訊息：id 屬性未定義\n因為錯誤訊息說是在 ProductForm 中，就來看看發生什麼事情了吧\n應該都還記得，商品的物件的製造商包含了 id 和 name 屬性\n但是我們的下拉選單的 value 只有傳回 name\n而後端資料庫要求製造商物件必須也要有 id 屬性\n所以在送出時使用了 find 方法找到了對應 name 的製造商物件\n並且將 modelData 中的製造商物件覆蓋掉，這樣就符合後端資料庫的要求了！\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202011-express-vue-build-ecommerce-20-element-ui-fix-function/"
  },{
    "title": "[Express+Vue 搭建電商網站] 19 使用 Element UI 重構畫面",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 套用 Element UI 到頁面上",
    "body": "重構可能會造成一些功能癱瘓，本章先著重在畫面，讓畫面變美美噠\n後續的文章會把功能修復，莫急莫慌莫害怕\n管理後台畫面重構 由於我們之前在 App 組件中已經有了共用的工具列，所以打開 src/views/admin/Index.vue 修改成\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;admin-new\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;In Admin\u0026lt;/h1\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 後台商品列表頁面重構 接著打開後台的商品組件 src/views/admin/Products.vue，將 \u0026lt;template\u0026gt; 修改成\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;el-table class=\u0026#34;table\u0026#34; :data=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;名稱\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;price\u0026#34; label=\u0026#34;售價\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;manufacturer.name\u0026#34; label=\u0026#34;製造商\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;管理\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-button class=\u0026#34;modify\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;\u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/edit/\u0026#39; + scope.row._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt;\u0026lt;/el-button\u0026gt; \u0026lt;el-button class=\u0026#34;remove\u0026#34; @click=\u0026#34;removeProduct(scope.row._id), deleteRow(scope.$index, products)\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 看起來和前台的 ProductItem 組件中表格非常相似，差在對商品物件的操作\n一個是將商品加入或移出購物車，一個是刪除或修改商品\n後台編輯商品頁面重構 打開 ProductForm 組件，在 \u0026lt;template\u0026gt; 內使用組件庫提供的 el-form 表單組件代替原本簡陋的 form 表單\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;productInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; :model=\u0026#34;model\u0026#34; label-width=\u0026#34;180px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Price\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.price\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Manufacturer \u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;model.manufacturer.name\u0026#34; clearable placeholder=\u0026#34;请选择制造商\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34; :label=\u0026#34;manufacturer.name\u0026#34; :value=\u0026#34;manufacturer.name\u0026#34; \u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Image \u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.image\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Description \u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;model.description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Update Product\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Product\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 接著要解決 src/views/admin/Edit.vue 組件內傳入的 computed model 無法被編輯的問題\n理由是 input 作為受控的組件，會一直顯示 Vue 的綁定資料\n輸入框內容將無法進行編輯：Input 输入框 結果送出之後還是沒反應，這很正常先繼續把畫面調好，等等我們會來修復它\n打開 Edit 組件，將原本在 computed 中的 model 屬性放到 data 屬性中，並移除原本在 computed 中的屬性\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-form @save-product=\u0026#34;updateProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; :isEditing=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { data() { const product = this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); return { // 回傳 product 的備份，是為了在修改 product 的備份之後，在保存之前不修改本地 Vuex store 的 product 屬性 model: { ...product, manufacturer: { ...product.manufacturer } } }; }, created() { const { name } = this.model; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, }, methods: { updateProduct(product) { this.$store.dispatch(\u0026#34;updateProduct\u0026#34;, { product }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 接著，長得跟 Edit 組件很像的 New 組件也一起重構\n\u0026lt;template\u0026gt; \u0026lt;product-form @save-product=\u0026#34;addProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34;\u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { data() { return { model: { manufacturer: { name: \u0026#34;\u0026#34; } } }; }, created() { if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; } }, methods: { addProduct(model) { this.$store.dispatch(\u0026#34;addProduct\u0026#34;, { product: model }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 後台編輯製造商頁面重構 和 Products 組件類似，開啟 Manufacturers 使用 el-table 替換掉原本的表單的 \u0026lt;template\u0026gt; 部分\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;manufacturers\u0026#34;\u0026gt; \u0026lt;el-table class=\u0026#34;table\u0026#34; :data=\u0026#34;manufacturers\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;製造商\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;管理\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-button class=\u0026#34;modify\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/manufacturers/edit/\u0026#39; + scope.row._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt; \u0026lt;/el-button\u0026gt; \u0026lt;el-button class=\u0026#34;remove\u0026#34; @click=\u0026#34;removeManufacturer(scope.row._id), deleteRow(scope.$index, products)\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34; \u0026gt;刪除\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 接著重構 NewManufacturers 組件，一樣將 computed 的 model 換到 data 屬性中\n\u0026lt;template\u0026gt; \u0026lt;manufacturer-form @save-manufacturer=\u0026#34;addManufacturer\u0026#34; :model=\u0026#34;model\u0026#34;\u0026gt;\u0026lt;/manufacturer-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ManufacturerForm from \u0026#34;@/components/ManufacturerForm.vue\u0026#34;; export default { data() { return { model: {} }; }, methods: { addManufacturer(model) { this.$store.dispatch(\u0026#34;addManufacturer\u0026#34;, { manufacturer: model }); } }, components: { \u0026#34;manufacturer-form\u0026#34;: ManufacturerForm } }; \u0026lt;/script\u0026gt; 接著重構 ManufacturerForm\n程式結構和 ProductForm 組件很類似，將 \u0026lt;template\u0026gt; 區塊替換成組件庫樣式\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;manufacturerInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; :model=\u0026#34;model\u0026#34; label-width=\u0026#34;180px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Update Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 重構前台購物車 最後！重構 Cart 組件，和 ProductList 類似，兩者都用了 ProductItem 組件\n一樣那句話：將 \u0026lt;template\u0026gt; 區塊替換成組件庫樣式\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-item :products=\u0026#34;cart\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在這篇文章中主要就是使用 element-ui 組件庫將畫面做得比較酷炫\n但也造成一些功能癱瘓，當下一定很緊張，但不要緊！我們馬上就要來修復功能了！\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202011-express-vue-build-ecommerce-19-elemen-ui-refactor-page/"
  },{
    "title": "[Express+Vue 搭建電商網站] 18 套用 Element UI 到頁面上",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 套用 Element UI 到頁面上",
    "body": "先前我們已經把電商的基本功能完成了，只是畫面有點差強人意。\n在這一節中我們使用 Element UI 來讓畫面更加美觀\n安裝 Element UI Element UI 是一套 Vue 2.0 的組件庫\n提供了許多模板。在很多時候可以減少我們重造輪子的麻煩\n現在也有 Vue 3.x 的版本了\n有三方法可以進行\n使用 npm 套件管理安裝，這也是官方推薦的作法\nnpm i element-ui -S 使用 CDN 安裝\n在 index.html 中加入 CDN 連結\n\u0026lt;!-- 引入样式 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/element-ui/lib/theme-chalk/index.css\u0026#34;\u0026gt; \u0026lt;!-- 引入组件库 --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/element-ui/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 若是使用 CDN 版本作法，建議加入版本號避免因為 Element UI 升級而受到影響\n使用 vue-ui 鑑於 vue/cli 3.0 的釋出，也提供了從 vue-cli 中安裝的套件 官方說明 導入套件 打開主目錄中的 src/main.js 我們要把剛剛安裝的套件導入到專案中註冊依賴\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.config.productionTip = false Vue.use(ElementUI); new Vue({ router, store, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 除了導入 element-ui 組件庫外，還需要單獨把 CSS 樣式也導入\n並且聲明 Vue.use(ElementUI); 來註冊組件庫，接著就是快樂的開始使用組件庫了\n重構選單列 打開 src/App.vue 愉快的使用 element-ui 改成酷炫的樣子\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-menu class=\u0026#34;menu\u0026#34; :default-active=\u0026#34;activeIndex2\u0026#34; mode=\u0026#34;horizontal\u0026#34; @select=\u0026#34;handleSelect\u0026#34; background-color=\u0026#34;#545c64\u0026#34; text-color=\u0026#34;#fff\u0026#34; active-text-color=\u0026#34;#ffd04b\u0026#34;\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;首頁\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-submenu index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;控制台\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-1\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;產品列表\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-2\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin/new\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;新增商品\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-3\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin/manufacturers\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;製造商列表\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-4\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin/manufacturers/new\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;新增製造商\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;el-menu-item index=\u0026#34;3\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/cart\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;購物車\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39;, data() { return { activeIndex: \u0026#39;1\u0026#39;, activeIndex2: \u0026#39;1\u0026#39; }; }, methods: { handleSelect(key, keyPath) { console.log(key, keyPath); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u0026lt;/style\u0026gt; 先不要在意 data 屬性以及 handleSelect 方法，暫時不會碰到\n首先看到 \u0026lt;el-menu\u0026gt; 這個標籤，其中的 el-menu-item 帶有幾個屬性\n其中 tag 屬性代表將這個內容用 \u0026lt;div\u0026gt; 這個標籤渲染，如果沒設定則預設是 \u0026lt;a\u0026gt; 連結並帶有底線\n所以這邊設定為 div 就是為了避免出現底線\n重構商品列表 接著要重構 ProductItem 同時因為子組件被修改，所以 ProductList 也需要修改\nProductList 打開 src/components/products/ProductList.vue 將 \u0026lt;template\u0026gt; 部分修改為\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;This is ProductList\u0026lt;/div\u0026gt; \u0026lt;!-- \u0026lt;template v-for=\u0026#34;product in products\u0026#34;\u0026gt; --\u0026gt; \u0026lt;product-item :products=\u0026#34;products\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;!-- \u0026lt;/template\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以藉由註解了解到，原本是分別將產品傳入子組件再進行渲染。但現在變成了傳入全部商品\n至於為什麼？就讓我們看下去\nProductItem 打開 src/components/products/ProductItem.vue 修改成以下內容\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;el-table class=\u0026#34;table\u0026#34; :data=\u0026#34;products\u0026#34; max-height=\u0026#34;250\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;產品名稱\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;description\u0026#34; label=\u0026#34;介紹\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;price\u0026#34; label=\u0026#34;售價\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;manufacturer.name\u0026#34; label=\u0026#34;製造商\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;!-- \u0026lt;el-table-column label=\u0026#34;圖片\u0026#34;\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;image\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;product__image\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt;--\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;product-button :id=\u0026#34;scope.row._id\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductButton from \u0026#34;./ProductButton\u0026#34;; export default { name: \u0026#34;product-item\u0026#34;, props: [\u0026#34;products\u0026#34;], components: { \u0026#34;product-button\u0026#34;: ProductButton } }; \u0026lt;/script\u0026gt; 第一，針對傳入值改成 props: [\u0026quot;products\u0026quot;], 因為在父組件做了改變，但是為什麼呢？\n再往回看 \u0026lt;template\u0026gt; 中，原來是因為 \u0026lt;el-table\u0026gt; 這個表格組件要傳入一個陣列作為 data 屬性\n而最後一個 el-table-column 作為按鈕，所以沒有定義 prop 屬性\n為了作為按鈕操作，使用了 scope.row 取得指定物件的 id 作為值傳給了子組件 ProductButton 來操作\n透過 slot-scope 可以取得 row, column, $index 和 store（table 内部的狀態管理）資料\nProductButton 接著就是修改 src/components/products/ProductButton.vue 組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button v-if=\u0026#34;isAdding\u0026#34; @click=\u0026#34;addToCart\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;加入購物車\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;removeFromCart(id)\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;從購物車移除\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;id\u0026#34;], computed: { product() { let product = this.$store.getters.allProducts.find( product =\u0026gt; product._id === this.id ); return product; }, isAdding() { let isAdding = true; this.cart.map(product =\u0026gt; { if (product._id === this.product._id) { isAdding = false; } }); return isAdding; }, cart() { return this.$store.state.cart; } }, methods: { addToCart() { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product: this.product }); }, removeFromCart(productId) { this.$store.commit(\u0026#34;REMOVE_FROM_CART\u0026#34;, { productId }); } } }; \u0026lt;/script\u0026gt; 使用 element-ui 組件庫提供的按鈕組件 el-button 替換先前普通的按鈕，並且改變了對應的按鈕方法 將父組件傳來的 product 物件換成了單純的 id\n因為在 ProductItem 組件中傳入的是指定物件的 id\n所以定義了一個 computed product，來取得指定 id 的產品物件\n到這邊我們先看看運行的結果\n上方的功能列已經變成比較好看的樣式了產品列表也用表單的形式，看起來整齊多了\n基本的 Element UI 套用就到這邊，接著我們會把畫面一步步變得更好看！\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202011-express-vue-build-ecommerce-18-element-ui-product-list/"
  },{
    "title": "[Express+Vue 搭建電商網站] 17 使用常數管理變數",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用常數管理變數",
    "body": "很多時候我們會把功能封裝到組件內，以便重複使用組件，而在組件內我們會定義很多方法名稱去呼叫不同的事件\n這中間只要有一個字打錯，整個流程就會錯誤，並且非常難除錯，因此我們會使用常數維持一致\n打錯字的時候就會報錯，方便除錯\n建立 ManufacturerForm 組件 和商品資訊一樣，我們也要將製造商資訊封裝到另一個單獨的組件 ManufacturerForm\n新增 src/components/ManufacturerForm.vue 檔案\n\u0026lt;template\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;saveManufacturer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Name\u0026#34; v-model=\u0026#34;model.name\u0026#34; name=\u0026#34;name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group new-button\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-pencil\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;!-- Conditional rendering for input text --\u0026gt; \u0026lt;span v-if=\u0026#34;isEditing\u0026#34;\u0026gt;Update Manufacturer\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;Add Manufacturer\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;model\u0026#34;, \u0026#34;isEditing\u0026#34;], methods: { saveManufacturer() { this.$emit(\u0026#34;save-manufacturer\u0026#34;, this.model); } } }; \u0026lt;/script\u0026gt; 重構 getters 檔案 在建立編輯生產商的組件前，需先加入對應的 getter 屬性\n打開 src/store/getters.js 檔案，對 manufacturerGetters 增加一個屬性\n用來取得狀態庫中的指定生產商\nmanufacturerById: (state, getters) =\u0026gt; id =\u0026gt; { if (getters.allManufacturers.length \u0026gt; 0) { return getters.allManufacturers.filter(manufacturer =\u0026gt; manufacturer._id === id)[0] } else { return state.manufacturer; } } 建立 EditManufacturers 頁面 在建立好顯示製造商資訊的表單組件 ManufacturerForm 以及設定好取得資料的 getter 之後\n我們要來建立編輯製造商的頁面 src/views/admin/EditManufacturers.vue\n\u0026lt;template\u0026gt; \u0026lt;manufacturer-form @save-manufacturer=\u0026#34;addManufacturer\u0026#34; :model=\u0026#34;model\u0026#34; :isEditing=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/manufacturer-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ManufacturerForm from \u0026#34;@/components/ManufacturerForm.vue\u0026#34;; export default { created() { this.$store.dispatch(\u0026#34;manufacturerById\u0026#34;, { manufacturerId: this.$route.params[\u0026#34;id\u0026#34;] }); }, computed: { model() { const manufacturer = this.$store.getters.manufacturerById( this.$route.params[\u0026#34;id\u0026#34;] ); return { ...manufacturer }; } }, methods: { addManufacturer(model) { this.$store.dispatch(\u0026#34;updateManufacturer\u0026#34;, { manufacturer: model }); } }, components: { \u0026#34;manufacturer-form\u0026#34;: ManufacturerForm } }; \u0026lt;/script\u0026gt; 組件在創建時會使用 action 去異步取得製造商資訊，並透過 mutation 修改狀態池 之所以在 model 這個 computed 中回傳製造商資料的備份資料\n是為了在修改資料被送出前不對當前 store 的生產商屬性做操作\n而組件內如果對生產商有操作，會透過 action 修改商品資訊，然後呼叫 mutation 變更狀態池\n建立 NewManufacturers 頁面 跟剛剛的編輯頁面邏輯差不多，這邊要建立新增頁面 src/views/admin/NewManufacturers.vue\n\u0026lt;template\u0026gt; \u0026lt;manufacturer-form @save-manufacturer=\u0026#34;addManufacturer\u0026#34; :model=\u0026#34;model\u0026#34;\u0026gt;\u0026lt;/manufacturer-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ManufacturerForm from \u0026#34;@/components/ManufacturerForm.vue\u0026#34;; export default { computed: { model() { return {}; } }, methods: { addManufacturer(model) { this.$store.dispatch(\u0026#34;addManufacturer\u0026#34;, { manufacturer: model }); } }, components: { \u0026#34;manufacturer-form\u0026#34;: ManufacturerForm } }; \u0026lt;/script\u0026gt; 重構 Admin menu 在 src/views/admin/Index.vue 加入新的頁面用來增加製造商，沒什麼多解釋的\n\u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/manufacturers/new\u0026#34;\u0026gt;新增製造商\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; 增加路由邏輯 頁面跟連結都做好了，打開 src/router/index.js 引入路由設定\nimport NewManufacturers from \u0026#39;@/views/admin/NewManufacturers\u0026#39;; import EditManufacturers from \u0026#39;@/views/admin/EditManufacturers\u0026#39;; 增加 admin 頁面下路由 children 屬性\n{ path: \u0026#39;manufacturers/new\u0026#39;, name: \u0026#39;NewManufacturers\u0026#39;, component: NewManufacturers, }, { path: \u0026#39;manufacturers/edit/:id\u0026#39;, name: \u0026#39;EditManufacturers\u0026#39;, component: EditManufacturers, }, 用常數管理通用名稱 很多時候我們會把功能封裝到組件內，以便重複使用組件\n而在組件內我們會定義很多方法名稱去呼叫不同的事件，例如當使用者按下了送出，觸發了 ADD_PRODUCT 事件\n那在 action 中就要有相應的事件\n並且 action 在後端處理完請求後，也會呼叫指定的 mutations 來處理狀態的變更\n這中間只要有一個字打錯，整個流程就會錯誤，並且非常難除錯\n因此我們會使用常數的方式定義 actions 和 mutations 中的事件\n只要我們都使用同一組常數就可以維持一致。關鍵的是如果這麼做打錯字的時候就會報錯，方便除錯\n接著就來實作建立 src/store/mutation-types.js 檔案作為 mapping 表\nexport const ALL_PRODUCTS = \u0026#39;ALL_PRODUCTS\u0026#39;; export const ALL_PRODUCTS_SUCCESS = \u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;; export const PRODUCT_BY_ID = \u0026#39;PRODUCT_BY_ID\u0026#39;; export const PRODUCT_BY_ID_SUCCESS = \u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;; export const ADD_PRODUCT = \u0026#39;ADD_PRODUCT\u0026#39;; export const ADD_PRODUCT_SUCCESS = \u0026#39;ADD_PRODUCT_SUCCESS\u0026#39;; export const UPDATE_PRODUCT = \u0026#39;UPDATE_PRODUCT\u0026#39;; export const UPDATE_PRODUCT_SUCCESS = \u0026#39;UPDATE_PRODUCT_SUCCESS\u0026#39;; export const REMOVE_PRODUCT = \u0026#39;REMOVE_PRODUCT\u0026#39;; export const REMOVE_PRODUCT_SUCCESS = \u0026#39;REMOVE_PRODUCT_SUCCESS\u0026#39;; export const ADD_TO_CART = \u0026#39;ADD_TO_CART\u0026#39;; export const REMOVE_FROM_CART = \u0026#39;REMOVE_FROM_CART\u0026#39;; export const ALL_MANUFACTURERS = \u0026#39;ALL_MANUFACTURER\u0026#39;; export const ALL_MANUFACTURERS_SUCCESS = \u0026#39;ALL_MANUFACTURER_S\u0026#39;; export const MANUFACTURER_BY_ID = \u0026#39;MANUFACTURER_BY_ID\u0026#39;; export const MANUFACTURER_BY_ID_SUCCESS = \u0026#39;MANUFACTURER_BY_ID_SUCCESS\u0026#39;; export const ADD_MANUFACTURER = \u0026#39;ADD_MANUFACTURER\u0026#39;; export const ADD_MANUFACTURER_SUCCESS = \u0026#39;ADD_MANUFACTURER_SUCCESS\u0026#39;; export const UPDATE_MANUFACTURER = \u0026#39;UPDATE_MANUFACTURER\u0026#39;; export const UPDATE_MANUFACTURER_SUCCESS = \u0026#39;UPDATE_MANUFACTURER_SUCCESS\u0026#39;; export const REMOVE_MANUFACTURER = \u0026#39;REMOVE_MANUFACTURER\u0026#39;; export const REMOVE_MANUFACTURER_SUCCESS = \u0026#39;REMOVE_MANUFACTURER_SUCCESS\u0026#39;; 重構 actions 檔案 打開 src/store/actions.js 檔案，引入剛剛的常數表文件後，把其中的方法名稱通通改成使用常數表內的常數\nimport axios from \u0026#39;axios\u0026#39;; import { ADD_PRODUCT, ADD_PRODUCT_SUCCESS, PRODUCT_BY_ID, PRODUCT_BY_ID_SUCCESS, UPDATE_PRODUCT, UPDATE_PRODUCT_SUCCESS, REMOVE_PRODUCT, REMOVE_PRODUCT_SUCCESS, ALL_PRODUCTS, ALL_PRODUCTS_SUCCESS, ALL_MANUFACTURERS, ALL_MANUFACTURERS_SUCCESS, MANUFACTURER_BY_ID, MANUFACTURER_BY_ID_SUCCESS, ADD_MANUFACTURER, ADD_MANUFACTURER_SUCCESS, UPDATE_MANUFACTURER, UPDATE_MANUFACTURER_SUCCESS, REMOVE_MANUFACTURER, REMOVE_MANUFACTURER_SUCCESS, } from \u0026#39;./mutation-types\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; export const productActions = { allProducts({ commit }) { commit(ALL_PRODUCTS) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { commit(ALL_PRODUCTS_SUCCESS, { products: response.data, }); }) }, productById({ commit }, payload) { commit(PRODUCT_BY_ID); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(PRODUCT_BY_ID_SUCCESS, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(REMOVE_PRODUCT); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`).then(() =\u0026gt; { // 回傳 productId，用來刪除對應商品 commit(REMOVE_PRODUCT_SUCCESS, { productId, }); }) }, updateProduct({ commit }, payload) { commit(UPDATE_PRODUCT); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product).then(() =\u0026gt; { commit(UPDATE_PRODUCT_SUCCESS, { product, }); }) }, addProduct({ commit }, payload) { commit(ADD_PRODUCT); const { product } = payload; axios.post(`${API_BASE}/products`, product).then(response =\u0026gt; { commit(ADD_PRODUCT_SUCCESS, { product: response.data, }) }) } }; export const manufacturerActions = { allManufacturers({ commit }) { commit(ALL_MANUFACTURERS); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(ALL_MANUFACTURERS_SUCCESS, { manufacturers: response.data, }); }) }, manufacturerById({ commit }, payload) { commit(MANUFACTURER_BY_ID); const { manufacturerId } = payload; axios.get(`${API_BASE}/manufacturers/${manufacturerId}`).then(response =\u0026gt; { commit(MANUFACTURER_BY_ID_SUCCESS, { manufacturer: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(REMOVE_MANUFACTURER); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() =\u0026gt; { // 回傳 manufacturerId，用來刪除對應的製造商 commit(REMOVE_MANUFACTURER_SUCCESS, { manufacturerId, }); }) }, updateManufacturer({ commit }, payload) { commit(UPDATE_MANUFACTURER); const { manufacturer } = payload; axios.put(`${API_BASE}/manufacturers/${manufacturer._id}`, manufacturer).then(() =\u0026gt; { commit(UPDATE_MANUFACTURER_SUCCESS, { manufacturer, }); }) }, addManufacturer({ commit }, payload) { commit(ADD_MANUFACTURER); const { manufacturer } = payload; axios.post(`${API_BASE}/manufacturers`, manufacturer).then(response =\u0026gt; { commit(ADD_MANUFACTURER_SUCCESS, { manufacturer: response.data, }) }) } } 重構 manufacturer 檔案 在 src/store/mutations.js 也做跟上一步一樣的事情\nimport { ADD_PRODUCT, ADD_PRODUCT_SUCCESS, PRODUCT_BY_ID, PRODUCT_BY_ID_SUCCESS, UPDATE_PRODUCT, UPDATE_PRODUCT_SUCCESS, REMOVE_PRODUCT, REMOVE_PRODUCT_SUCCESS, ADD_TO_CART, REMOVE_FROM_CART, ALL_PRODUCTS, ALL_PRODUCTS_SUCCESS, ALL_MANUFACTURERS, ALL_MANUFACTURERS_SUCCESS, MANUFACTURER_BY_ID, MANUFACTURER_BY_ID_SUCCESS, ADD_MANUFACTURER, ADD_MANUFACTURER_SUCCESS, UPDATE_MANUFACTURER, UPDATE_MANUFACTURER_SUCCESS, REMOVE_MANUFACTURER, REMOVE_MANUFACTURER_SUCCESS, } from \u0026#39;./mutation-types\u0026#39;; export const productMutations = { [ALL_PRODUCTS](state) { state.showLoader = true; }, [ALL_PRODUCTS_SUCCESS](state, payload) { const { products } = payload; state.showLoader = false; state.products = products; }, [PRODUCT_BY_ID](state) { state.showLoader = true; }, [PRODUCT_BY_ID_SUCCESS](state, payload) { state.showLoader = false; const { product } = payload; state.product = product; }, [REMOVE_PRODUCT](state) { state.showLoader = true; }, [REMOVE_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { productId } = payload; state.products = state.products.filter(product =\u0026gt; product._id !== productId); }, [UPDATE_PRODUCT](state) { state.showLoader = true; }, [UPDATE_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { product: newProduct } = payload; state.product = newProduct; state.products = state.products.map(product =\u0026gt; { if (product._id === newProduct._id) { return newProduct; } return product; }) }, [ADD_PRODUCT](state) { state.showLoader = true; }, [ADD_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { product } = payload; state.products = state.products.concat(product); }, }; export const cartMutations = { [ADD_TO_CART](state, payload) { const { product } = payload; state.cart.push(product) }, [REMOVE_FROM_CART](state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, } export const manufacturerMutations = { [ALL_MANUFACTURERS](state) { state.showLoader = true; }, [ALL_MANUFACTURERS_SUCCESS](state, payload) { const { manufacturers } = payload; state.showLoader = false; state.manufacturers = manufacturers; }, [MANUFACTURER_BY_ID](state) { state.showLoader = true; }, [MANUFACTURER_BY_ID_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer } = payload; state.manufacturer = manufacturer; }, [REMOVE_MANUFACTURER](state) { state.showLoader = true; }, [REMOVE_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturerId } = payload; state.manufacturers = state.manufacturers.filter(manufacturer =\u0026gt; manufacturer._id !== manufacturerId); }, [UPDATE_MANUFACTURER](state) { state.showLoader = true; }, [UPDATE_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer: newManufacturer } = payload; state.manufacturers = state.manufacturers.map(manufacturer =\u0026gt; { if (manufacturer._id === newManufacturer._id) { return newManufacturer; } return manufacturer; }) }, [ADD_MANUFACTURER](state) { state.showLoader = true; }, [ADD_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer } = payload; state.manufacturers = state.manufacturers.concat(manufacturer); } } 如此就完成了用常數替換 actions 和 mutations 兩隻檔案中的事件類型\n後續要維護就不會東一塊西一塊的過於分散，還要用全域搜尋人工替換，增加了維護的可行性\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202010-express-vue-build-ecommerce-17-use-const-instead-of-variable/"
  },{
    "title": "[Express+Vue 搭建電商網站] 16 抽離 Vuex store 中的邏輯",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 抽離 Vuex store 中的邏輯",
    "body": "隨著我們的迷你電商網站越來越完整，在 Vuex store 中的程式也越來越龐大\n不只有 getters、mutation 還有 actions\n在章節中先試著將這些複雜的邏輯拆分成個別的檔案，抽出 Getters、Mutations 和 Actions 邏輯\n重構 Admin 首頁 打開 src/views/admin/Index.vue 頁面，將選單換成中文。並且加上查看查看製造商的選項\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;admin-new\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-3 col-md-3 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;admin-menu\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;查看商品\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/new\u0026#34;\u0026gt;新建商品\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/manufacturers\u0026#34;\u0026gt;查看製造商\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以預期到的接下來我們會做一個關於製造商的頁面，然後透過後端 API 取得製造商資料\n建立 Manufacturers 頁面 新建 src/views/admin/Manufacturers.vue 檔案\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;製造商\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{manufacturer.name}}\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;modify\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/manufacturers/edit/\u0026#39; + manufacturer._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;remove\u0026#34;\u0026gt; \u0026lt;a @click=\u0026#34;removeManufacturer(manufacturer._id)\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt;刪除\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; table { margin: 0 auto; } .modify { color: blue; } .remove a { color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { created() { if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; } }, methods: { removeManufacturer(manufacturerId) { const res = confirm(\u0026#34;是否刪除此製造商？\u0026#34;); if (res) { this.$store.dispatch(\u0026#34;removeManufacturer\u0026#34;, { manufacturerId }); } } } }; \u0026lt;/script\u0026gt; 可以看到這邊我們用了一些先前沒用過的方法\n例如 computed 中的 manufacturers、生命週期 created() 時候會使用到的 allManufacturers\n還有製造商刪除用的 method 中 removeManufacturer，這些會在之後實作出來\n重構 Products 組件 接著要動手重構的就是 src/views/admin/Products.vue 組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;名稱\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;價錢\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;製造商\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;product in products\u0026#34; :key=\u0026#34;product._id\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{product.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{product.price}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{product.manufacturer.name}}\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;modify\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/edit/\u0026#39; + product._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;remove\u0026#34;\u0026gt; \u0026lt;a @click=\u0026#34;removeProduct(product._id)\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt;刪除\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; table { margin: 0 auto; } .modify { color: blue; } .remove a { color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { created() { if (this.products.length === 0) { this.$store.dispatch(\u0026#34;allProducts\u0026#34;); } }, computed: { products() { return this.$store.getters.allProducts; } }, methods: { removeProduct(productId) { const res = confirm(\u0026#34;是否刪除此商品？\u0026#34;); if (res) { this.$store.dispatch(\u0026#34;removeProduct\u0026#34;, { productId }); } } } }; \u0026lt;/script\u0026gt; 基本上和使用者畫面中的商品頁差不多，就是將加入購物車換成了修改與刪除商品\n也和剛剛操作過的 Manufacturers 組件相似，相關的東西講了許多次了，就交給你來思考\n加入路由設定 頁面跟組件都完成了，接著就要讓頁面可以被訪問\n打開 vue-router 的設定 src/router/index.js，加入製造商相關的路由參數\n引入頁面檔案\nimport Manufacturers from \u0026#39;@/views/admin/Manufacturers\u0026#39; 在 admin 路由的 children 屬性中加入頁面\n{ path: \u0026#39;manufacturers\u0026#39;, name: \u0026#39;Manufacturers\u0026#39;, component: Manufacturers, }, 接著開啟專案，可以看到製造商連結已經生效，可以把我們帶到製造商頁面，但是資料還是沒有取得\n記得嗎？之前說要從後端 API 取得資料的方法還沒寫，接下來就一邊重構一邊把這個功能完成吧！\n分離 Getter 邏輯 首先建立 src/store/getters.js 檔案，用來存放各種不同的 getter\nexport const productGetters = { allProducts(state) { return state.products }, productById: (state, getters) =\u0026gt; id =\u0026gt; { if (getters.allProducts.length \u0026gt; 0) { return getters.allProducts.filter(product =\u0026gt; product._id === id)[0] } else { return state.product; } } } export const manufacturerGetters = { allManufacturers(state) { return state.manufacturers; } } 可以看到我們導出了 productGetters 和 manufacturerGetters 兩個方法\n前者包含商品的 getters，後者則是負責製造商的 getter，如此就補上了前面幾段缺少的 manufacturer getters\n分離 Mutations 邏輯 就像剛剛分離 Getter 邏輯，接著新建 src/store/mutations.js 檔案作為 store 中 mutation 的程式管理\nexport const productMutations = { ALL_PRODUCTS(state) { state.showLoader = true; }, ALL_PRODUCTS_SUCCESS(state, payload) { const { products } = payload; state.showLoader = false; state.products = products; }, PRODUCT_BY_ID(state) { state.showLoader = true; }, PRODUCT_BY_ID_SUCCESS(state, payload) { state.showLoader = false; const { product } = payload; state.product = product; }, REMOVE_PRODUCT(state) { state.showLoader = true; }, REMOVE_PRODUCT_SUCCESS(state, payload) { state.showLoader = false; const { productId } = payload; state.products = state.products.filter(product =\u0026gt; product._id !== productId); } }; export const cartMutations = { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, } export const manufacturerMutations = { ALL_MANUFACTURERS(state) { state.showLoader = true; }, ALL_MANUFACTURERS_SUCCESS(state, payload) { const { manufacturers } = payload; state.showLoader = false; state.manufacturers = manufacturers; }, REMOVE_MANUFACTURER(state) { state.showLoader = true; }, REMOVE_MANUFACTURER_SUCCESS(state, payload) { state.showLoader = false; const { manufacturerId } = payload; state.manufacturers = state.manufacturers.filter(manufacturer =\u0026gt; manufacturer._id !== manufacturerId); } } 分別導出了\nproductMutations cartMutations manufacturerMutations 來操作 vuex store 中的不同狀態，這邊也加入了生產商相關的狀態管理 mutations，讓之後的 actions 可以呼叫\n重構 Store 物件 既然剛剛都把 Getter 和 Mutations 抽離文件完成了，這邊就要重構 Store 檔案。\n要做的事情有兩件：\n移除原有的 getters 和 mutations 引入新建的 getters 和 mutations 下面就是新的 src/store/index.js\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import axios from \u0026#39;axios\u0026#39;; import { productGetters, manufacturerGetters } from \u0026#39;./getters\u0026#39;; import { productMutations, cartMutations, manufacturerMutations } from \u0026#39;./mutations\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items cart: [], // ajax loader showLoader: false, // selected product product: {}, // all products products: [], // all manufacturers manufacturers: [], }, mutations: { ...productMutations, ...cartMutations, ...manufacturerMutations, }, getters: { ...productGetters, ...manufacturerGetters, }, actions: { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { console.log(\u0026#39;response\u0026#39;, response); commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) }, productById({ commit }, payload) { commit(\u0026#39;PRODUCT_BY_ID\u0026#39;); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(\u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(\u0026#39;REMOVE_PRODUCT\u0026#39;); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`).then(() =\u0026gt; { // 傳入 manufacturerId，用來刪除指定商品 commit(\u0026#39;REMOVE_PRODUCT_SUCCESS\u0026#39;, { productId, }); }) }, allManufacturers({ commit }) { commit(\u0026#39;ALL_MANUFACTURERS\u0026#39;); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(\u0026#39;ALL_MANUFACTURERS_SUCCESS\u0026#39;, { manufacturers: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(\u0026#39;REMOVE_MANUFACTURER\u0026#39;); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() =\u0026gt; { // 傳入 manufacturerId，用來刪除指定製造商 commit(\u0026#39;REMOVE_MANUFACTURER_SUCCESS\u0026#39;, { manufacturerId, }); }) }, } }); 移除原有 getters 和 mutations 不難理解，而引入新建的 getters 和 mutations 就值得說明了！\n首先藉由\nimport { productGetters, manufacturerGetters } from \u0026#39;./getters\u0026#39;; import { productMutations, cartMutations, manufacturerMutations } from \u0026#39;./mutations\u0026#39;; 引入剛剛分離出去的檔案\n接著使用 ES6 中的：擴展運算符（spread operator） 將剛剛引入的屬性以及包含的方法導入到 store 物件中。\n除此之外我們還偷偷在 actions 加入一些 action 屬性，稍後我們也會把它抽離出去\n這樣整個 store 看起來就會更簡潔了\n分離 Actions 邏輯 上面抽出了 Getters、Mutations 終於輪到 Actions 了\n重構 Edit 頁面 打開 src/views/admin/Edit.vue 替換成\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-form @save-product=\u0026#34;updateProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; :isEditing=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { created() { const { name } = this.model; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, model() { const product = this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); // 回傳 product 的備份，是為了在修改 product 的備份之後，在保存之前不修改本地 Vuex store 的 product 屬性 return { ...product, manufacturer: { ...product.manufacturer } }; } }, methods: { updateProduct(product) { this.$store.dispatch(\u0026#34;updateProduct\u0026#34;, { product }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 可以看到我們有兩個 computed：manufacturers 和 model，分別回傳製造商和當前商品\n之所以要回傳當前的 product 是為了在編輯了 product 的副本之後\n在存入資料庫之前先不變更使用者端 Vuex store 中的 product 屬性\n當組件被建立時，判斷 model 是否有值，如果沒有代表本機狀態庫中沒有資料\n必須透異步 API 取得商品資料，並且使用對應的 mutation 修改狀態庫中的資料\n在 \u0026lt;template\u0026gt; 中使用了子組件 ProductForm 來顯示商品資料\n按下表單送出時則會對送出 updateProduct 的異步 action，通知指定 mutation 來更新狀態\n重構 New 頁面 src/views/admin/New.vue 負責建立新的商品，邏輯與 Edit 類似\n只是一個負責新增商品，一個修改\n在這邊我們將組件中原本寫死的資料改為從後端動態取得，並將資料傳入給子組件 ProductForm\n\u0026lt;template\u0026gt; \u0026lt;product-form @save-product=\u0026#34;addProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34;\u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { created() { if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, model() { return {}; } }, methods: { addProduct(model) { this.$store.dispatch(\u0026#34;addProduct\u0026#34;, { product: model }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 跟 Edit 組件類似，只是這邊的 model 屬性回傳的是空物件，畢竟當前是不存在商品的\n拆分 Actions 邏輯 就像之前一樣建立 src/store/actions.js 檔案，用來管理 store 物件中 actions 屬性的內部屬性\n就跟上面處理 Getters 和 Manufacturers 時類似做法\nimport axios from \u0026#39;axios\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; export const productActions = { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) }, productById({ commit }, payload) { commit(\u0026#39;PRODUCT_BY_ID\u0026#39;); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(\u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(\u0026#39;REMOVE_PRODUCT\u0026#39;); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`).then(() =\u0026gt; { // 回傳 productId，用來刪除對應商品 commit(\u0026#39;REMOVE_PRODUCT_SUCCESS\u0026#39;, { productId, }); }) }, updateProduct({ commit }, payload) { commit(\u0026#39;UPDATE_PRODUCT\u0026#39;); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product).then(() =\u0026gt; { commit(\u0026#39;UPDATE_PRODUCT_SUCCESS\u0026#39;, { product, }); }) }, addProduct({ commit }, payload) { commit(\u0026#39;ADD_PRODUCT\u0026#39;); const { product } = payload; axios.post(`${API_BASE}/products`, product).then(response =\u0026gt; { commit(\u0026#39;ADD_PRODUCT_SUCCESS\u0026#39;, { product: response.data, }) }) } }; export const manufacturerActions = { allManufacturers({ commit }) { commit(\u0026#39;ALL_MANUFACTURERS\u0026#39;); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(\u0026#39;ALL_MANUFACTURERS_SUCCESS\u0026#39;, { manufacturers: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(\u0026#39;REMOVE_MANUFACTURER\u0026#39;); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() =\u0026gt; { // 回傳 manufacturerId，用來刪除對應的製造商 commit(\u0026#39;REMOVE_MANUFACTURER_SUCCESS\u0026#39;, { manufacturerId, }); }) }, } 可以發現我們把 API 的設定與使用都搬到這邊了，所以可以猜到下一步我們要做的就是「重構 Store」\n重構 Store 再次回到 src/store/index.js 檔案中，導入 Actions 邏輯相關的設定\n並且移除 API 相關的設定，包含引入 axios 和 API 網址的參數設定\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import { productGetters, manufacturerGetters } from \u0026#39;./getters\u0026#39;; import { productMutations, cartMutations, manufacturerMutations } from \u0026#39;./mutations\u0026#39;; import { productActions, manufacturerActions } from \u0026#39;./actions\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items cart: [], // ajax loader showLoader: false, // selected product product: {}, // all products products: [], // all manufacturers manufacturers: [], }, mutations: { ...productMutations, ...cartMutations, ...manufacturerMutations, }, getters: { ...productGetters, ...manufacturerGetters, }, actions: { ...productActions, ...manufacturerActions, } }); 於是我們就完成了 Actions 邏輯的抽換，來賓請掌聲鼓勵！\n新增 mutations 屬性 接著我們要在 src/store/mutations.js 的 productMutations 下新增一些 mutation 屬性\n用來處理使用者不同的操作時更新狀態庫中的內容同步\nUPDATE_PRODUCT(state) { state.showLoader = true; }, UPDATE_PRODUCT_SUCCESS(state, payload) { state.showLoader = false; const { product: newProduct } = payload; state.product = newProduct; state.products = state.products.map(product =\u0026gt; { if (product._id === newProduct._id) { return newProduct; } return product; }) }, ADD_PRODUCT(state) { state.showLoader = true; }, ADD_PRODUCT_SUCCESS(state, payload) { state.showLoader = false; const { product } = payload; state.products = state.products.concat(product); } 上面幾個 mutation 屬性分別處理了更新商品以及加入商品的邏輯，如此就完成了第一階段的重構\n本來還想把更多的重構寫在一起，但由於此篇篇幅以及資訊量已經很龐大，就在下一篇繼續優化我們的程式吧！\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202010-express-vue-build-ecommerce-16-refactor-vue-store/"
  },{
    "title": "[Express+Vue 搭建電商網站] 15 使用 Vuex Getters 複用資料邏輯",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用 Vuex Getters 複用資料邏輯",
    "body": "有時候我們需要 computed store 中的 state，在每個組件中複製貼上同樣的 computed 似乎不是一個明智的作法\nVuex Getter 是 Vuex 提供讓我們可以對 Vuex store 中 state 資料做預處理的方法，就可以達成這個目的\n建立 Getter 首先在原本的 src/store/index.js 檔案裡加入一些新的 action、mutation 屬性\n以及這次要使用的 getter\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import axios from \u0026#39;axios\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items cart: [], // ajax loader showLoader: false, // selected product product: {}, // all products products: [], // all manufacturers manufacturers: [], }, mutations: { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, ALL_PRODUCTS(state) { state.showLoader = true; }, ALL_PRODUCTS_SUCCESS(state, payload) { const { products } = payload; state.showLoader = false; state.products = products; }, PRODUCT_BY_ID(state) { state.showLoader = true; }, PRODUCT_BY_ID_SUCCESS(state, payload) { state.showLoader = false; const { product } = payload; state.product = product; } }, getters: { allProducts(state) { return state.products; }, productById: (state, getters) =\u0026gt; id =\u0026gt; { if (getters.allProducts.length \u0026gt; 0) { return getters.allProducts.filter(p =\u0026gt; p._id == id)[0]; } else { return state.product; } } }, actions: { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { console.log(\u0026#39;response\u0026#39;, response); commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) }, productById({ commit }, payload) { commit(\u0026#39;PRODUCT_BY_ID\u0026#39;); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(\u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;, { product: response.data, }); }) } } }); 主要增加了三個部分\nmutations：增加了 PRODUCT_BY_ID、PRODUCT_BY_ID_SUCCESS 用來管理單一商品的資訊狀態 actions：增加了 productById 來呼叫 mutations中的方法取得商品資訊 getters：建立 getters，並且加入 allProducts 和 productById 方法\nallProducts 取得所有商品；productById 則會回傳指定 id 的商品資料，如果商品不存在則回傳空的物件 在後台 Products 組件中使用 Getters 先使用一個簡單的範例說明 Getters 是怎麼運作的，打開 src/views/admin/Products.vue 組件\n並且把以下內容\nreturn this.$store.state.products[0]; 替換成\nreturn this.$store.getters.allProducts[0]; 在這個範例中，我們通過 this.$store.getters.allProducts 來調用 getter 中的 allProducts 屬性\n並且顯示出第一個商品的名稱\n建立 ProductDetail 組件 在簡單的了解 Getter 是怎麼運作之後，要來實現單一商品詳細內容的組件\n新建 src/components/products/ProductDetail.vue\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;product-details\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product-details__image\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;image\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;product-details__info\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product-details__description\u0026#34;\u0026gt; \u0026lt;small\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/small\u0026gt; \u0026lt;h3\u0026gt;產品名稱：{{product.name}}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;product-details__price-cart\u0026#34;\u0026gt; \u0026lt;p\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;product-button :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product-details__image .image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductButton from \u0026#34;./ProductButton\u0026#34;; export default { props: [\u0026#34;product\u0026#34;], components: { \u0026#34;product-button\u0026#34;: ProductButton } }; \u0026lt;/script\u0026gt; 可以看到這個組件將會利用父組件傳入的 product 物件來顯示內容\n並且複用了先前建立的 ProductButton 組件\n在 ProductItem 組件中為商品加入連結 有了詳細頁面，我們還需要設定怎麼進入商品詳細頁面的連結\n打開 src/components/products/ProductItem.vue 組件，將 \u0026lt;template\u0026gt; 區塊編輯成以下樣式\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/detail/\u0026#39; + product._id\u0026#34; class=\u0026#34;product-link\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;商品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;售價：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;/router-link\u0026gt; \u0026lt;product-button :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; 可以發現我們使用了之前學過的 vue-router 中的 router-link 方法跳轉到指定編號的商品頁面\n在 ProductList 中使用 Getters 而原先商品列表組件（src/components/products/ProductList.vue）「取得所有商品」功能\n也是直接操作 Vuex store 中的 state\ncomputed: { products() { return this.$store.state.products; } }, 在這邊我們也改用剛剛學到的 Getter 改寫成以下內容，使用指定的 getter：allProducts 取得所有商品資料\ncomputed: { products() { return this.$store.getters.allProducts; } }, 建立 Detail 頁面組件 現在子組件都完成了，只缺一個詳細商品頁面將組件拿來使用\n建立 src/views/Detail.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;product-detail :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-detail\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductDetail from \u0026#34;@/components/products/ProductDetail.vue\u0026#34;; export default { created() { // 如果使用者儲存的狀態中不存在此商品，則從後端取得商品資訊 const { name } = this.product; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } }, computed: { product() { return this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); } }, components: { \u0026#34;product-detail\u0026#34;: ProductDetail } }; \u0026lt;/script\u0026gt; 引入了 ProductDetail 組件，並且在生命週期中頁面建立「created()」時檢查使用者端是否有指定商品的資料\n沒有則使用異步方法呼叫 Vuex action 取得資訊，並透過 mutation 修改狀態\n其中的 computed 屬性用於取得狀態管理中的指定商品\n而其中的 id 參數透過 this.$route.params['id'] 取得路由中的產品編號，傳入指定的 getter 取得指定商品資料\n設定 Detail 頁面路由 剛剛提到會使用路由傳入的產品編號來查詢產品資料，有沒有想起什麼事情？\n打開 vue-router 的設定檔 src/router/index.js 引入 Detail 頁面\nimport Detail from \u0026#39;@/views/Detail\u0026#39;; 在路由規則中加入 Detail 頁面設定值\n{ path: \u0026#39;/detail/:id\u0026#39;, name: \u0026#39;Detail\u0026#39;, component: Detail, }, 成果 打開專案頁面，可以在商品列表發現所有商品現在都有了超連結\n點擊超連結之後會進入商品詳細頁面，而顯示的就是該商品的詳細資料\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202010-express-vue-build-ecommerce-15-use-vuex-getters/"
  },{
    "title": "[Express+Vue 搭建電商網站] 14 使用組件思維重構頁面邏輯",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用組件思維重構頁面邏輯",
    "body": "在先前我們學會怎麼使用 Vuex 進行狀態管理、如何使用 Action 取得 API 資料，以及使用 Mutation 更改狀態\n而這一篇中將透過 Vue 的組件化思維簡化原本複雜且分散於各個頁面的邏輯\n建立 ProductButton 組件 新建一個 src/components/products/ProductButton.vue 檔案\n準備用這個組件替換掉操作購物車中狀態按鈕的組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button v-if=\u0026#34;isAdding\u0026#34; class=\u0026#34;button\u0026#34; @click=\u0026#34;addToCart\u0026#34;\u0026gt;加入購物車\u0026lt;/button\u0026gt; \u0026lt;button v-else class=\u0026#34;button\u0026#34; @click=\u0026#34;removeFromCart(product._id)\u0026#34;\u0026gt;從購物車移除\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;product\u0026#34;], computed: { isAdding() { let isAdding = true; this.cart.map(product =\u0026gt; { if (product._id === this.product._id) { isAdding = false; } }); return isAdding; }, cart() { return this.$store.state.cart; } }, methods: { addToCart() { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product: this.product }); }, removeFromCart(productId) { this.$store.commit(\u0026#34;REMOVE_FROM_CART\u0026#34;, { productId }); } } }; \u0026lt;/script\u0026gt; 在這個組件中，透過了 v-if 來判斷 isAdding 這個 computed 是否為真\n而 isAdding 使用了來自 Vuex store 中 state 的 cart 參數\n藉由遍歷整個 cart 判斷當前的商品是否在購物車內，進而顯示對應的按鈕，並綁定不同的行為\naddToCart 和 removeFromCart 這兩個方法會調用 mutation 而改變 Vuex store 中的狀態\n建立 ProductItem 組件 建立好了按鈕後，要建立個別商品在渲染時使用的組件\n建立 src/components/products/ProductItem.vue 顯示商品相關資訊\n並引入上一步建立的 ProductButton 組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;商品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;售價：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;product-button :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductButton from \u0026#34;./ProductButton\u0026#34;; export default { name: \u0026#34;product-item\u0026#34;, props: [\u0026#34;product\u0026#34;], components: { \u0026#34;product-button\u0026#34;: ProductButton } }; \u0026lt;/script\u0026gt; 透過 import ProductButton from \u0026quot;./ProductButton\u0026quot; 引入剛剛建立的 ProductButton 組件\n並註冊在 components 物件中，最後在模板中使用組件\n重構 ProductList 組件 接著就可以把 src/components/products/ProductList.vue 這個組件重構\n把跟商品相關的模板部分移除，methods 中的加入購物車方法也一併移除\n因為單一商品的資料以及按鈕都已經加入到剛剛的 ProductItem 組件中\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;This is ProductList\u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in products\u0026#34;\u0026gt; \u0026lt;product-item :product=\u0026#34;product\u0026#34; :key=\u0026#34;product._id\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductItem from \u0026#39;./ProductItem.vue\u0026#39;; export default { name: \u0026#34;product-list\u0026#34;, created() { if (this.products.length === 0) { this.$store.dispatch(\u0026#34;allProducts\u0026#34;); } }, computed: { // a computed getter products() { return this.$store.state.products; } }, components: { \u0026#39;product-item\u0026#39;: ProductItem }, }; \u0026lt;/script\u0026gt; 我們在引用了 ProductItem 組件後，利用 v-for 把每個商品都傳入組件用來建立商品列表\n重構 Cart 頁面 就跟在 ProductItem 組件中一樣，我們也將 src/views/Cart.vue 頁面中的商品列表組件化\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in cart\u0026#34;\u0026gt; \u0026lt;product-item :product=\u0026#34;product\u0026#34; :key=\u0026#34;product._id\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductItem from \u0026#34;@/components/products/ProductItem.vue\u0026#34;; export default { name: \u0026#34;home\u0026#34;, data() { return { msg: \u0026#34;Welcome to the Cart Page\u0026#34; }; }, computed: { cart() { return this.$store.state.cart; } }, components: { \u0026#34;product-item\u0026#34;: ProductItem } }; \u0026lt;/script\u0026gt; 一樣引入 ProductItem 組件，並且在 components 中註冊\n接著就可以在模板中把購物車內的商品傳入給組件使用\n而頁面的功能不會有所改變，只是把重複的部分整合成組件來共用，增加維護性\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202010-express-vue-build-ecommerce-14-refactor-component/"
  },{
    "title": "[Express+Vue 搭建電商網站] 13 使用 Axios 取得 API 資料",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用 Axios 取得 API 資料",
    "body": "使用 Axios 取得後端 API 的資料\n使用 Axios 取得 API 資料 首先先安裝 axios npm i axios 在 Vuex store 中可以使用 action 屬性\n乍看之下跟 mutation 類似，不同的地方在於\nAction 提交的是 mutation，而不是直接變更狀態 Action 可以包含任意異步操作，用於響應 Vue 組件中分派的事件或動作 一個 action 是類似於 (context, payload) =\u0026gt; response.data 的函數：\nproductById(context, payload) { // 異步操作，從後端取得資料 return response.data; } 其中 productById 是從組件分派的事件或動作名稱，接收兩個參數 context、payload\ncontext 具有跟 store 相同的方法與屬性，可以透過 context.commit 來提交一個 mutation\n或是透過 context.state 和 context.getters 來取得 state 和 getters\npayload 就是攜帶的參數，可以透過他來執行異步操作，從而取得後端資料並回傳\n所以我們可以在 Action 中異步執行 axios 來抓取後端 API 的資料\n取得回傳結果後將結果提交給 mutation，並更新使用者端的資料\n實現 Action 再次修改 src/store/index.js\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import axios from \u0026#39;axios\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items cart: [], // ajax loader showLoader: false, // selected product product: {}, // all products products: [], // all manufacturers manufacturers: [], }, mutations: { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, ALL_PRODUCTS(state) { state.showLoader = true; }, ALL_PRODUCTS_SUCCESS(state, payload) { const { products } = payload; state.showLoader = false; state.products = products; } }, actions: { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { console.log(\u0026#39;response\u0026#39;, response); commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) } } }); 我們總共做了幾件事情\n導入 axios，定義了後端 API 的網址到 API_BASE 刪除 store 中的假資料，清空 products 陣列 mutations 增加了 ALL_PRODUCTS 和 ALL_PRODUCTS_SUCCESS 方法\u0026lt; 用來處理撈取後端資料的載入狀態以及資料 最後加入了 actions 屬性，定義了 allProducts 函數，用來響應組件的對應事件\n首先提交了 ALL_PRODUCTS mutation，接著在 axios 取得後端資料後提交了 ALL_PRODUCTS_SUCCESS\n並且把取得的資料命名為 products 一併作為 payload 傳入 提示：\n可以看到在 allProducts 中我們傳入了 { commit } 參數\n這地方使用了解構賦值 const { commit } = context\n代替比較長的 context.commit\n因為目前我們沒用到其他 context 屬性，所以這麼做是可以的\n更新組件 ProductList 將 src/components/products/ProductList.vue 的 \u0026lt;script\u0026gt; 區塊改成以下\n\u0026lt;script\u0026gt; export default { name: \u0026#34;product-list\u0026#34;, created() { if (this.products.length === 0) { this.$store.dispatch(\u0026#34;allProducts\u0026#34;); } }, computed: { // a computed getter products() { return this.$store.state.products; } }, methods: { addToCart(product) { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product }); } } }; \u0026lt;/script\u0026gt; 增加了一個 created() 生命週期方法，在這個組件被建立時判斷使用者端是否有商品資料\n若是沒有，則需要跟後端 API 要資料\n於是通過 this.$store.dispatch 方法觸發名叫 allProducts 的 action\n為什麼我們這邊不使用 commit 操作 mutation 而是使用 dispatch 呢？\n是因為 mutation 必須是一個同步執行的程式，而這邊是一個異步請求\n需要使用 dispatch 來操作 Action 進行異步請求\n再來是 \u0026lt;template\u0026gt;，我們做部分修改，讓畫面渲染時的資料符合當初後端 API 定義的格式\n\u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/p\u0026gt; Cart 接著打開 src/views/Cart.vue 頁面，因為上面也有顯示生產商的名稱\n同樣把 {{product.manufacturer}} 改成 {{product.manufacturer.name}}\n測試結果 首先確認先前的後端 API 專案已經啟動，並且 MongoDB 也在運行中\n如果先前在撰寫 API 時你沒有進行測試，則資料庫應該為空。先去加一些資料吧！\n完成之後進入前端測試，應該就可以發現商品的資料就是後端 API 傳來的資料\n如果不確定的話，可以照著先前的教學，使用 Postman 取得 API 中的商品列表和前端的資料比對\n取得的資料和先前一樣，可以加入與移出購物車\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202009-express-vue-build-ecommerce-13-how-to-use-axios/"
  },{
    "title": "[Express+Vue 搭建電商網站] 12 在 Vuex 使用 Mutation 管理狀態",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 在 Vuex 使用 Mutation 管理狀態",
    "body": "透過 Mutation 管理 Vuex中的狀態\n使用 Mutation 在 Vuex 中 Mutation 是修改 Vuex store 內容的唯一方法\nMutation 是定義在 Vuex store 物件中 mutations 屬性的一系列函數\n長得會像\nACTION_NAME(state, payload) { return state++; } 其中 ACTION_NAME 就是組件發出的事件或動作的名稱\n這個函數接收兩個參數 state 和 payload。state 就是在 Vuex store 裡面儲存的 state\npayload 則是跟著呼叫的事件或是動作一起傳來的參數\n然後就可以對現有的 state 做操作而回傳新的 state，透過這種方式我們可以輕鬆的管理所有狀態\n初始化 mutations 狀態 打開 src/store/index.js 檔案，修改其中的 state\n並加入 mutations，這邊我們先把資料寫死，未來會接上先前寫的後端 API\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items cart: [], // ajax loader showLoader: false, // selected product product: {}, // all products products: [ { _id: \u0026#39;1\u0026#39;, name: \u0026#39;iPhone 11\u0026#39;, description: \u0026#39;全新雙相機系統，捕捉所見所愛，範圍更多更廣。智慧型手機歷來最快速的晶片，加上滿足一天的電池續航力，讓你完成更多事，充電更少次。而智慧型手機中最高的影片畫質，讓你的點滴回憶，看起來比過去更加動人精彩。\u0026#39;, image: \u0026#39;https://i.gadgets360cdn.com/large/iPhone11_leak_1567592422045.jpg\u0026#39;, price: 44000, manufacturer: \u0026#39;Apple Inc\u0026#39; }, { _id: \u0026#39;2\u0026#39;, name: \u0026#39;Pixel 4\u0026#39;, description: \u0026#39;只要用Pixel 4 拍照，不用進工作室後製編輯，也能拍出相同品質的相片！Pixel 4 是第一支能夠拍下銀河的手機，只要輕輕一點，就能拍下美麗星空。\u0026#39;, image: \u0026#39;https://pgw.udn.com.tw/gw/photo.php?u=https://uc.udn.com.tw/photo/2019/10/16/realtime/6946830.jpg\u0026#39;, price: 24990, manufacturer: \u0026#39;Google\u0026#39; }, { _id: \u0026#39;3\u0026#39;, name: \u0026#39;Xperia 1 II\u0026#39;, description: \u0026#39;由於 Sony 先前整合了 Mobile 手機部門到 Sony 本家消費性電子產品部門的緣故，所以這次以這樣的命名方式出現也不讓人意外。\u0026#39;, image: \u0026#39;https://timgm.eprice.com.tw/tw/mobile/img/2020-02/24/5484360/innocences_1_a8c4b844f3c0c83646b79e366c3d8111.jpg\u0026#39;, price: 29000, manufacturer: \u0026#39;SONY\u0026#39; }, { _id: \u0026#39;4\u0026#39;, name: \u0026#39;V30S\u0026#39;, description: \u0026#39;LG V30 S ThinQ 最大的改變是 Vision AI 功能的加入，拍照的同時相機會自動識別畫面中的場景，準確的設定場景模式。\u0026#39;, image: \u0026#39;https://img.eprice.com.tw/img/mobile/5858/large.png\u0026#39;, price: 12500, manufacturer: \u0026#39;LG\u0026#39; }, { _id: \u0026#39;5\u0026#39;, name: \u0026#39;Galaxy Note 9\u0026#39;, description: \u0026#39;做為三星每年下半年度的旗艦手機，Note 系列從 2011 年的第一代 Galaxy Note 起，就以 S Pen 做為最大賣點，並且帶動大螢幕智慧手機的風潮直到今日。\u0026#39;, image: \u0026#39;https://timgm.eprice.com.tw/tw/mobile/img/2018-08/09/5115231/hat7029_1_77763a4f06a1fba43ab32e66d90bcba1.jpg\u0026#39;, price: 18900, manufacturer: \u0026#39;Samsung\u0026#39; } ], // all manufacturers manufacturers: [], }, mutations: { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) } } }); 除了 state 中暫時寫死的商品內容外，我們加了兩個 mutations 屬性下的方法\n分別代表組件中「將商品加入購物車」以及「從購物車移除移出商品」的動作\nProductList 組件 接著要新建「商品列表」的組件，用來展示商品詳細資訊\n新建 /src/components/products/ProductList.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;This is ProductList\u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in products\u0026#34;\u0026gt; \u0026lt;div :key=\u0026#34;product._id\u0026#34; class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;產品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;addToCart(product)\u0026#34;\u0026gt;加入購物車\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;product-list\u0026#34;, computed: { // a computed getter products() { return this.$store.state.products; } }, methods: { addToCart(product) { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product }); } } }; \u0026lt;/script\u0026gt; 在 \u0026lt;script\u0026gt; 中定義了一個 computed 作為商品資料的預處理\n這樣在模板渲染時就只需要使用 {products} 就可以取得在 Vuex store 中的 products 資料\n然後定義了一個點擊事件 addToCart 來處理加入購物車按鈕的點擊\n會通過 this.$store.commit 方法\n將目前商品物件 {product} 當作 payload 來操作 Vux store 中 mutation 所定義的 ADD_TO_CART 方法做狀態修改\n組件建立完之後要在畫面引入才能使用\n修改首頁 src/pages/Home.vue 把剛剛建立的 ProductList.vue 組件加入畫面\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;In Stock\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-list\u0026gt;\u0026lt;/product-list\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductList from \u0026#39;@/components/products/ProductList.vue\u0026#39;; export default { name: \u0026#39;home\u0026#39;, data () { return { msg: \u0026#39;Welcome to Your Vue.js App\u0026#39; }; }, components: { \u0026#39;product-list\u0026#39;: ProductList } } \u0026lt;/script\u0026gt; 購物車 接著要修改購物車頁面 /src/views/Cart.vue 將商品資訊顯示出來。\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in cart\u0026#34;\u0026gt; \u0026lt;div :key=\u0026#34;product._id\u0026#34; class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;產品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;removeFromCart(product._id)\u0026#34;\u0026gt;從購物車中移除\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;home\u0026#34;, data() { return { msg: \u0026#34;Welcome to the Cart Page\u0026#34; }; }, computed: { cart() { return this.$store.state.cart; } }, methods: { removeFromCart(productId) { this.$store.commit(\u0026#34;REMOVE_FROM_CART\u0026#34;, { productId }); } } }; \u0026lt;/script\u0026gt; 同樣的加入 computed 對商品做預處理\n這邊接收的是 this.$store.state.cart 也就是購物車中的商品列表\n寫好觸發 Vuex mutation 中移出購物車的按鈕方法 removeFromCart\n接著就可以開啟瀏覽器預覽執行結果\n一開始購物車是空的，我們隨便加了幾款手機進購物車後，在購物車頁面可以看見剛剛有選中的商品！\n而在購物車頁面可以將商品從購物車移除。\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202009-express-vue-build-ecommerce-12-vuex-mutation/"
  },{
    "title": "[Express+Vue 搭建電商網站] 11 認識 vuex",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 認識 vuex",
    "body": "vuex 來協助我們集中管理組件狀態，就不用到處維護狀態\n使得組件只需要專注於渲染頁面，而前端狀態都保留在 vuex 中建立的狀態庫中\n所謂狀態庫，其實也就是一個 Javascript 物件\n安裝 vuex 可以使用指令\nnpm install vuex --save 或是依然使用 vue ui 來安裝\n如果是使用 vue ui 安裝，會發現專案下多了一個檔案：/src/store/index.js，先用以下內容取代原本的檔案\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items cart: [], // ajax loader showLoader: false, // selected product product: {}, // all products products: [ { name: \u0026#39;產品 1\u0026#39;, } ], // all manufacturers manufacturers: [], } }) 上面我們做了一些事情\n導入了 Vue 和 Vuex 調用 Vue.use 方法宣告使用 Vuex，聽起來和 vue-router 的時候一樣 最後導出 Vuex.Store 物件，並傳入 strict 和 state 參數\nstrict 宣告我們必須使用 Vuex 的 Mutation 函數來改變 state，否則會報錯（這部分會在之後的章節說明）\n而 state 參數儲存全域的狀態，比如在這邊定義了 cart、showLoader 等屬性\n都是後面我們操作會使用到的資料 整合 Vuex 和 Vue 當我們建立了 Vuex 的 store 物件後就可以使用它了，打開 src/main.js\n在開頭導入之前建立的 store，並且將 store 添加到 Vue 初始化的參數列表裡\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; Vue.config.productionTip = false new Vue({ router, store, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 如果你是使用 Vue ui 安裝，打開檔案可以見到程式已經幫我們完成了以上的內容\n當我們將 store 導入到了 Vue 中進行初始化後，Vue 會將 store 裡面的 state 注入到所有的組件中\n這樣所有的 Vue 組件就共享了一個全域的 state\n而所有的狀態變化都是針對這個 javascript 物件進行操作，然後觸發組件的重新渲染\n同時也避免了組件嵌套層級過多時，組件之間傳遞屬性的複雜性，便於大型程式與團隊合作\n查看結果 在整合好 Vuex 和 Vue 之後，馬上來看看 Vuex 帶來的變化。打開 src/pages/admin/Products.vue 修改成以下內容\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt;{{ product.name }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { computed: { product() { return this.$store.state.products[0]; } } }; \u0026lt;/script\u0026gt; 可以在 \u0026lt;script\u0026gt; 中看到一個沒見過的東西 computed，先來了解一下這是什麼\nComputed 如果在前端模板內加入太多的邏輯運算，不但可讀性差也難以維護，這問題在後端套版時常常發生，很難一眼看出它到底要渲染什麼\n而 計算屬性 (computed) 有點類似於 method，但 method 需要括號來觸發\n而且 method 不管相依的資料有沒有改變，都會重新計算。computed 則是在相依的資料有改變時才做計算並渲染\n所以需要每次更新的行為用 method，在意效能的話使用 computed\n講完了 computed 屬性，回頭來看剛剛的改動，我們在 computed 定義了一個 product 屬性\n會去 Vuex 也就是 store 中的 state 中 products 的第一個元素\n然後在頁面上使用剛剛取到的內容中的 name 屬性渲染\n於是我們知道可以使用 this.$store.state 來取得 Vuex store 中保存的 state\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202009-express-vue-build-ecommerce-11-install_vuex/"
  },{
    "title": "[Express+Vue 搭建電商網站] 10 用 vue 建立一個表單",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 用 vue 建立一個表單",
    "body": "後端的 API 上次已經開了出來，接著來建立前端使用的表單\n這次的目標是建立新增商品時所用的表單，會使用到基本的 Vue 知識，如果沒看過文件的可以先了解一下官方文件\n架構規劃 之前我們建立了 /src/views/admin/New.vue 這個模板做為網址 /admin/new 的顯示頁面\n在這節中會建立一個表單，然後讓他作為頁面組件顯示在 New.vue 中\n程式實作 建立一個新的檔案 /src/components/products/ProductForm.vue 作為表單的組件\n可以看到我們在這邊的存放位置不再是 /src/views/ 因為他是組件\n好好的放在「components」內是比較好的架構方式\n\u0026lt;template\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;saveProduct\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-5 col-md-5 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Name\u0026#34; v-model=\u0026#34;model.name\u0026#34; name=\u0026#34;name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Price\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Price\u0026#34; v-model=\u0026#34;model.price\u0026#34; name=\u0026#34;price\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Manufacturer\u0026lt;/label\u0026gt; \u0026lt;select type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; v-model=\u0026#34;model.manufacturer\u0026#34; name=\u0026#34;manufacturer\u0026#34;\u0026gt; \u0026lt;template v-for=\u0026#34;manufacturer in manufacturers\u0026#34;\u0026gt; \u0026lt;option :key=\u0026#34;manufacturer._id\u0026#34; :value=\u0026#34;manufacturer._id\u0026#34; :selected=\u0026#34;manufacturer._id == (model.manufacturer \u0026amp;\u0026amp; model.manufacturer._id)\u0026#34; \u0026gt;{{manufacturer.name}}\u0026lt;/option\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-lg-4 col-md-4 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Image\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; lass=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Image\u0026#34; v-model=\u0026#34;model.image\u0026#34; name=\u0026#34;image\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Description\u0026lt;/label\u0026gt; \u0026lt;textarea class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Description\u0026#34; rows=\u0026#34;5\u0026#34; v-model=\u0026#34;model.description\u0026#34; name=\u0026#34;description\u0026#34; \u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group new-button\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-pencil\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;!-- Conditional rendering for input text --\u0026gt; \u0026lt;span v-if=\u0026#34;isEditing\u0026#34;\u0026gt;Update Product\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;Add Product\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;model\u0026#34;, \u0026#34;manufacturers\u0026#34;, \u0026#34;isEditing\u0026#34;], methods: { saveProduct() { this.$emit(\u0026#34;save-product\u0026#34;, this.model); } } }; \u0026lt;/script\u0026gt; 程式說明 於是我們來看看這段看起來很長很嚇人的東西在做什麼？\n分為兩部分來理解\nscript 部分 props 主要接收父組件傳來的三個參數 model、manufacturers、isEditing\n然後在 methods 定義了一個方法 saveProduct，當使用者填完送出後按下送出會觸發這個方法\n而在 saveProduct 內部調用了一個 save-product 方法，這個方法稍後會在父組件建立\n除了調用父組件方法，在送出的同事還會把 this.model 內容傳遞給父組件\ntemplate 部分 淺而易見的 template 就是一個表單，其中的 submit 事件使用 @submit.prevent 禁用預設的送出行為\n並使用 saveProduct 替換\n接著寫了好幾個 class=\u0026quot;form-group\u0026quot; 的區塊，代表要填寫的商品資料\n其中前兩個區塊使用了 v-model 綁定 model 的 name、price 兩個屬性\n第三個區塊先對 select 標籤雙向綁定了 model.manufacturer 屬性\n代表在內部做的行為都會影響對應的 model.manufacturer\n接著使用迴圈把 script 中接收到的父組件 manufacturers 資料一個一個設為 option 標籤內容\n並且把個別設定 manufacturer 的屬性\n以及如果 model.manufacturer._id 和當前的 manufacturer._id 一致\n就把 selected 屬性設為 true\n接著第四個 form-group 開始，依然是使用 v-model 綁定 model.image 和 model.description 屬性\n最後一個 form-group 使用 v-if 判斷式來判斷 isEditing 來渲染不同的按鈕文字\n完成了子組件之後，就要引入父組件內。所以重新打開 New.vue 這個檔案，引入剛剛建立的表單組件\n\u0026lt;template\u0026gt; \u0026lt;product-form @save-product=\u0026#34;addProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; \u0026gt; \u0026lt;/product-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#39;@/components/products/ProductForm.vue\u0026#39;; export default { data() { return { model: {}, manufacturers: [ { _id: \u0026#39;sam\u0026#39;, name: \u0026#39;Samsung\u0026#39;, }, { _id: \u0026#39;apple\u0026#39;, name: \u0026#39;Apple\u0026#39;, }, ], }; }, methods: { addProduct(model) { console.log(\u0026#39;model\u0026#39;, model); }, }, components: { \u0026#39;product-form\u0026#39;: ProductForm } } \u0026lt;/script\u0026gt; 當要在一個組件中使用另一個組件時，需要在父組件的 components 中註冊\n在我們的 New.vue 中就將 ProductForm 註冊為 product-form\n於是我們就可以在 \u0026lt;template\u0026gt; 區塊中使用 \u0026lt;product-form /\u0026gt; 來使用組件。\n同時在 data 中定義了 model 和 manufacturers；methods 中定義了 addProduct 方法\n並且綁定成 @save-product=\u0026quot;saveProduct\u0026quot; 事件傳遞給子組件使用\n儲存之後，重新開啟前端網頁，進入新建商品的頁面就可以看到子組件已經被加入 New.vue 的畫面上\n目前為止我們學會了\n使用 vue-router 進行多頁面的跳轉與路由 使用嵌套路由有組織的管理前端路由 基礎的 Vue 使用 學會建立 Vue 的組件並在父組件中使用 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202009-express-vue-build-ecommerce-10-new-product-page/"
  },{
    "title": "[Express+Vue 搭建電商網站] 09 API 測試",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 測試",
    "body": "在上一篇中完成了第一個 API，這一篇要來測試 API 是不是正常工作\n測試 API 經過上一篇的流程，我們的 API 應該已經建好了，現在透過常用的 API 測試軟體：Postman 來測試\nmanufacturers POST /api/v1/manufacturers\n首先先建立供應商的資料，測試新建一個供應商「Google」\nGET /api/v1/manufacturers\n查看供應商，因為我原本就有寫入了一個供應商「Apple」所以會有兩筆資料\nPUT /api/v1/manufacturers/:id\n接著更新「APPLE」為「Apple」\nDELETE /api/v1/manufacturers/:id\n最後我特別建立了一個叫做「samsung」的供應商用來測試刪除功能\nproducts 最後來測試新建產品資料\nPOST /api/v1/products\n建立一個產品「iPhone 11」並且把他的供應商（manufacturer）指定給剛剛看過的「Apple」\nGET /api/v1/products 新增完之後，使用 GET 方法取得資料查看會發現，iPhone 11 這筆資料的外部鍵值 manufacturer\n屬性的確是對應到當初在 model 設定中指定的 manufacturer Model 的 ObjectId 資料內容\n在這個範例中就是「Apple」。如此我們就建立了一款 Apple 出的手機：iPhone 11\n結論 到這邊我們就已經建立好了 API 的服務\n在這幾個章節中我們學到了\n了解 Express 路由以及如何使用 mongoose 連接 monogoDB 資料庫 編寫路由、Controller 和 Model 使用 Postman 測試 API 目前我們對於 Node 和 Express 搭建後端 API 有了基本的了解，就繼續前進吧！\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-09-test-api/"
  },{
    "title": "[Express+Vue 搭建電商網站] 08 API 建立",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 建立",
    "body": "在上一篇中建立了 Router，這一篇要做的就是將 Controller 完成，如此就完成了第一個 API\n建立 API 建立 Controller 接著就來建立兩個 Controller productController 和 manufacturerController\ncontrollers/manufacturer.js 這個 Controller 管理製造商（manufacturers）資料的操作，回頭看看上面路由中的方法是不是都找到了呢？\n開頭導入了之前在 Model 中定義過的 ManufacturerModel，這是 mongoose 提供給我們操作資料庫的介面\n通過 Model 上定義的一系列指令來對 Manufacturer 做資料操作\nconst Model = require(\u0026#39;../model\u0026#39;); const { Manufacturer } = Model; const manufacturerController = { all(req, res) { Manufacturer.find({}) .exec((err, manfacturers) =\u0026gt; res.json(manfacturers)) }, byId(req, res) { const idParams = req.params.id; Manufacturer .findOne({ _id: idParams }) .exec((err, manufacturer) =\u0026gt; res.json(manufacturer)); }, create(req, res) { const requestBody = req.body; const newManufacturer = new Manufacturer(requestBody); newManufacturer.save((err, saved) =\u0026gt; { Manufacturer .findOne({ _id: newManufacturer._id }) .exec((err, manfacturer) =\u0026gt; res.json(manfacturer)) }) }, update(req, res) { const idParams = req.params.id; let manufacturer = req.body; Manufacturer.updateOne({ _id: idParams }, { ...manufacturer }, (err, updated) =\u0026gt; { res.json(updated); }) }, remove(req, res) { const idParams = req.params.id; Manufacturer.findOne({ _id: idParams }).remove( (err, removed) =\u0026gt; res.json(idParams) ) } } module.exports = manufacturerController; controllers/product.js 而在 productController 中基本上與上方 manufacturerController 概念一致\nconst Model = require(\u0026#39;../model\u0026#39;); const { Product } = Model; const productController = { all(req, res) { Product.find({}) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, products) =\u0026gt; res.json(products)) }, byId(req, res) { const idParams = req.params.id; Product .findOne({ _id: idParams }) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, product) =\u0026gt; res.json(product)); }, create(req, res) { const requestBody = req.body; const newProduct = new Product(requestBody); newProduct.save((err, saved) =\u0026gt; { Product .findOne({ _id: newProduct._id }) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, product) =\u0026gt; res.json(product)) }) }, update(req, res) { const idParams = req.params.id; const product = req.body; console.log(\u0026#39;idParams\u0026#39;, idParams); console.log(\u0026#39;product\u0026#39;, product); Product.updateOne({ _id: idParams }, { ...product }, (err, updated) =\u0026gt; { res.json(updated); }) }, remove(req, res) { const idParams = req.params.id; Product.findOne({ _id: idParams }).remove( (err, removed) =\u0026gt; res.json(idParams) ) } } module.exports = productController; 完成後存擋，在終端機執行 npm start\n要先先確定是你的 mongoDB 要是開著的，可以使用指令\nmongo 看能不能進入 mongo 的指令列中，如果忘記怎麼開啟可以回到前面：連接 MongoDB 章節複習\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-08-build-api/"
  },{
    "title": "[Express+Vue 搭建電商網站] 07 API 路由建立",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 路由建立",
    "body": "在上一篇中建立了 Model，這一篇要做的就是將路由完成，讓請求可以送到指定的 Controller\nAPI 路由建立 新增路由並設定路由群組 打開 app.js 引入我們要使用的 api 路由\nconst api = require(\u0026#39;./routes/api\u0026#39;); 路徑就設定成 /api/v1 吧\napp.use(\u0026#39;/api/v1\u0026#39;, api); 這下子所有進入 /api/v1/ 以及底下路徑的所有請求都會進入 /routes/api 這個路由內\n建立新路由 我們建立一個檔案 /routes/api/index.js\nconst express = require(\u0026#39;express\u0026#39;); const router = express.Router(); const productController = require(\u0026#39;../../controllers/product\u0026#39;); const manufacturerController = require(\u0026#39;../../controllers/manufacturer\u0026#39;); router.get(\u0026#39;/manufacturers\u0026#39;, manufacturerController.all); router.get(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.byId); router.post(\u0026#39;/manufacturers\u0026#39;, manufacturerController.create); router.put(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.update); router.delete(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.remove); router.get(\u0026#39;/products\u0026#39;, productController.all); router.get(\u0026#39;/products/:id\u0026#39;, productController.byId); router.post(\u0026#39;/products\u0026#39;, productController.create); router.put(\u0026#39;/products/:id\u0026#39;, productController.update); router.delete(\u0026#39;/products/:id\u0026#39;, productController.remove); module.exports = router; 我們在上一步建立了路由群組，而這個步驟中我們照著經典的 RESTful API 規則來撰寫路由規則\nget：取得資源 post：建立新資源 put：更新資源 delete：刪除資源 在這個路由群組中不難發現，我們引用了 productController、manufacturerController\n這兩個尚未建立的檔案，而這兩個檔案就是我們 MVC 中的 Controller\n而 router 物件接了各種路徑的請求方法，並指定給所屬的 Controller 方法\n下個章節會建立 Controller 並且測試 API 是否成功運行\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-07-api-routes/"
  },{
    "title": "[Express+Vue 搭建電商網站] 06 - 資料庫設計",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 資料庫設計",
    "body": "先前我們安裝好了 mongoDB 以及開啟了 CORS，這一篇要來建立資料庫架構以及 MVC 架構中的 Model 部分\n資料庫設計 Schema 在 Express 中，資料庫的 Schema 是建立在 model/index.js 中的，如果沒有 model 資料夾就自己建一個\nconst mongoose = require(\u0026#39;mongoose\u0026#39;); const Schema = mongoose.Schema; const model = mongoose.model.bind(mongoose); const ObjectId = mongoose.Schema.Types.ObjectId; const productSchema = Schema({ id: ObjectId, name: String, image: String, price: Number, description: String, manufacturer: { type: ObjectId, ref: \u0026#39;Manufacturer\u0026#39; } }); const manufacturerSchema = Schema({ id: ObjectId, name: String, }); const Product = model(\u0026#39;Product\u0026#39;, productSchema); const Manufacturer = model(\u0026#39;Manufacturer\u0026#39;, manufacturerSchema); module.exports = { Product, Manufacturer }; 在下方兩個 model 的常數定義中 Schema 接收一個物件來定義資料結構以及對應的類型\n除了常見的 String, Number 外，比較特別的是：ObjectId 代表 MongoDB 中資料的主鍵，具有唯一性\n並且在 productSchema 中具有一個特別的屬性：manufacturer\n這個物件定義了一個 ref 屬性，對應到 Manufacturer 這個 model\n這是 MongoDB 的外部鍵值，與之對應的是 Manufacturer 中的 ObjectId 屬性的資料\n這就是我們習慣的 MVC 架構中的「Model」部分\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-06-db-schemas-and-models/"
  },{
    "title": "[Express+Vue 搭建電商網站] 05 - 連接 MongoDB 與 CORS",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 連接 MongoDB 與 CORS",
    "body": "資料庫使用 MongoDB，這篇中我們會簡單介紹基本連線方式，以及跨來源資源共(CORS)\n連接 MongoDB 接著我們要安裝 mongoose 套件：Mongoose Mongoose 是一個 MongoDB 對象建模工具，用於在異步環境中工作\n是時下最流行的 ODM(Object Document Mapping)，要比直接操作底層 MongoDB Node 更方便\nnpm install mongoose 接著回到 app.js 中導入剛剛安裝的 mongoose\nconst mongoose = require(\u0026#39;mongoose\u0026#39;) 並透過套件提供的方法連上我們的 MongoDB 資料庫\nmongoose.connect(`mongodb://localhost:27017/test`); 雖然現在看不出效果，但我們等等會嘗試操作資料庫來測試連線的有效性\n但現在我們先做點額外的事情，儘管目前看來沒什麼用處但卻是必要的一環\n那就是開啟跨來源資源共用 CORS\n跨來源資源共用 CORS CORS 是基於 同源政策 的限制\n當關閉時限制了程式碼和不同網域資源間的互動，來自不同網域的資源請求會被無情拒絕！\n讓我們回到 app.js，在剛剛的資料庫連線下一行加入以下程式碼\n// CORS config here app.all(\u0026#39;/*\u0026#39;, function(req, res, next) { // CORS headers res.header(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); // restrict it to the required domain res.header(\u0026#39;Access-Control-Allow-Methods\u0026#39;, \u0026#39;GET,PUT,POST,DELETE,OPTIONS\u0026#39;); // Set custom headers for CORS res.header(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;Content-type,Accept,X-Access-Token,X-Key\u0026#39;); if (req.method == \u0026#39;OPTIONS\u0026#39;) { res.status(200).end(); } else { next(); } }); 通常來說會使用 npm 套件 cors 解決，但這邊先用簡單暴力的方式解決\n未來如果有進行優化會再回頭安裝\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202007-express-vue-build-ecommerce-05-mongodb-connect-and-cors/"
  },{
    "title": "[Express+Vue 搭建電商網站] 04 - 進入 MongoDB 的世界",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 進入 MongoDB 的世界",
    "body": "資料庫使用 MongoDB，這篇中我們會簡單介紹基本指令及安裝。\n安裝 MongoDB 因為使用的是 mac 筆電，所以最愛用 Homebrew 安裝東西\n除了 node.js！這東西用 brew 裝會把你搞到懷疑人生，並且連官網都不建議這麼做\n但是 MongoDB 官方有釋出：使用 Homebrew 的安裝方法 ，我們就這個做看看吧\n至於不會使用 Homebrew 或是使用其他作業系統的人，可以使用：官方的下載中心 進行安裝\n安裝好之後有兩種啟動的方法\n作為背景執行：mongod --config /usr/local/etc/mongod.conf --fork 使用 brew 管理 這邊推薦使用 brew 來操作的原因是容易操作，簡單幾個指令就可以\n啟動服務：brew services start mongodb-community 重新啟動：brew services restart mongodb-community 停止服務：brew services stop mongodb-community 執行之後繼續輸入 mongo 指令，應該會進到 mongoDB 的指令列中\n到這邊就代表已經 mongoDB 服務就安裝並且啟動了\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202007-express-vue-build-ecommerce-04-hello-mongodb/"
  },{
    "title": "[Express+Vue 搭建電商網站] 03 - 認識 Express",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 認識 Express",
    "body": "後端使用的是 node.js 的後端框架 - express，這篇中我們會建立新專案。\n建立 Express 專案 使用 express-generator 來建立專案\nnpm install -g express-generator 安裝完成後可以使用以下指令查看版本是否有安裝成功\nexpress --version 接著初始化建立新專案\nexpress backend 建立之後運行看看初始樣貌\ncd backend npm install npm start 打開瀏覽器 http://localhost:3000/ 應該會看到以下畫面\n打開看看 Express 專案的資料夾架構\napp.js：Express Web Application 原型 routes/index.js：路由設定主要檔案 views/：放 View 的檔案 public/：放靜態檔案 和其它文章不同的是，這次使用 express-generator 建立的專案中並沒有把所有路由給寫在 app.js 中\n而是根據不同的應用做拆分，這和前端使用 vue-router 的嵌套路由是相同的概念\napp.js 在 app.js 中一開始先對於會用到的資源進行導入，例如 routes/index 和 routes/users 兩個路由\n也定義了專案使用的前端模板類型。但因為我們後端是作為 API 使用，所以沒什麼差\nroutes/index.js 而在 routes/index.js 中定義了進入這個路由之後對於不同請求可以做的回應方式\n這就是主要我們需要先了解的部分\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202007-express-vue-build-ecommerce-03-hello-express/"
  },{
    "title": "[Express+Vue 搭建電商網站] 02 - vue-router 的使用",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - vue-router 的使用",
    "body": "在接下來的內容中會學習 vue-router 的使用方法與學習路由基礎知識\n並使用 vue-router 來進行多個頁面的跳轉\n建立新組件 首先我們要先建立新的頁面組件，新建一個 src/components/Home.vue 檔案\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;home\u0026#39;, data () { return { msg: \u0026#39;Welcome to Your Vue.js App\u0026#39; }; }, } \u0026lt;/script\u0026gt; 看起來跟一開始預設的 HelloWorld.vue 有 87% 像，但是這邊先不對樣式做糾結，之後再去找 UI 庫套用\n設定 vue-router 在安裝了 vue-router 之後，會發現專案中多了一個資料夾 /src/router/index.js\n這就是 vue-router 的設定檔\n藉由以下這段我們發現，路徑 '/' 使用的是 Home 這個組件\nconst routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;About\u0026#39;, // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =\u0026gt; import(/* webpackChunkName: \u0026#34;about\u0026#34; */ \u0026#39;../views/About.vue\u0026#39;) } ] 順著邏輯往上找會發現 Home 這個組件的引用來源\nimport Home from \u0026#39;../views/Home.vue\u0026#39; 接著打開 /views/Home.vue，原來這引入了 HelloWorld 組件\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;../assets/logo.png\u0026#34;\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // @ is an alias to /src import HelloWorld from \u0026#39;@/components/HelloWorld.vue\u0026#39; export default { name: \u0026#39;Home\u0026#39;, components: { HelloWorld } } \u0026lt;/script\u0026gt; 知道原理之後呢，就把 /views/Home.vue 內部目前沒有用到的部分刪除，並且換成我們上面建立的 Home 組件\n\u0026lt;script\u0026gt; // @ is an alias to /src import Home from \u0026#39;@/components/Home.vue\u0026#39; export default { name: \u0026#39;Home\u0026#39;, components: { Home } } \u0026lt;/script\u0026gt; 這時候使用瀏覽器開啟專案首頁，應該就會看到首頁已經變成 Home.vue 的內容\n加入頁面上方導航超連結 打開 App.vue 檔案，在 id=\u0026quot;app\u0026quot; 中加入三個 router-link 標籤的超連結，這是 Vue Router 的 API 根據官網說明 \u0026lt;router-link\u0026gt; 比起寫死的 \u0026lt;a href=\u0026quot;...\u0026quot;\u0026gt; 會好一些\n無論是 HTML5 history 模式還是 hash 模式，它的表現行為一致，所以，當你要切換路由模式，或者在 IE9 降級使用 hash 模式，無須作任何變動。 在 HTML5 history 模式下，router-link 會守衛點擊事件，讓瀏覽器不再重新加載頁面。 當你在 HTML5 history 模式下使用 base 選項之後，所有的 to 屬性都不需要寫 (基路徑) 了。 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;nav__left\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;Admin\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/cart\u0026#34;\u0026gt;Cart\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 看到上面的程式碼內容，聰明的你一定知道接著我們要建立三個頁面\nadmin 後台管理 購物車頁面 剛剛示範了怎麼在 /views/Home.vue 中引入 src/components/Home.vue\n但在這邊先簡單一點，直接在 /views/ 目錄下建立如同 src/components/Home.vue 內容的檔案\n這時候 /views/ 資料夾應該會長得像這樣\n這時候其實可以把剛剛的 Home.vue 搬移進 /views/ 中，我們原本的引用在這邊有點多此一舉了\n但是在搬移過後會發現瀏覽器提示我們發生了一些問題，原來是 Home.vue 找不到檔案，但是為什麼呢？\n我們不是在 vue-router 裡面指定路徑 \u0026lsquo;/‘ 要到 Home.vue 嗎？\n首先復原程式碼，來看看在哪裡使用到了 src/components/Home.vue？\n哈！原來是一開始我們創建新組建時候把 App.vue 裡面的初始頁面 import 設定成 Home\n這也就說明了為什麼在 admin 以及 Cart 頁面中 Home.vue 的內容還是陰魂不散\n在刪除 import 的內容之後一切就正常了\n新建立的頁面加入路由 接著把剛剛新建的頁面加入路由設定檔案 /src/router/index.js 中\nimport Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import Home from \u0026#39;@/views/Home.vue\u0026#39; import Admin from \u0026#39;@/views/Admin\u0026#39;; import Cart from \u0026#39;@/views/Cart\u0026#39;; Vue.use(Router) const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: Home }, { path: \u0026#39;/admin\u0026#39;, name: \u0026#39;Admin\u0026#39;, component: Admin }, { path: \u0026#39;/cart\u0026#39;, name: \u0026#39;Cart\u0026#39;, component: Cart, }, ] const router = new Router({ routes }) export default router 好像有些什麼東西怪怪的？為什麼可以用 @ 引用東西呢？代表什麼意思？\n在我深入研究後發這是一個 webpack 的設定\n存在於 \\node_modules\\@vue\\cli-service\\lib\\config\\base.js\n進入檔案之後可以發現有設定了一個 alias set('@', api.resolve('src')) 這代表告訴了 vue\n看到路徑用 @ 開頭的，就從 src 這個目錄開始操作\n這樣做可以大幅度的減少我們使用 ../ 這種作法造成目錄結構變換就專案大爆炸，或是為了存取深層的檔案，畫面被一堆點點斜線佔滿\n在完成了以上動作之後，打開瀏覽器預覽一下\n看來我們剛剛完成了一個簡單的基於 Vue 的多頁面網站了！\n嵌套路由 有點經驗的工程師就知道，路由絕對不是這麼簡單的\n當頁面少的時候可以全塞在一支檔案裡面，但當頁面開始多這樣就會顯得很亂，並且無法一眼看出彼此之間的階層關聯\n還好 vue-router 提供了嵌套路由的功能，讓我們可以組織化的管理相關聯的頁面\n在後台頁面中會使用到很多操作的頁面，例如新增、修改商品，下面就藉由嵌套路由的方法來管理這些路由\n在引入的地方加入我們之後要增加的頁面，這邊只是先聲明，之後會一步一步的完成頁面\n// Admin Components import Index from \u0026#39;@/views/admin/Index\u0026#39; import New from \u0026#39;@/views/admin/New\u0026#39; import Products from \u0026#39;@/views/admin/Products\u0026#39; import Edit from \u0026#39;@/views/admin/Edit\u0026#39; 路由常數中加入嵌套路由，會發現 Admin 下有四個組件（component）\n而嵌套路由會為相關連的子路由設置一個入口頁面\n然後把這些頁面都放到 children 定義中的陣列中\n{ path: \u0026#39;/admin\u0026#39;, name: \u0026#39;Admin\u0026#39;, component: Index, children: [ { path: \u0026#39;\u0026#39;, name: \u0026#39;Products\u0026#39;, component: Products, }, { path: \u0026#39;new\u0026#39;, name: \u0026#39;New\u0026#39;, component: New, }, { path: \u0026#39;edit/:id\u0026#39;, name: \u0026#39;Edit\u0026#39;, component: Edit, }, ] }, 接著回到 /src/views/admin 建立\nIndex.vue Edit.vue New.vue Products.vue Index.vue Index 是我們上面提到的入口組件，也就是渲染 path = /admin 的基礎組件\n其餘的組件藉由 children 陣列宣告為嵌套的子路由。在子路由內的路由，前端都必須加上父層的路徑\n而在上方的定義中，我們把 /admin/ 的渲染子組件定義給了 Products\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;admin-new\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-3 col-md-3 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;admin-menu\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;View Products\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/new\u0026#34;\u0026gt;New Products\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 是用來渲染子路由的組件，比如說我們進入了 admin/new\n那麼 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 內部會被替換成 New.vue 組件的內容\n因為我們在上面路由定義中定義 \u0026lsquo;/new\u0026rsquo; 的路由渲染組件是 New.vue\nEdit.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit/{{$route.params.id}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Edit 這個路由在剛剛路由定義的時候有點不一樣，他的路徑是 edit/:id 這種寫法被稱作動態路由\n:id 會接收任意的內容作為一個參數傳入。例如我們進入 /admin/edit/banana 頁面\n那麼就可以在 Edit.vue 這個組件上使用\n{{$route.params.id}} 來呼叫到 :id 接收到的值，在上面的例子中就是「banana」\nNew.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/New\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Products.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 建立完成之後就完成了嵌套路由的應用\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202007-express-vue-build-ecommerce-02-vue-router/"
  },{
    "title": "[Express+Vue 搭建電商網站] 01- 初始設定",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 初始設定",
    "body": "本篇將使用 vue-ui 建立專案，並且安裝 vue-router\n安裝所需要的環境 在這個練習中我們首先需要的是安裝 npm 以及node\n這部分教學太多了，總之就先去裝起來吧！裝好後使用\nnpm -v # 確定安裝結果 node -v 接著要安裝我們前端所要使用的 vue\nnpm install -g vue-cli 安裝完成後在 terminal 確認安裝結果\nvue --version 新建 vue 專案 這次嘗試使用 Vue-cli 新出的 vue ui 來建立專案，在終端機輸入\nvue ui 就可以起動，根據提示我們開啟 vue-ui 的畫面 按下新增之後選擇指定的位置，根據畫面上提示來建立新專案\n接著就是等待他執行完成，在終端機進到剛剛建立專案的資料夾下會發現一個 vue 專案已經被建立\n根據 README 的說明執行以下指令後，可以打開 http://localhost:8080/ 來預覽執行結果\nnpm install npm run serve 安裝 vue-router 接著還要安裝一個我們會用上的東西：vue-router 可以選擇下指令，或是同樣的使用 vue-ui 來完成，既然剛剛使用 vue-ui 建立專案，這邊繼續使用 vue-ui 安裝 vue-router\n打開 vue-ui 頁面，最上方搜尋欄的左邊看「新增 vue-router」給他按下去就會開始安裝了 安裝好之後可以進入 main.js 查看，友善的自動安裝已經幫我們引入了呢！\n如此就完成了我們前端 vue 專案的初始設定\n專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce ",
    "ref": "/blog/202006-express-vue-build-ecommerce-01-basic-settings/"
  },{
    "title": "About",
    "date": "",
    "description": "關於我",
    "body": "寫 PHP 入門，寫過原生 PHP、CodeIgniter、WordPress、Laravel\n對前端稍有涉獵，在容器技術方面也是略懂\n目前轉戰 Golang 進行開發，同時學習 AWS 相關服務\n技術方面就東摸摸西摸摸，偶爾寫點小玩具\n歡迎透過 LinkedIn 和我交流\n平常興趣是看 Vtuber\n看 Vtuber 前對日本完全不認識也沒興趣\n現在變成一年必須去一次日本的體質\n",
    "ref": "/about/"
  }]
