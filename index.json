[{
    "title": "[A Tour of Go 學習筆記] 03 流程控制",
    "date": "",
    "description": "使用官方教學瞭解 Go 語言流程控制",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go  來認識基本的 Golang 使用\n這篇是流程控制相關的筆記，說明一些 if else for switch 還有 defer\nfor Go 只有一種迴圈：for\n組成結構是：\n 初始值：在第一次迭代之前執行 執行條件：在每次迭代前求值 更新語句：在每次迭代結束時執行  初始值通常是一個簡短變數聲明，該變數只作用於for迴圈內\n一旦執行條件判斷結果為false則迴圈就會被停止\n底下是一個基本的迴圈\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } fmt.Println(sum) } /* \u0026gt;\u0026gt;\u0026gt; 45 */ 初始值和更新語句是可以省略的\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 1 for ; sum \u0026lt; 1000; { sum += sum } fmt.Println(sum) } /* \u0026gt;\u0026gt;\u0026gt; 1024 */ 甚至你可以連分號都省略\n有沒有覺得很眼熟？這就是在 go 語言中實踐while迴圈的方式\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 1 for sum \u0026lt; 1000 { sum += sum } fmt.Println(sum) } /* \u0026gt;\u0026gt;\u0026gt; 1024 */ 如果想要寫出無窮迴圈，只要省略條件判斷迴圈就不會結束\n如此就可以很簡單寫出無限迴圈\npackage main func main() { for { } } if package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func sqrt(x float64) string { if x \u0026lt; 0 { return sqrt(-x) + \u0026#34;i\u0026#34; } return fmt.Sprint(math.Sqrt(x)) } func main() { fmt.Println(sqrt(2), sqrt(-4)) } /* \u0026gt;\u0026gt;\u0026gt; 1.4142135623730951 2i */ 簡短語句 就跟for一樣，if也有簡短的寫法\n可以在條件判斷式之前執行一個簡單的操作\n可以參考底下範例\n要注意的是變數v的作用域只存在if內\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } // 這裡就不能使用 v 了 \treturn lim } func main() { fmt.Println( pow(3, 2, 10), pow(3, 3, 20), ) } /* \u0026gt;\u0026gt;\u0026gt; 9 20 */ else 在if中聲明的變數也可以在對應的else範圍內被使用\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } else { fmt.Printf(\u0026#34;%g \u0026gt;= %g\\n\u0026#34;, v, lim) } // can\u0026#39;t use v here, though \treturn lim } func main() { fmt.Println( pow(3, 2, 10), pow(3, 3, 20), ) } /* \u0026gt;\u0026gt;\u0026gt; 27 \u0026gt;= 20 \u0026gt;\u0026gt;\u0026gt; 9 20 */ switch 和其他語言不同的點是，go 語言中的 switch 不需要break聲明\n只會執行對應的 case，而其他語言會繼續執行後續的所有 case\n在最後可以藉由default定義所有條件都不符合的預設情況\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { fmt.Print(\u0026#34;Go runs on \u0026#34;) switch os := runtime.GOOS; os { case \u0026#34;darwin\u0026#34;: fmt.Println(\u0026#34;OS X.\u0026#34;) case \u0026#34;linux\u0026#34;: fmt.Println(\u0026#34;Linux.\u0026#34;) default: // freebsd, openbsd, \t// plan9, windows... \tfmt.Printf(\u0026#34;%s.\\n\u0026#34;, os) } } /* \u0026gt;\u0026gt;\u0026gt; Go runs on Linux. */ case中不一定要是常數或是整數，甚至可以在裡面執行計算\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { fmt.Println(\u0026#34;When\u0026#39;s Saturday?\u0026#34;) today := time.Now().Weekday() switch time.Saturday { case today + 0: fmt.Println(\u0026#34;Today.\u0026#34;) case today + 1: fmt.Println(\u0026#34;Tomorrow.\u0026#34;) case today + 2: fmt.Println(\u0026#34;In two days.\u0026#34;) default: fmt.Println(\u0026#34;Too far away.\u0026#34;) } } /* \u0026gt;\u0026gt;\u0026gt; When\u0026#39;s Saturday? \u0026gt;\u0026gt;\u0026gt; Too far away. */ 不設定條件的 switch 就等同於switch true，可以把很長的 if-then-else 變比較好閱讀\n就由上到下比對 case 內條件何者首先為真，就執行內容\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;Good morning!\u0026#34;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026#34;Good afternoon.\u0026#34;) default: fmt.Println(\u0026#34;Good evening.\u0026#34;) } } /* \u0026gt;\u0026gt;\u0026gt; Good evening. */ defer 會將函數延遲到整個方法結束後執行\n但是參數的值會先傳入，等到外層函數執行完成後才會被執行\npackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) } /* \u0026gt;\u0026gt;\u0026gt; hello \u0026gt;\u0026gt;\u0026gt; world */ Stacking defers 如果在迴圈中使用 defer 會發生什麼事情呢？\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;counting\u0026#34;) for i := 0; i \u0026lt; 10; i++ { defer fmt.Println(i) } fmt.Println(\u0026#34;done\u0026#34;) } /* counting done 9 8 7 6 5 4 3 2 1 0 */ 首先可以先判斷迴圈外的兩個Println會先被執行，這很好理解\n接著進入迴圈，從 0 一路執行到 9，並且將印出當前數字送進defer推遲執行\n而實際印出的順序是從 9 印到 0，所以可以推斷defer是一種堆疊\n當多個defer同時存在，則會遵守後進先出(LIFO)來執行\n",
    "ref": "/blog/202111-a-tour-of-go-03-flow-control-statements/"
  },{
    "title": "[A Tour of Go 學習筆記] 02 變數與型別",
    "date": "",
    "description": "使用官方教學瞭解 Go 語言變數與型別",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go  來認識基本的 Golang 使用\n這篇是變數與型別的筆記\n變數 在 Go 語言中使用var來定義變數，並且和函數的參數列表一樣將型別定義在最後\nvar 聲明可以出現在 package 或是 function 的作用域內\npackage main import \u0026#34;fmt\u0026#34; var c, python, java bool func main() { var i int fmt.Println(i, c, python, java) } /* \u0026gt;\u0026gt;\u0026gt; 0 false false false */ 變數預設值 在聲明變數的時後可以定義一個初始值\n如果有定義初始值，在聲明的時候可以省略類型\nGo 會根據初始值來推斷變數的型別，這點十分聰明！\npackage main import \u0026#34;fmt\u0026#34; // 主動定義變數型別 var i, j int = 1, 2 func main() { // 省略型別，透過預設值 \tvar c, python, java = true, false, \u0026#34;no!\u0026#34; fmt.Println(i, j, c, python, java) } /* \u0026gt;\u0026gt;\u0026gt; 1 2 true false no! */ 短變數聲明 在函數內可以使用:=來代替使用var聲明變數\n在函數外部，每個語句都以關鍵字(var、func 等)開頭，不可使用:=\npackage main import \u0026#34;fmt\u0026#34; func main() { var i, j int = 1, 2 k := 3 c, python, java := true, false, \u0026#34;no!\u0026#34; fmt.Println(i, j, k, c, python, java) } /* \u0026gt;\u0026gt;\u0026gt; 1 2 true false no! */ 基本型別 Go 的基本型別有\nbool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8  rune // alias for int32  // represents a Unicode code point  float32 float64 complex64 complex128 一般來說int、uint和uintptr的長度和系統位元數一樣\n在 32 位元系統中就是 32 位元；在 64 位元系統中就是 64 位元\n當你需要整數的時候直接使用int就好\n除非有明確的理由，否則不應該去限制長度\n可以使用fmt.Printf套件來印出變數的格式化輸出內容，包含型別%T和值%v\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/cmplx\u0026#34; ) var ( ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) func main() { fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, ToBe, ToBe) fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, MaxInt, MaxInt) fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, z, z) } /* \u0026gt;\u0026gt;\u0026gt; Type: bool Value: false \u0026gt;\u0026gt;\u0026gt; Type: uint64 Value: 18446744073709551615 \u0026gt;\u0026gt;\u0026gt; Type: complex128 Value: (2+3i) */ Zero values 如果在聲明變數的時候沒有給定預設值\n那就會被自動賦予 Zero value\n不同型別的 Zero value 分別是\n 數值型別：0 布林型別：false 字串型別：\u0026quot;\u0026quot;(空字串)  型別轉換 使用T(v)的形式來將v型別轉換成T\n例如：\nvar i int = 42 var f float64 = float64(i) var u uint = uint(f) 或是可以使用更簡短的表達方式：\ni := 42 f := float64(i) u := uint(f) 常數  和變數的宣告方式很像，只是改為使用const 內容可以是字元、字串、布林、或數值資料 不能使用:=聲明  數值常數(Numeric constants)  一種高精度的數值 根據上下文使用來決定他的數值型別  import \u0026#34;fmt\u0026#34; const ( // 透過將 1 往左移動 100 位數來創造一個很大的數字（二進制中 1 後面接了 100 個 0）  Big = 1 \u0026lt;\u0026lt; 100 // 再往左移 99 位元，變成二進制的「10」也就是十進制的 2  Small = Big \u0026gt;\u0026gt; 99 ) func needInt(x int) int { return x*10 + 1 } func needFloat(x float64) float64 { return x * 0.1 } func main() { fmt.Println(needInt(Small)) fmt.Println(needFloat(Small)) fmt.Println(needFloat(Big)) } /* \u0026gt;\u0026gt;\u0026gt; 21 \u0026gt;\u0026gt;\u0026gt; 0.2 \u0026gt;\u0026gt;\u0026gt; 1.2676506002282295e+29 */ 這時候如果印出needInt(Big)會發生什麼事情呢？\n constant 1267650600228229401496703205376 overflows int\n 原來是因為我們所使用的系統中，最長的 int 就是 64-bit(有時候會更少)\n而我們定義的數值常數Big是一個 100 位元的正數，所以就造成了 overflow\n",
    "ref": "/blog/202111-a-tour-of-go-02-variables-and-types/"
  },{
    "title": "[A Tour of Go 學習筆記] 01 Packages 和 Functions",
    "date": "",
    "description": "使用官方教學瞭解 Go 語言基本套件包和函數的基礎",
    "body": "初入 Golang 的世界，首先我們使用官方教學：A Tour of Go  來認識基本的 Golang 使用\n本篇包含基本套件包和函數的基礎\nHello World 第一個就是跑不掉的Hello World\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello World\u0026#34;) } Packages 每個 Go 語言程式都是由 packages 組成\n程式會從 package main開始執行\nimport 底下範例中，引入了fmt和math/rand兩個套件包\n按照慣例 package 的名稱與導入路徑的最後一個元素相同\n例如math/rand中的方法皆以package rand開始\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { fmt.Println(\u0026#34;My favorite number is\u0026#34;, rand.Intn(10)) } 除了將要引入的套件寫在import括弧內的「分組導入」\n還有另一種導入方式是寫成多行的 import，但是分組導入是比較好的做法\npackage main import \u0026#34;fmt\u0026#34; import \u0026#34;math\u0026#34; func main() { fmt.Printf(\u0026#34;Now you have %g problems.\\n\u0026#34;, math.Sqrt(7)) } exported name 在 Go 中如果是以大寫字母開頭，則代表他是被導出的、可以在外部使用的\n例如：Pizza就是一個 exported name，而在math package 裡的Pi也一樣\n而pizza和pi就不是一個 exported name，因為不是使用大寫開頭\n當在使用 package 的時候，你只能呼叫 exported name 的內容\n無法從外部使用任何非導出的內容！\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { fmt.Println(math.Pi) } Functions 和其他語言一樣，一個函數可以不傳入參數或傳入多個參數\n範例中的add函數就接收了兩個int型別的參數\n要注意的是型別是定義在參數「後面」\npackage main import \u0026#34;fmt\u0026#34; func add(x int, y int) int { return x + y } func main() { fmt.Println(add(42, 13)) } /* \u0026gt;\u0026gt;\u0026gt; 55 */ 如果是傳入連續多個同樣型別的參數，可以忽略前面幾個參數的型別宣告\n只在最後一個後宣告，把x int, y int換成x, y int\npackage main import \u0026#34;fmt\u0026#34; func add(x, y int) int { return x + y } func main() { fmt.Println(add(42, 13)) } /* \u0026gt;\u0026gt;\u0026gt; 55 */ 回傳多個值 一個函數可以返回任意數量的結果\npackage main import \u0026#34;fmt\u0026#34; func swap(x, y string) (string, string) { return y, x } func main() { a, b := swap(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) fmt.Println(a, b) } /* \u0026gt;\u0026gt;\u0026gt; world hello */ 也可以對回傳值進行命名\n在函數的最上方將回傳值命名後，會被視為函數內的變數\n不帶任何參數的return會回傳已經命名好的回傳值，也就是直接返回(\u0026ldquo;naked\u0026rdquo; return)\n回傳值命名應具有意義，可以做為文件使用\nNaked return 只應該被用在簡短的函數中，因為在比較長的函數中這麼做會影響程式可讀性\npackage main import \u0026#34;fmt\u0026#34; func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } func main() { fmt.Println(split(19)) } /* \u0026gt;\u0026gt;\u0026gt; 4 5 */ ",
    "ref": "/blog/202111-a-tour-of-go-01-packages-and-functions/"
  },{
    "title": "[Git 教學] 設定本機全域 gitignore",
    "date": "",
    "description": "不要再把編輯器設定檔上傳！我真的不想知道你用什麼編輯器",
    "body": "在開發專案時，你會不會把編輯器自動產生的設定檔加入 .gitignore 裡呢？\n為什麼要把你的個人的環境設定加到專案中呢？\n例如你是用 PhpStorm，就會生出.idea這個資料夾：What is the .idea folder?  如果是用蘋果系統就會有.DS_Store：wiki .DS_Store  個人開發的時候很順手加進.gitignore很方便，乾淨又衛生\n但是當你參與的是多人專案這件事就會變得不合理\n因為一般會加入.gitignore排除在版本控制之外的是一些專案設定檔、金鑰、渲染出來的內容等\n所以把idea和.DS_Store加入到 gitignore 中並不合理，畢竟不是每個人都會需要忽略這些檔案\n其實我們可以在本機的 git 設定檔進行設定，畢竟你的這台電腦不會突然從 Mac 自己變成 Windows\n而在本機環境下將特定的檔案或路徑排除在版本控制，聽起來就合理多了\n操作步驟 1 建立全域 gitignore 用的設定檔 檔名可以隨意，使用終端機下指令\ntouch .gitignore_global 2 加入需要 ignore 的檔案 像 .gitignore 一樣作法，也可以手動開啟檔案編輯\necho /.idea \u0026gt;\u0026gt; .gitignore_global 3 加入設定檔到 .gitconfig 裡面 可以手動修改，也可以使用底下的指令\ngit config --global core.excludesfile ~/.gitignore_global 4 檢查設定是否成功 當然最簡單就是打開專案，把.gitignore裡面對應的設定刪掉啦\n不過還是可以來看看我們剛剛究竟設定了些什麼\n可以使用指令查看或是直接開啟檔案，因為用指令看起來比較高端\n所以我們用指令查看試試\nvim .gitignore_global 可以看到我們想要忽略的檔案列表設定檔，可能有些是初始化 git 的時候就加入的\n只要確認我們剛剛加入的內容有寫入檔案就好\n*~ .DS_Store /.idea 接著查看 git 設定檔有沒有設定\nvim .gitconfig 可以看到在排除的設定檔中有指定給剛剛建立的忽略列表設定檔\n[core] excludesfile = {.gitignore_global 所在路徑} 如此一來就完成了這次的「本機全域 gitignore 設定」\n參考資料：git gitignore  ",
    "ref": "/blog/202111-git-global-gitignore/"
  },{
    "title": "[Discord 機器人] 02.擲骰機器人",
    "date": "",
    "description": "建立擲骰子用的 Discord 聊天機器人，使用 Python3",
    "body": "不知道大家知不知道 TTRPG 呢？\n比較有名的大概就是龍與地下城(D\u0026amp;D)吧\n之前看 hololive EN 在玩，就萌生了「來寫個擲骰子 Bot 玩看看好了」的想法\n需求討論  要可以擲多個骰子 骰子的面數要可以自訂 成功判定計算  指令格式\n!roll 5D10\u0026gt;8 這代表：擲 5 個 10 面骰，成功判定是點數大於等於 8\n程式碼 # 導入 Discord.py 套件 import discord # 導入隨機數套件 import random # 取得 Discord client 物件才能操作 client = discord.Client() # 調用 event 函式庫 @client.event # 當機器人完成啟動時在終端機顯示提示訊息 async def on_ready(): print(f\u0026#39;目前登入身份：{client.user}\u0026#39;) # 調用 event 函式庫 @client.event # 當有訊息時 async def on_message(message): # 排除機器人本身發出的訊息，避免機器人自問自答的無限迴圈 if message.author == client.user: return # 預設錯誤訊息 error = [] # 處理輸入文字 content = message.content.replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;).lower() # 如果是「!roll」開頭的訊息 if message.content.startswith(\u0026#39;!roll\u0026#39;): content = content.replace(\u0026#39;!roll\u0026#39;, \u0026#39;\u0026#39;) # 骰子數量計算 dice_cont = content.split(\u0026#39;d\u0026#39;)[0] try: dice_cont = int(dice_cont) except ValueError: error.append(\u0026#39;How many dice you roll must be an interger!\u0026#39;) # 骰子類型判斷 content = content.split(\u0026#39;d\u0026#39;)[1] dice_type = content.split(\u0026#39;\u0026gt;\u0026#39;)[0] try: dice_type = int(dice_type) except ValueError: error.append(\u0026#39;Dice type must be an interger!\u0026#39;) # 成功判斷 if \u0026#39;\u0026gt;\u0026#39; in content: success = content.split(\u0026#39;\u0026gt;\u0026#39;)[1] try: success = int(success) except ValueError: error.append(\u0026#39;Success condition must be an interger!\u0026#39;) else: success = 0 if len(error) == 0: success_count = 0 result_msg = \u0026#39;\u0026#39; # 擲骰子 results = [random.randint(1, dice_type) for _ in range(dice_cont)] for result in results: if success \u0026gt; 0 and result \u0026gt;= success: success_count += 1 result_msg += f\u0026#39;`{result}`, \u0026#39; await message.channel.send(result_msg) if success \u0026gt; 0: await message.channel.send(f\u0026#39;Success: `{success_count}`\u0026#39;) else: await message.channel.send(error) # TOKEN 在 Discord Developer 的「BOT」頁取得 client.run(\u0026#39;\u0026#39;) 程式說明 基本的discord.py使用方法之前寫過就不寫了\n針對邏輯的部份做說明\n輸入訊息偵測 首先透過\nmessage.content.startswith(\u0026#39;!roll\u0026#39;) 只對!roll開頭的訊息做反應\n為了讓使用者不管輸入大小寫或是有沒有空格都可使用\n所以透過\nmessage.content.replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;).lower() 去除空白和全部轉小寫\n如此一來，使用者不論輸入\n !Roll 5 D10 !roll5d10  後續程式都是以!roll5d10做處理\n骰子數量計算 根據輸入訊息的格式，在!roll後面、d前面的「數字」代表骰子數量\n使用\ncontent.replace(\u0026#39;!roll\u0026#39;, \u0026#39;\u0026#39;) 去除字串中的!roll，因為這只是用來觸發機器人，不會影響擲骰子結果\n使用\ncontent.split(\u0026#39;d\u0026#39;)[0] 將字串從d切分，取得列表第一個值，這就是骰子數量\n使用強制轉型判斷取得的值是不是數字？如果不是則轉型出錯會被try except捕獲\n若是被捕獲了，就新增錯誤訊息字串\n骰子類型判斷 和剛剛的數量計算很像，只是這次我們抓取的邏輯是介於d後，\u0026gt;符號前\n如果沒有對應的\u0026gt;符號，則不會分切回傳整個內容\n再藉由跟數量計算一樣的強制轉型判斷取得的類型是否是數字\n若是錯誤，一樣新增錯誤訊息\n成功判斷 因為我們允許使用者在使用指令的時候不輸入成功判斷條件\n所以透過'\u0026gt;' in content:來判斷使用者是否有輸入判斷條件\n如果有輸入的話條件會在\u0026gt;後面，一樣取得值之後判斷是否是數字\n擲骰 我們需要的參數都已經取得了，接下來就是根據條件擲骰並回傳\n首先先檢查前面的錯誤訊息是不是有被建立，如果有代表不該擲骰！\n這時候就直接輸出錯誤訊息到 Discord\n如果錯誤訊息為空，就透過\nresults = [random.randint(1, dice_type) for _ in range(dice_cont)] 取得指定數量的隨機亂數執行結果，用這種方法寫和寫迴圈是一樣的！\n接著遍歷所有結果，整理成輸出到 Discord 想要的格式\n並且如果使用者有輸入擲骰成功的條件，也在這邊計算成功次數\n最後就是輸出擲骰結果和成功次數到 Discord，結果如下\n如此就完成了擲骰機器人的需求\n改進方向 儘管機器人的需求是完成了，但是還有很多可以優化的部分\n函式切分 現在太多邏輯全部寫在一起，應該拆成獨立函數來呼叫\n這樣不論是寫測試或是未來要調整都會比較容易\n輸入判斷邏輯優化 切分邏輯過於簡單，萬一使用者輸入了我們沒想到的內容\n例如!roll6D10d5，雖然程式執行起來會跟!roll6D10一樣\n但是使用者不應該多最後那個d5，這部分該如何處理也是一個可以改進的目標\n",
    "ref": "/blog/202110-make-discord-chatbot-02-roll-dice-bot/"
  },{
    "title": "[Discord 機器人] 01.建立基本機器人",
    "date": "",
    "description": "使用 Python3 建立基本的 Discord 聊天機器人",
    "body": "閒閒沒事，來寫點沒寫過的東西\n最近都在 Discord 活動，就決定寫 Discord ChatBot 啦\n新增 Discord Application 到 Discord Developers Applications  登入 Discord 帳號\n按下New Application命名之後按下Create，名字之後可以改\n左邊Bot進入後點選Add Bot\n點選左邊OAuth2頁籤\n SCOPES中點選bot Bot Permissions 選擇 Administrator  下面就是機器人的邀請連結，可以將機器人邀請到自己的群\n安裝 pip 及 Discord .py 使用指令安裝Discord.py套件\npython3 -m pip install -U discord.py 機器人程式碼 剛剛已經建立機器人，並且把機器人加到自己的群組裡\n下一步就是要來啟動機器人，讓他可以開始做事\n作為範例，我們先寫一個最簡單的機器人試試看運行結果\nroll_dice.py\n# 導入 Discord.py 套件 import discord # 取得 Discord client 物件才能操作 client = discord.Client() # 調用 event 函式庫 @client.event # 當機器人完成啟動時在終端機顯示提示訊息 async def on_ready(): print(f\u0026#39;目前登入身份：{client.user}\u0026#39;) # 調用 event 函式庫 @client.event # 當有訊息時 async def on_message(message): # 排除機器人本身發出的訊息，避免機器人自問自答的無限迴圈 if message.author == client.user: return # 如果我們說了「誰是機器人」，機器人就會回「誰叫我？」 if message.content == \u0026#39;誰是機器人\u0026#39;: await message.channel.send(\u0026#39;誰叫我？\u0026#39;) client.run(\u0026#39;MY APP TOKEN\u0026#39;) 程式說明都寫在範例中了，唯一要解釋的就是 token 要去哪裡拿？\n廢話不多說，上圖！\nTOKEN 在上面 Discord Developer 的BOT頁面中取得\n他不會直接顯示在畫面上，就按Copy就好了，如果堅持要看的話就按下Click to Reveal Token就會顯示\n如果覺得 TOKEN 外洩可以使用 Regenerate 重新產生\n啟動機器人 開啟你的終端機，執行剛剛的 python 檔案\npython roll_dice.py 接著測試指令是不是可以觸發機器人\n看來成功被呼叫了呢！\n",
    "ref": "/blog/202110-make-discord-chatbot-01-set-up/"
  },{
    "title": "[LeetCode] #404 Sum of Left Leaves (Easy)",
    "date": "",
    "description": "LeetCode 第 404 題 Sum of Left Leaves，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Sum of Left Leaves，屬於 Easy\n原始題目 Given the root of a binary tree, return the sum of all left leaves.\nExample 1:\nInput: root = [3,9,20,null,null,15,7] Output: 24 Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively. Example 2:\nInput: root = [1] Output: 0 Constraints:\n The number of nodes in the tree is in the range [1, 1000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000  題目分析 判斷一個二元樹的左子葉總和\n把每個節點送進遞迴函數裡面取得該節點的左節點，並且送進同一個函數取得更深入的左節點\n如果傳入節點的左節點不為空，且該節點的左節點沒有更深入的左節點\n而且該節點的左節點的右節點為空，則找到了一個左子葉\n判斷式長得像：\nif (node-\u0026gt;left != NULL \u0026amp;\u0026amp; node-\u0026gt;left-\u0026gt;left == NULL \u0026amp;\u0026amp; node-\u0026gt;left-\u0026gt;right == NULL) { 找到左子葉 } 解題過程 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sumOfLeftLeaves(self, root: Optional[TreeNode]) -\u0026gt; int: if not root: return 0 left_left_leaves_sum = self.sumOfLeftLeaves(root.left) right_left_leaves_sum = self.sumOfLeftLeaves(root.right) cur_left_leaf_val = 0 if root.left and not root.left.left and not root.left.right: cur_left_leaf_val = root.left.val return cur_left_leaf_val + left_left_leaves_sum + right_left_leaves_sum 結果 ",
    "ref": "/blog/202110-leetcode-no404-sum-of-left-leaves/"
  },{
    "title": "[LeetCode] #1013 Partition Array Into Three Parts With Equal Sum (Easy)",
    "date": "",
    "description": "LeetCode 第 1013 題 Partition Array Into Three Parts With Equal Sum，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Partition Array Into Three Parts With Equal Sum，屬於 Easy\n原始題目 Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 \u0026lt; j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])\nExample 1:\nInput: arr = [0,2,1,-6,6,-7,9,1,2,0,1] Output: true Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 Example 2:\nInput: arr = [0,2,1,-6,6,7,9,-1,2,0,1] Output: false Example 3:\nInput: arr = [3,3,6,5,-2,2,5,1,-9,4] Output: true Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 Constraints:\n 3 \u0026lt;= arr.length \u0026lt;= 5 * 104 -104 \u0026lt;= arr[i] \u0026lt;= 104  題目分析 一個陣列，當裡面的內容相加可以分成完全相等的三個部分，並且內容都不是空值就會傳 true\n否則回傳 false\n解題過程 可以理解成三等分的每一份恰好等於陣列總和的三分之一，所以不能整除三的就必定是 false\n從陣列開頭累加，當等於三分之一的總和，則切為一份\n繼續計算下一份的累加值，當累加值等於三分之二的總和時，剩下的值總和必然是另外的三分之一，所以可以回傳 true\n若累加沒有達到三分之二則回傳 false\nclass Solution: def canThreePartsEqualSum(self, arr: List[int]) -\u0026gt; bool: s = sum(arr) if s % 3 != 0: return False target = s // 3 n, i, cur = len(arr), 0, 0 while i \u0026lt; n: cur += arr[i] if cur == target: break i += 1 if cur != target: return False j = i + 1 while j + 1 \u0026lt; n: cur += arr[j] if cur == target * 2: return True j += 1 return False 結果 ",
    "ref": "/blog/202110-leetcode-no1013-partition-array-into-three-parts-with-equal-sum/"
  },{
    "title": "[LeetCode] #455 Assign Cookies (Easy)",
    "date": "",
    "description": "LeetCode 第 455 題 Assign Cookies，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Assign Cookies，屬於 Easy\n原始題目 Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] \u0026gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\nExample 1:\nInput: g = [1,2,3], s = [1,1] Output: 1 Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1. Example 2:\nInput: g = [1,2], s = [1,2,3] Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. Constraints:\n 1 \u0026lt;= g.length \u0026lt;= 3 * 104 0 \u0026lt;= s.length \u0026lt;= 3 * 104 1 \u0026lt;= g[i], s[j] \u0026lt;= 231 - 1  題目分析 有一串小孩的胃口，和另一串餅乾數量。要滿足最多小孩的胃口\n解題過程 看到這種滿足ＯＯ、讓最多ＸＸ怎樣怎樣的題目，馬上反應使用貪婪演算法\n 排序胃口跟餅乾 餅乾從最小到最大，依序餵飽小孩 餵飽後計數器 +1 如果餅乾無法滿足指定的小孩，則跳出迴圈 回傳可滿足的小孩數量  class Solution: def findContentChildren(self, g: List[int], s: List[int]) -\u0026gt; int: g.sort() s.sort() # 可以餵飽的小孩數量 res = 0 # 遍歷所有餅乾 for i in range(len(s)): # 如果可餵飽的數量小於小孩總數，且餅乾大小大於下一個小孩的胃口。則餵飽數量 +1 if res \u0026lt; len(g) and s[i] \u0026gt;= g[res]: res += 1 else: break return res 結果 ",
    "ref": "/blog/202110-leetcode-no455-assign-cookies/"
  },{
    "title": "[LeetCode] #150 Evaluate Reverse Polish Notation (Medium)",
    "date": "",
    "description": "LeetCode 第 150 題 Evaluate Reverse Polish Notation，難度 Medium",
    "body": "用 Python3 解 LeetCode 系列，Evaluate Reverse Polish Notation，屬於 Medium\n原始題目 Evaluate the value of an arithmetic expression in Reverse Polish Notation  .\nValid operators are +, -, *, and /. Each operand may be an integer or another expression.\nNote that division between two integers should truncate toward zero.\nIt is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.\nExample 1:\nInput: tokens = [\u0026#34;2\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;*\u0026#34;] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2:\nInput: tokens = [\u0026#34;4\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;+\u0026#34;] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3:\nInput: tokens = [\u0026#34;10\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;-11\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;/\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;+\u0026#34;] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 題目分析 這題是使用：逆波蘭表示法  ，兩個值之間的運算符號是表示在兩個值後面\n和一般日常使用寫在中間的表示方式不太一樣 ，遇到運算符才把前面「兩個」數字做運算\n解題過程  遍歷傳入的 Input，如果值不是運算符代表他是要運算的數字。轉換成 int 存進堆疊裡 遇到運算符號的時候，把堆疊最上面的兩個值取出進行運算( python 3.8 沒有 switch case 可以用)  class Solution: def evalRPN(self, tokens: List[str]) -\u0026gt; int: stack = [] for value in tokens: # 不是運算符就把值轉成 int 存進 stack 裡 if value not in \u0026#34;+-*/\u0026#34;: stack.append(int(value)) # 防止第二的值就是運算符的防呆 elif len(stack) \u0026gt; 1: # 遇到運算符的時候，取得堆疊最上面兩個值進行運算 num2 = stack.pop() num1 = stack.pop() if value == \u0026#39;+\u0026#39;: stack.append(num1 + num2) elif value == \u0026#39;-\u0026#39;: stack.append(num1 - num2) elif value == \u0026#39;*\u0026#39;: stack.append(num1 * num2) elif value == \u0026#39;/\u0026#39;: # 題目要求除法取整數就好 stack.append(int(num1 / num2)) return stack[-1] 結果 ",
    "ref": "/blog/202109-leetcode-no150-evaluate-reverse-polish-notation/"
  },{
    "title": "[LeetCode] #155 Min Stack (Easy)",
    "date": "",
    "description": "LeetCode 第 155 題 Min Stack，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Min Stack，屬於 Easy\n原始題目 Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\n MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack.  Example 1:\nInput [\u0026#34;MinStack\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;getMin\u0026#34;,\u0026#34;pop\u0026#34;,\u0026#34;top\u0026#34;,\u0026#34;getMin\u0026#34;] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 題目分析 設計具有 push, pop, top 操作，並能在常數時間 O(n) 內查詢到最小元素的堆疊\n解題過程  建立一個 list min_stack紀錄堆疊最小值 建立stack list 作為堆疊紀錄 push：把值放進堆疊後面，如果該值小於等於 min_stack 堆疊的最後一筆資料，則一併加入 min_stack 堆疊 pop：從 stack 移除最上面一筆值，如果該值等於 min_stack 最後一筆，一併從堆疊移除 top：取得堆疊最上面一個元素stack[-1] getMin：取得最小值，也就是 min_stack 的最後一個元素min_stack[-1]  class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -\u0026gt; None: self.stack.append(val) if not self.min_stack or val \u0026lt;= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -\u0026gt; None: if self.stack.pop() == self.min_stack[-1]: self.min_stack.pop() def top(self) -\u0026gt; int: return self.stack[-1] def getMin(self) -\u0026gt; int: return self.min_stack[-1] # Your MinStack object will be instantiated and called as such: # obj = MinStack() # obj.push(val) # obj.pop() # param_3 = obj.top() # param_4 = obj.getMin() 結果 ",
    "ref": "/blog/202109-leetcode-no155-min-stack/"
  },{
    "title": "[LeetCode] #66 Plus One (Easy)",
    "date": "",
    "description": "LeetCode 第 66 題 Plus One，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Plus One，屬於 Easy\n原始題目 You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0\u0026rsquo;s.\nIncrement the large integer by one and return the resulting array of digits.\nExample 1:\nInput: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124. Thus, the result should be [1,2,4]. Example 2:\nInput: digits = [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Incrementing by one gives 4321 + 1 = 4322. Thus, the result should be [4,3,2,2]. Example 3:\nInput: digits = [0] Output: [1] Explanation: The array represents the integer 0. Incrementing by one gives 0 + 1 = 1. Thus, the result should be [1]. Example 4:\nInput: digits = [9] Output: [1,0] Explanation: The array represents the integer 9. Incrementing by one gives 9 + 1 = 10. Thus, the result should be [1,0]. 題目分析  傳入一個純正整數的陣列 該陣列是一個大正整數，依照每個位數拆開 計算出該正整數 +1 的結果 把結果依照輸入的方式也輸出成陣列  解題過程  把輸入的陣列數字一個一個串成字串 字串轉換成數字，然後 +1 每個位元拆開做成新的 list 後回傳  class Solution: def plusOne(self, digits: List[int]) -\u0026gt; List[int]: number_string = \u0026#39;\u0026#39; number_new = [] # list 用字串串起來 for number in digits: number_string += str(number) # 字串轉數字，數字 +1 number_string = str(int(number_string) + 1) # 每一個位元拆開成新的 list for number in number_string: number_new.append(number) return number_new 結果 ",
    "ref": "/blog/202109-leetcode-no66-plus-one/"
  },{
    "title": "[LeetCode] #290 Word Pattern (Easy)",
    "date": "",
    "description": "LeetCode 第 290 題 Word Pattern，難度 Easy",
    "body": "用 Python3 解 LeetCode 系列，Word Pattern，屬於 Easy\n原始題目 Given a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.\nExample 1:\nInput: pattern = \u0026#34;abba\u0026#34;, s = \u0026#34;dog cat cat dog\u0026#34; Output: true Example 2: Input: pattern = \u0026#34;abba\u0026#34;, s = \u0026#34;dog cat cat fish\u0026#34; Output: false Example 3:\nInput: pattern = \u0026#34;aaaa\u0026#34;, s = \u0026#34;dog cat cat dog\u0026#34; Output: false Example 4:\nInput: pattern = \u0026#34;abba\u0026#34;, s = \u0026#34;dog dog dog dog\u0026#34; Output: false 題目分析  給你一個模式pattern和s pattern 裡的每個字母對應s一個單字，相同字母單字必須一樣 判斷s是否符合pattern  解題過程  長度判斷，如果pattern字母數量和s單字數量不同，一定就是 false mapping_dict的 key 是pattern的字母，值是同 index 的s內容 exist_check_dict的 key 是s的單字，值是pattern的字母 遍歷pattern所有值 檢查當前pattern字母為 key 的mapping_dict資料，和s中相同位置的單字有沒有一樣 檢查和當前pattern字母同 index 的 s 單字所對應的字母和exist_check_dict紀錄中的字母有沒有一樣  class Solution: def wordPattern(self, pattern: str, s: str) -\u0026gt; bool: # 長度判斷，如果不同長度一定就是 false words_list = s.split(\u0026#39; \u0026#39;) words_len = len(words_list) pattern_len = len(pattern) if words_len != pattern_len: return False mapping_dict = dict() exist_check_dict = dict() for index, val in enumerate(pattern): # 如果 pattern key 存在 if val in mapping_dict.keys(): # 檢查 pattern 字母代表的單字是否一致 if mapping_dict[val] != words_list[index]: return False else: # 檢查有沒有重複的單字在不同字母中 if words_list[index] in exist_check_dict: if exist_check_dict[words_list[index]] != val: return False else : mapping_dict[val] = words_list[index] exist_check_dict[words_list[index]] = val return True 結果 ",
    "ref": "/blog/202109-leetcode-no290-word-pattern/"
  },{
    "title": "使用 GrumPHP 做程式碼品質的守門員",
    "date": "",
    "description": "檢查你的程式有沒有怪味道，在你犯錯前就制止你。一生只督你一人",
    "body": "多人一起開發的環境下，Code Review 是一件非常重要的事情\n因為如果有人寫出一些不符合規則的程式，或是無法通過測試的程式時會造成專案出錯\n而人工檢查語法或是手動執行測試耗時費力 no fashion，這種事情應該讓程式自動做\n於是 GrumPHP 登場了\n什麼是 GrumPHP GrumPHP 是一個開源的 Composer 套件，藉由 git hook\n當有人變更程式並且 commit 的時候，GrumPHP 將根據設定好的 tasks 去檢查程式內容\n如果測試失敗，commit 會被中斷\n並且 GrumPHP 內建了一組常見的任務，可以用最少的客製設定使用 GrumPHP\n可以在官方文件中的 Tasks  頁面找到大部分你會用到的檢查任務\n以下我們就分別從安裝到加入四個常用的任務來介紹\n安裝 GrumPHP 一樣拿上次做一半的 LaraPeko 來做示範，以下說的「專案」指的都是這個套件包！\n首先進入專案目錄下執行\ncomposer require --dev phpro/grumphp 會跳出互動介面問你要不要建立設定檔grumphp.yml，然後給你一大堆選項\n可以先隨便選一個，或是直接跳過\n因為下一步要安裝的是yamllint，如果你在這邊選了 yamllint，下一步就沒事了\n可以在專案根目錄執行指令來測試是否可以執行檢查\nvendor/bin/grumphp run 若是執行\ncomposer install 可以看到提示GrumPHP is sniffing your commits!代表 GrumPHP 已經在嗅探我們的 commit 了\n加入檢查任務 這邊會逐步安裝並說明四個常用的基本檢查任務\n yamllint PHPLint Phpunit Phpcs  首先如果上一步沒建立grumphp.yml的話，在專案根目錄下建立檔案並建立內容\ngrumphp: tasks: { } 在官方 GitHub 上有一份範例的 grumphp.yml 設定檔\n而 Parameters 文件  有參數的詳細說明和與設值介紹\n在這邊為了減少設定上的步驟，我們都先用預設值就好\n1. yamllint 檢查你專案中的 yaml 檔結構合法性，如果有 drone 或是其他需要使用 yaml 格式檔案配置的設定檔\n根據文件中 YamlLint  我們不需要額外配置\n只需要在 tasks 列表中加入 yamllint 即可\ngrumphp: tasks: { yamllint: null, } 2. PHPLint 檢查語法錯誤，多一個逗點之類會讓 IDE 有紅字的syntax error\n照著官方文件的任務使用方法安裝：PHPLint  首先執行 composer 指令安裝依賴項目，因為這個檢查只有在測試環境需要被執行\n所以只在測試環境require-dev中安裝\ncomposer require --dev php-parallel-lint/php-parallel-lint 接著加入grumphp.yml中的任務\ngrumphp: tasks: { yamllint: null, phplint: ~, } 同樣的，在文件中有很多可以調整個規則\n可以依照個人使用調整，而這邊我們依然使用預設值就好\n3. Phpunit 指行指定路徑下的測試，如果失敗則視為任務失敗\n照著官方文件的任務說明安裝在測試環境中：Phpunit  composer require --dev phpunit/phpunit 而文件中有說明，你必須建立phpunit.xml作為任務的設定檔\n底下範例指定了測試檔案的資料夾目錄\n Unit：./tests/Unit Feature：./tests/Feature  如果缺少這個檔案，預設會是 null，執行下去會報錯\n如果你的對應資料夾沒建立，在執行檢查的時候也會視為錯誤，記得要在專案中建立對應資料夾\nphpunit.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;phpunit xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:noNamespaceSchemaLocation=\u0026#34;./vendor/phpunit/phpunit/phpunit.xsd\u0026#34; bootstrap=\u0026#34;vendor/autoload.php\u0026#34; colors=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;testsuites\u0026gt; \u0026lt;testsuite name=\u0026#34;Unit\u0026#34;\u0026gt; \u0026lt;directory suffix=\u0026#34;Test.php\u0026#34;\u0026gt;./tests/Unit\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; \u0026lt;testsuite name=\u0026#34;Feature\u0026#34;\u0026gt; \u0026lt;directory suffix=\u0026#34;Test.php\u0026#34;\u0026gt;./tests/Feature\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; \u0026lt;/testsuites\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;whitelist processUncoveredFilesFromWhitelist=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;directory suffix=\u0026#34;.php\u0026#34;\u0026gt;./app\u0026lt;/directory\u0026gt; \u0026lt;/whitelist\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;/phpunit\u0026gt; 來測試一下任務是否有執行上次套件包中的測試吧！\n因為配合 phpunit.xml 的設定，所以把上次寫在 tests 資料夾內的測試搬到 tests/unit 內\n執行指令vendor/bin/grumphp run可以看到通過的綠色的開心老頭\n若我們修改測試方法，讓測試無法通過\npublic function testGetAhoy() { $larapeko = new LaraPeko(); $this-\u0026gt;assertEquals(\u0026#39;ahoy\u0026#39;, \u0026#39;DD\u0026#39;); } 接著再一次執行指令便會看到一個生氣的紅色老頭，以及其錯誤訊息\n透過提示訊息，我們可以清楚的知道是哪個測試沒有通過\n4. Phpcs 這個任務，可以檢查提交的 PHP 內容是不是符合 PSR 規則  首先安裝相關套件，參考：Phpcs 任務文件  composer require --dev squizlabs/php_codesniffer 接著一樣是需要建立配置文件phpcs.xml來設定我們需要檢查的規則，這邊以基本的 PSR-12 為例\n可以看到我們設定了 PSR12 的檢查規則\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;ruleset name=\u0026#34;PSR12\u0026#34;\u0026gt; \u0026lt;description\u0026gt;The PSR12 coding standard.\u0026lt;/description\u0026gt; \u0026lt;rule ref=\u0026#34;PSR12\u0026#34;/\u0026gt; \u0026lt;file\u0026gt;app/\u0026lt;/file\u0026gt; \u0026lt;file\u0026gt;config/\u0026lt;/file\u0026gt; \u0026lt;file\u0026gt;routes/\u0026lt;/file\u0026gt; \u0026lt;exclude-pattern\u0026gt;public/index.php\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;server.php\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;laravel-nova-*\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;vendor\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;resources\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;database/\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;storage/\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;node_modules/\u0026lt;/exclude-pattern\u0026gt; \u0026lt;exclude-pattern\u0026gt;tests\u0026lt;/exclude-pattern\u0026gt; \u0026lt;/ruleset\u0026gt; 既然設定好了就執行看看吧\nvendor/bin/grumphp run 可以看到我們設定的測試都有通過了\n那如果有一些不符合 PSR12 規則的東西會發生什麼事情呢？\n為了測試，我們隨便找一段 PHP 程式，在分號後面再加一個分號\n這麼做並不會觸發先前安裝的 phplint 檢查，因為這不屬於語法錯誤，但這麼做不符合 PSR12 規則\n於是我們又看到了生氣的老頭，指出哪裡有問題\n自動監聽 以上都是我們手動執行套件的任務來測試程式碼的品質，好還要更好\n最好可以讓程式自動執行測試，也就是一開頭我們說過的在 commit 時自動觸發 GrumPHP 的 tasks\n這件事情想起來難，做起來倒是一點就通\n透過修改專案的composer.json我們可以加入指令，參考 composer 官方文件  我們可以透過加入scripts區塊，讓指令在 composer 執行過程中被執行\n在專案的composer.json中加入指令，在初始時就就開始嗅探\n\u0026#34;scripts\u0026#34;: { \u0026#34;post-install-cmd\u0026#34;: [ \u0026#34;@php ./vendor/bin/grumphp git:init\u0026#34; ] }, 這樣不論是在 CLI 執行git commit或是使用 GUI 操作，都可以在 commit 前觸發我們定義的 tasks\n如下圖就是使用 GUI 觸發 phpcs 這個任務的失敗狀態跳出的訊息\n",
    "ref": "/blog/202107-grumphp-a-php-code-quality-tool/"
  },{
    "title": "開發屬於自己的 Laravel 套件",
    "date": "",
    "description": "介紹如何在本機進行 Laravel 套件開發及撰寫測試，並在本機專案透過 composer 安裝自行開發的套件",
    "body": "目前的 Laravel 生態中有許多好用的套件包可以使用\n但要是找不到別人寫好的套件包，又或是必須建置公司共用的套件包怎麼辦呢？\n本篇就來在本機進行套件包開發，並且會在本機專案中使用 composer 進行安裝並測試\n有些文章會教你在既有的 Laravel 專案中建立 packages 資料夾，並在裡面進行開發\n但這不是一個好方法，試想你萬一有天把專案刪掉了，套件包的專案也被刪掉了\n並且這種做法不能測試使用 composer 安裝是否正常，所以本篇使用的是另一種方式\n1. 初始化套件專案 首先我們開一個資料夾，方便起見我們用 larapeko 作為範例\nmkdir larapeko 接著進到剛剛的 larapeko 資料夾中，執行指令初始化套件\ncd larapeko composer init 會經過一連串的問答協助你設定套件的基本資訊\n接著就會在資料夾內看到剛剛初始化的套件 composer.json 檔案\n{ \u0026#34;name\u0026#34;: \u0026#34;ray247k/larapeko\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A package for demo peko\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Ray\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;ray247k@gmail.com\u0026#34; } ], \u0026#34;minimum-stability\u0026#34;: \u0026#34;dev\u0026#34;, \u0026#34;require\u0026#34;: {} } 2. 撰寫套件程式 在 larapeko 資料夾中新建 src 資料夾，我們的套件程式碼主要都放在這\n建立一個名為 LaraPeko.php 的檔案，並設定所使用的 namespace\n為了後續示範，我先建立一個簡單的 function\n\u0026lt;?php # LaraPeko.php  namespace Ray247k\\LaraPeko; class LaraPeko { public function sayPeko() { echo \u0026#34;好油喔 peko\\n\u0026#34;; } } 3. ServiceProvider 在 src 目錄內建立剛剛檔案的 ServiceProvider，為了好識別，我們就命名為 LaraPekoServiceProvider.php\n透過 register 中的 singleton，會註冊一個叫做LaraPeko的類別，並回傳剛剛建立的 LaraPeko 物件\n\u0026lt;?php # LaraPekoServiceProvider.php  namespace Ray247k\\LaraPeko; use Illuminate\\Support\\ServiceProvider; class LaraPekoServiceProvider extends ServiceProvider { public function boot() { } // 註冊套件函式  public function register() { $this-\u0026gt;app-\u0026gt;singleton(\u0026#39;LaraPeko\u0026#39;, function ($app) { return new LaraPeko(); }); } } 4. Facade Facade  提供一個靜態的介面讓我們直接呼叫註冊過的類別\n在 src 目錄內建立剛剛檔案的 Facade，命名為 LaraPekoFacade.php 吧\n使用剛剛上面 ServiceProvider 註冊的LaraPeko類別作為 Laravel 的 Facade 物件\n\u0026lt;?php # LaraPekoFacade.php  namespace Ray247k\\LaraPeko; use Illuminate\\Support\\Facades\\Facade; class LaraPekoFacade extends Facade { protected static function getFacadeAccessor() { return \u0026#39;LaraPeko\u0026#39;; } } 5. 預設 config 以及使用方法 在使用套件的時候，有時候會想讓使用者可以透過設定檔設定參數\n這時候可以在套件目錄下建立config資料夾，並且在裡面加入 config 設定檔 lara_peko.php\n\u0026lt;?php # lara_peko.php  return [ \u0026#39;best_girl\u0026#39; =\u0026gt; \u0026#39;Yagoo\u0026#39;, ]; 建立好了之後，我們要編輯LaraPekoServiceProvider.php成底下內容\n\u0026lt;?php # LaraPekoServiceProvider.php  namespace Ray247k\\LaraPeko; use Illuminate\\Support\\ServiceProvider; class LaraPekoServiceProvider extends ServiceProvider { public function boot() { $source = realpath($raw = __DIR__.\u0026#39;/../config/lara_peko.php\u0026#39;) ?: $raw; $this-\u0026gt;publishes([ $source =\u0026gt; config_path(\u0026#39;lara_peko.php\u0026#39;), ]); } // 註冊套件函式  public function register() { $configPath = __DIR__ . \u0026#39;/../config/lara_peko.php\u0026#39;; $this-\u0026gt;mergeConfigFrom($configPath, \u0026#39;lara_peko\u0026#39;); $this-\u0026gt;app-\u0026gt;singleton(\u0026#39;LaraPeko\u0026#39;, function ($app) { return new LaraPeko(); }); } } 在boot()中使用publishes方法後，在引用套件的時候可以在專案內使用指令\nphp artisan vendor:publish 並根據跳出的互動視窗選擇套件對應數字輸入\n就可以的在專案目錄的 config 路徑下產生套件包的 config 範本對應的檔案\n如果如果你很確定自己要建立的是哪一個套件的 config 檔，也可以直接加上 provider 標籤\n指定要呼叫的是哪一個命名空間內的 provider 的 publishes 發布方法\nphp artisan vendor:publish --provider=\u0026#34;Ray247k\\LaraPeko\\LaraPekoServiceProvider\u0026#34; 而register()中則是將預設的 config 設定檔和新建立的設定檔合併\n如此一來，若使用者對專案設定檔做修改，會覆蓋掉預設的設定檔，達到客製化的目的\n清除 config 的快取 當 config 有變更，則需要使用指令清除專案內的設定檔快取\nphp artisan config:clear # 清除設定檔快取 php artisan cache:clear # 清除一般快取 使用 config 參數 若是要在程式中使用 config 設定，則可以使用 config() 方法呼叫\n回到LaraPeko.php，新建個方法getBestGirl取得設定檔中的best_girl參數內容\n\u0026lt;?php # LaraPeko.php  namespace Ray247k\\LaraPeko; class LaraPeko { public function sayPeko() { echo \u0026#34;好油喔 peko\\n\u0026#34;; } public function getBestGirl() { echo config(\u0026#39;lara_peko.best_girl\u0026#39;); } } 6. 套件包自動發現 Laravel 5.5 新增的功能，可以借由套件包的設定減少使用者安裝時候需要的步驟\n目的是在執行 composer install 之後，不需要手動編輯config/app.php 的providers和aliases陣列\n關鍵字：Package Auto-discovery、Laravel 擴充套件包自動發現\n作法：\n在套件包的 composer.json 裡面加入 autoload 和 extra 的內容\n因為整串貼有點太長，就只貼有新增的部分\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;Ray\\\\LaraPeko\\\\\u0026#34;: \u0026#34;src\u0026#34; } }, \u0026#34;extra\u0026#34;: { \u0026#34;laravel\u0026#34;: { \u0026#34;providers\u0026#34;: [ \u0026#34;Ray\\\\LaraPeko\\\\LaraPekoServiceProvider\u0026#34; ], \u0026#34;aliases\u0026#34;: { \u0026#34;LaraPeko\u0026#34;: \u0026#34;Ray\\\\LaraPeko\\\\LaraPekoFacade\u0026#34; } } } } 藉由 extra 中的 laravel 定義，會在陣列中的 providers 和 aliases 內各加入一筆資料進行相關註冊\n而 autoload 會使用 psr-4 的規則將指定命名空間指向我們套件程式所在的資料夾src\n7. 套件包相依套件 如果你的套件包相依於某個套件，例如常用的Guzzle\n那麼就在套件包的 composer.json 中加入 require 的項目如下\n{ \u0026#34;name\u0026#34;: \u0026#34;ray247k/larapeko\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A package for demo peko\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Ray\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;ray247k@gmail.com\u0026#34; } ], \u0026#34;minimum-stability\u0026#34;: \u0026#34;dev\u0026#34;, \u0026#34;require\u0026#34;: { \u0026#34;php\u0026#34;: \u0026#34;\u0026gt;=7.3\u0026#34;, \u0026#34;laravel/framework\u0026#34;: \u0026#34;5.5.*||^6.0|^7.0|^8.0\u0026#34;, \u0026#34;guzzlehttp/guzzle\u0026#34;: \u0026#34;^6.3\u0026#34; } } 我們除了 require guzzle 外，還 require 了 php 必須大於指定版本以及 Laravel\n8. 套件包測試 建立測試用專案 經過上面流程，我們的套件包差不多就設定好了\n接著就要進入測試流程，因為我們是要在 Laravel 專案中使用的\n所以就建立一個新的 Laravel 專案來進行測試，叫做 lara-ahoy\nlaravel new lara-ahoy 可以藉由指令查看安裝的 Laravel 版本\ncd \u0026lt;專案目錄\u0026gt; php artisan -V # Laravel Framework 6.20.30 專案中引用套件 加入套件項目 在專案中使用指令，在 composer.json 中加入套件的版本儲存位置\n這邊因為是在本機測試，所以使用 path 方法指定本機套件包的相對或絕對路徑\n關於路徑的設定可以參考官方說明：Composer Documentation #Path  composer config repositories.ray247k path ../larapeko 從相對路徑看得出來我把套件包(larapeko) 和測試用的專案(lara-ahoy) 放在同一個資料夾裡面\n指令執行之後可以打開 lara-ahoy 專案的 composer.json 檔案\n會發現最下面多了一段\n{ \u0026#34;repositories\u0026#34;: { \u0026#34;ray247k\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;../larapeko\u0026#34; } } } 如果不想用指令加入套件位址，也可以手動加入這段\n如果套件是在某個 repository 的話 可以把引用 type 換成 vcs，然後加上遠端版本庫的 url\ncomposer config repositories.ray247k vcs https://github.com/ray247k/larapeko 或是手動調整 composer.json 裡面的 repositories 設定\n{ \u0026#34;repositories\u0026#34;: { \u0026#34;ray247k\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;vcs\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://github.com/ray247k/larapeko\u0026#34; } } } 遠端的 url 可以使用 https 或是 ssh 方法\n但如果該套件的 repository 是私有的，那就必須用 ssh：git@github.com:ray247k/larapeko.git\n添加依賴 可以使用指令\ncomposer require ray247k/larapeko @dev 或是直接打開 cmoposer.json 找到require段落加入底下內容\n{ \u0026#34;require\u0026#34;: { \u0026#34;ray247k/larapeko\u0026#34;: \u0026#34;@dev\u0026#34; }, } 若是在使用指令的時候發生某個套件的相依套件無法安裝而造成錯誤的話\nProblem 1 - \u0026lt;某個套件\u0026gt; is locked to version 3.1.2 and an update of this package was not requested. - \u0026lt;某個套件\u0026gt; 3.1.2 requires ext-rdkafka \u0026gt;=1.0 -\u0026gt; it is missing from your system. Install or enable PHP's rdkafka extension. 可以藉由加上 --ignore-platform-reqs 忽略平台\ncomposer require ray247k/larapeko --ignore-platform-reqs 在添加本機依賴之後，預設每次被使用都會自動去抓取本機套件最新的程式碼\n如果沒自動抓取，或是不想要自動抓取，而是每次都想要 composer require 來更新的話\n可以在測試專案中的 composer.json 透過 repositories 區塊內的 options.symlink 設定來調整\n{ \u0026#34;repositories\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;path\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;../../packages/my-package\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;symlink\u0026#34;: false } } ] } 安裝套件 使用套件安裝指令\ncomposer install 在上圖中可以看到剛剛的套件已經成功被發現，並且安裝\nDiscovered Package: ray247k/larapeko Package manifest generated successfully. 如果跟 require 的時候一樣發生相依套件的版本錯誤，一樣可以加入參數忽略平台\ncomposer install --ignore-platform-reqs 打開 lara-ahoy 中的 composer.lock 檔案，可以看到剛剛成功安裝的套件資料\n若是先前已經執行過專案，那必須清除原有 autoload 的快取\ncomposer dump-autoload 測試套件 上一步驟中我們在測試用專案 lara-ahoy 中安裝好了本機開發的套件 larapeko\n接著會分別用兩種方式測試套件是否有正確被引入，分別是直接呼叫測試和單元測試\n在開發套件時候如果就有撰寫單元測試，那這時候就會方便許多\n本篇文章也會帶著你建立基本的單元測試並執行，就繼續看下去吧！\n方法一、檔案測試 直接在測試用的 Laravel 專案跟目錄資料夾下建立 test-autoload.php 檔案\n在檔案中載入 autoload 之後呼叫套件方法\n\u0026lt;?php # test-autoload.php  use Ray247k\\LaraPeko\\LaraPeko; require_once \u0026#39;./vendor/autoload.php\u0026#39;; LaraPeko::sayPeko(); 在 lara-ahoy 專案目錄下執行測試檔案\nphp test-autoload.php 如果成功載入應該會出現套件中sayPeko()的執行結果\n雖然跳出了 PHP Deprecated，但是還是有成功印出我們的預設字串內容\n代表剛剛在 ServiceProvider 註冊的 Facade aliases 有成功被呼叫了！\n如果真的很不想看到那個錯誤訊息\n只要在 test-autoload.php 中加入error_reporting(0);關閉錯誤訊息提示\n\u0026lt;?php error_reporting(0); use Ray247k\\LaraPeko\\LaraPeko; require_once \u0026#39;./vendor/autoload.php\u0026#39;; LaraPeko::sayPeko(); 如此就不會看到 PHP Deprecated 的提示了\n方法二、使用單元測試 接著就是使用單元測試來測試套件，參考文件：Laravel Package Development #Testing  先試試看 PHPUnit 是否可以執行，在專案目錄下使用指令\nphp vendor/bin/phpunit 如果出現底下錯誤訊息\n/usr/bin/php declares an invalid value for PHP_VERSION. This breaks fundamental functionality such as version_compare(). Please use a different PHP interpreter. 那看來是蘋果的鍋：PHPUnit does not work when I run the tests on the Laravel framework   PHPUnit refuses to be run with a PHP interpreter where the value of the PHP_VERSION constant contains an invalid value due to modification made by vendors that ship (binary) distributions of PHP.\n  7.3.24-(to be removed in future macOS) is such an invalid value. The -(to be removed in future macOS) suffix was added by Apple, who is the vendor of the PHP interpreter binary you use.\n  TL;DR: Do not use the PHP interpreter that is shipped by Apple with macOS. Use Homebrew, or similar, instead.\n 這時候有兩個解法，一個是用 Homebrew  安裝 PHP，記得要修改 bash/zsh 的設定檔\n另一個是把測試專案搬到 docker 環境裡面 PHP mount 的資料夾內\n直接進到 php 容器裡面執行 php vendor/bin/phpunit 指令\n如果 php vendor/bin/phpunit 可以執行，接著就要來建置單元測試檔案\n先在 LaraPeko.php 新增一個測試用的 function\npublic function getAhoy() { return \u0026#34;ahoy\u0026#34;; } 接著在套件包專案內建立 tests 資料夾，並建立測試檔案 LaraPekoTest.php\n\u0026lt;?php namespace Ray247k\\LaraPeko; use PHPUnit\\Framework\\TestCase; class LaraPekoTest extends TestCase { /** * @test * * @return void */ public function testClassInstance() { $this-\u0026gt;assertInstanceOf(LaraPekoTest::class, new LaraPekoTest); } public function testGetAhoy() { $larapeko = new LaraPeko(); $this-\u0026gt;assertEquals(\u0026#39;ahoy\u0026#39;, $larapeko-\u0026gt;getAhoy()); } } 可以看到我們呼叫 LaraPeko 物件，然後調用了 getAhoy() 方法\n因為我們上面有建立了這個方法，會回傳「ahoy」\n使用 assertEquals 的測試斷言式判斷回傳值是不是等於「ahoy」\n建立好 test file 之後進到容器中的 Laravel 專案的根目錄，使用指令執行指定路徑下的測試\nphp vendor/bin/phpunit vendor/ray247k/larapeko/tests 補充\n假設現在 LaraPeko 套件裡有個 private function 叫做 testMethod\nprivate function testMethod() { return \u0026#39;Haha\u0026#39;; } 如果想測試 private function 可以使用閉包中的 bindTo() 方法\n產生物件之後手動注入一個物件，替換掉 closure 物件中的 $this\n如此一來就像是直接使用 LaraPeko 物件去呼叫 testMethod 方法\n/** * @test * * @return void */ public function testMethodTest() { $contentSegment = new LaraPeko(); $closure = function () { return $this-\u0026gt;testMethod(); }; $closure_bind = $closure-\u0026gt;bindTo($contentSegment, $contentSegment); $this-\u0026gt;assertEquals(\u0026#39;Haha\u0026#39;, $closure_bind()); } 這樣去執行單元測試就可以對 private 方法進行測試了！\n 以上就是這次\n",
    "ref": "/blog/202107-laravel-package-development/"
  },{
    "title": "用 Docker 建立 Laravel 開發環境",
    "date": "",
    "description": "介紹如何使用 Docker 建置基礎的 Laravel 的開發環境",
    "body": "過去在本機開發 Laravel 專案，多數是直接在本機安裝所需要服務\n而後來改以虛擬機為主，曾經官方文件推薦開發環境的 Homestead  是很多人第一次使用的環境\n而後出現的 Laradock  就是一個容器化的 PHP 開發環境\n裡面已經預先設定好了常用的容器，只需要修改一些設定就可以直接使用\n可以說是 Laradock 開啟了 Laravel 的大容器時代，在目前最新版本的 Laravel 8  中直接內建了容器環境\nLaravel Sail  是一個輕量級的 cli\n為使用 PHP、MySQL 和 Redis 建置的 Laravel 專案提供了一個可以直接使用的容器，甚至不需要有 Docker 經驗\n那為什麼還需要自己學 Docker 自己建環境呢？因為當初還沒有 Sail 可以用\n在本機開發可能不會遇到需要調整設定檔的情況\n但是如果你想要的服務 Laravel Sail  沒有提供\n又或是想要把線上環境也改為使用 Docker，那就必須要知道怎麼用 Docker 建置環境\n並且知道該怎麼配置相關服務\n 廢話一大串，正文開始\nLaravel 專案環境建置 使用 docker-compose 建構 Laravel 專案環境\n一個 Laravel 專案需要包含以下服務\n nginx php redis postgreSQL  資料庫選用 postgreSQL，如果想換成 mysql 的也有在程式碼中附上設定方式\n啟動的時候二選一就好！\n1. docker-compose.yml 首先先建立一個專案資料夾，為了好分辨就叫 docker_env 吧\n在 docker_env 資料夾內建立檔案 docker-compose.yml，當作 docker-compose 服務的設定檔\n完整程式碼 # docker-compose.yml version: \u0026#39;3\u0026#39; networks: server: data: services: nginx: container_name: docker_env_nginx image: nginx:1.18 # stable version networks: - server ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - ./nginx/conf.d/:/etc/nginx/conf.d/ - ./nginx/ssl/:/ssl/ - \u0026lt;local project path\u0026gt;:/var/www/html/\u0026lt;project name\u0026gt; restart: always php: container_name: docker_env_php build: ./php/ expose: - 9000 networks: - server - data volumes: - /trp/web/home/:/var/trp/ restart: always redis: container_name: docker_env_redis image: redis:6.0 # stable version ports: - \u0026#34;6379:6379\u0026#34; networks: - data restart: always postgre: container_name: docker_env_postgre ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:12.6\u0026#34; volumes: - /trp/database/dev/database_data:/var/lib/postgresql/data # persist data even if container shuts down networks: - data environment: POSTGRES_DB: ${DB_NAME} POSTGRES_USER: ${DB_USER} POSTGRES_PASSWORD: ${DB_PASSWORD} restart: always mysql: container_name: docker_env_mysql ports: - \u0026#34;3306:3306\u0026#34; image: mysql:5.7.23 volumes: - /var/lib/mysql networks: - data environment: MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD} MYSQL_USER: ${DB_USER} MYSQL_PASSWORD: ${DB_PASSWORD} 分段說明 這邊會就 services 內容做說明，也會一併把需要的設定做完\n如果只把上面複製貼上就啟動服務的話必定會失敗的\nnginx 使用 nginx 作為我們的 Web 伺服器程式\nnginx: container_name: docker_env_nginx  # 將容器命名為 docker_env_nginx  image: nginx:1.18  # stable version networks: - server ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; # 容器外主機的 port:容器內的 port volumes: - ./nginx/conf.d/:/etc/nginx/conf.d/  # 載入的 nginx 設定檔 - ./nginx/ssl/:/ssl/  # 使用的 ssl 憑證 - \u0026lt;local project path\u0026gt;:/var/www/html/\u0026lt;project name\u0026gt; # 將專案掛載進容器裡面 restart: always  # 自動重啟 ports 設定了對容器內外的 port 對應，上面的設定檔中比較看不出來\n我們改成 8080:80 來說明的話就是把主機上的 8080 port 映射給 nginx 容器內的 80 port\nvolumes 區塊則是說明需要掛載進 Docker 容器中的檔案，表現方式一樣是 本機位置:容器內位置\n第三行中我們把指定的 Laravel 專案掛載進容器的指定目錄下，如果你沒有 Laravel 專案的話先去建一個新專案\n第二行掛載了如果本機也想要用 https 的網址，你可以自己產一組證書放在 docker_env/nginx/ssl 目錄下\n這麼做雖然會顯示不安全，但是至少是 https 的網址\n第一行我們把同層中的 nginx 資料夾掛載進「/etc/nginx/conf.d/」這是 nginx 服務使用的設定檔位置\n所以我們要在 docker_env/nginx 資料夾中建立 nginx config 檔案\n# dev.project.com.conf server { listen 80; listen [::]:80; # Redirect all HTTP requests to HTTPS with a 301 Moved Permanently response. return 301 https://$host$request_uri; } server { listen 443 ssl; listen [::]:443 ssl; root /var/www/html/\u0026lt;laravel project name\u0026gt;/public; index index.php index.html index.htm; ssl_certificate /ssl/ssl.crt; ssl_certificate_key /ssl/ssl.key; server_name dev.project.com; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri /index.php =404; fastcgi_pass docker_env_php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ /\\.ht { deny all; } } 可以看到，監聽 80 port 的部分，會直接使用 301 跳轉到 443 port a.k.a https 使用的 port\nroot 則是指定專案資料夾的位置，可以看到他的指定位置和剛剛在 docker-compose.yml 中設定的掛載路徑一樣\n至於 public 是 Laravel 專案的程式進入點\n使用的 ssl 憑證也是對應到掛載時指定的容器內部路徑\n而 fastcgi_pass 是指定到有安裝 php-fpm 的容器 container_name，以及剛剛提供容器內部存取的 port\n其名稱和使用的 port 不是固定的！\nphp php: container_name: docker_env_php build: ./php/ expose: - 9000 networks: - server - data volumes: - \u0026lt;local project path\u0026gt;:/var/www/html/\u0026lt;project name\u0026gt; # 將專案掛載進容器裡面 restart: always 因為 php 容器不需要對外 port，所以使用 expose 讓容器的 9000 port 可以在 docker network 裡面被存取\nvolumes 的掛載方式和 nginx 服務一樣\n而要使用 Laravel，我們需要額外安裝一些 PHP 的擴充套件\n安裝套件這件事情會使用 build 指令，重新打包我們自己的 docker image\n會安裝一些 Laravel 所需要的 PHP 擴充套件，而資料庫的擴充套件就依照所使用的資料庫做選擇\n底下主要以 postgreSQL 做範例\n這邊也會一併示範安裝 composer，如果需要的話自行開啟，但是因為 PHP 不需要提前編譯的特性\n我們可以透過直接在本機下指令改變 volumes 的檔案，進而讓容器內部程式產生變更\n除非有非要在容器內下指令的原因，否則是不建議安裝\n在 docker_env 資料夾下建立 php 資料夾，新增檔案 Dockerfile\n# DockerfileFROMphp:7.4-fpmWORKDIR/varRUN apt-get update \u0026amp;\u0026amp; apt-get install -y libpq-dev libpng-dev libzip-dev zipRUN docker-php-ext-install pgsql pdo_pgsql gd zip\\ \u0026amp;\u0026amp; docker-php-ext-enable opcache# To use mysql, install pdo pdo_mysql instead of pgsql pdo_pgsql# Install composer Latest# RUN php -r \u0026#34;copy(\u0026#39;https://getcomposer.org/installer\u0026#39;, \u0026#39;composer-setup.php\u0026#39;);\u0026#34; \\# \u0026amp;\u0026amp; php -r \u0026#34;if (hash_file(\u0026#39;sha384\u0026#39;, \u0026#39;composer-setup.php\u0026#39;) === \u0026#39;756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3\u0026#39;) { echo \u0026#39;Installer verified\u0026#39;; } else { echo \u0026#39;Installer corrupt\u0026#39;; unlink(\u0026#39;composer-setup.php\u0026#39;); } echo PHP_EOL;\u0026#34; \\# \u0026amp;\u0026amp; php composer-setup.php \\# \u0026amp;\u0026amp; php -r \u0026#34;unlink(\u0026#39;composer-setup.php\u0026#39;);\u0026#34; \\# \u0026amp;\u0026amp; mv composer.phar /usr/local/bin/composerdatabase postgre: container_name: docker_env_postgre ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:12.6\u0026#34; volumes: - /trp/database/dev/database_data:/var/lib/postgresql/data # persist data even if container shuts down networks: - data environment: POSTGRES_DB: ${DB_NAME} POSTGRES_USER: ${DB_USER} POSTGRES_PASSWORD: ${DB_PASSWORD} restart: always mysql: container_name: docker_env_mysql ports: - \u0026#34;3306:3306\u0026#34; image: mysql:5.7.23 volumes: - /var/lib/mysql networks: - data environment: MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD} MYSQL_USER: ${DB_USER} MYSQL_PASSWORD: ${DB_PASSWORD} 而資料庫的設定中 volumes 主要是在做資料持久化使用，當容器重啟時會去讀取裡面的資料\n資料庫的相關環境參數設定則是在 environment 區塊中，可以看到有很多敏感資料\n所以我們可以藉由在 docker_env 資料夾中建立不加入版本控制的 .env 檔案\n# .env DB_USER=db_user DB_PASSWORD=db_password DB_NAME=my_database 等號左邊的鍵值可以在 docker-compose.yml 裡面透過 ${鍵值} 呼叫，進而取得左邊設定的值\n啟動容器 經過上面的步驟，我們設定了 nginx php 和資料庫的服務\n確定 Docker 服務本身有在運作後，進入 docker_env 資料夾下執行\ndocker-compose up -d 如果一切正常，容器會在背景起動\n這樣就完成了「使用 Docker 建置 Laravel 環境」的目標！\n要檢查容器啟動狀況可以使用指令，看是不是全部運行中\ndocker ps -a 不過如果是我自己在寫新的 docker-compose.yml 設定檔，我會先使用\ndocker-compose up 讓 Log 即時顯示在畫面上，這時候要除錯就方便很多了！\n通常會遇到的問題是 volume 的資料夾不存在，例如 nginx config、ssl、Laravel 專案\nLaravel .env 設定 在完成 Docker 環境的啟動之後，就要設定 Laravel 專案的環境設定檔\n開啟根目錄下的.env，修改內容，這邊資料庫一樣使用 postgreSQL 做範例\n設定上使用 docker-compose.yml 中 postgre 服務的內容\n DB_HOST：設定檔中的容器名稱 container_name DB_PORT：設定檔中的 ports DB_DATABASE：設定檔中的 POSTGRES_DB DB_USERNAME：設定檔中的 POSTGRES_USER DB_PASSWORD：設定檔中的 POSTGRES_PASSWORD  # .env DB_CONNECTION=pgsql DB_HOST=docker_env_postgre DB_PORT=5432 DB_DATABASE=my_database DB_USERNAME=db_user DB_PASSWORD=db_password 如以一來 Laravel 專案就可以透過容器內部網路存取到資料庫所在的容器\n設定本機測試用網址 用 Docker 建立 Laravel 環境 - 完成 Laravel 連線到 Docker 的資料庫 - 完成\n如此一來就大功\u0026hellip; 欸不對！我還沒上車 我要怎麼看專案的畫面？\n接下來要做的就是讓我們可以用瀏覽器開啟本機 Laravel 專案的畫面\n首先使用終端機指令，不管是 bash 還是 zsh\nsudo vim /etc/hosts 在 /etc/hosts 檔案裡面加入\n127.0.0.1 dev.project.com 意思是要把後面定義的網址名稱，指向前面的 IP 位址\n所以當瀏覽器網址列輸入 dev.project.com 的時候會將請求發送到本機的 localhost\n那為什麼這樣就可以看到剛剛設定的 Laravel 專案呢？\n因為我們在前面的 nginx config 設定中，有設定了 server_name 內容\nserver_name dev.project.com; 所以當監聽本機 80 和 443 port 的 Docker nginx 服務發現有請求進來\n而且符合 server_name 區塊設定的內容，就會進行處理\n如果你有另一個 nginx config 在 listen port 號的後面加上 default_server 如下\nlisten 80 default_server; 那代表當其他 nginx config 規則都沒有抓取到的時候，nginx 會使用這個設定檔\n若是全部 config 都沒有設定成 default_server，那麼會使用「檔名排序最前面」的設定檔\n如此一來應該就可以瀏覽 Laravel 專案的畫面了\n執行 Laravel 指令 如果想執行 Laravel 中跟資料庫有關的指令，例如\nphp artisan migrate 首先要先進入 php 容器內\ndocker exec -ti docker_env_php bash 在容器內的專案目錄下運行指令，就可以看到指令被正確執行\n若是沒有連進容器，直接執行 migrate 指令，則會得到錯誤訊息\nSQLSTATE[08006] [7] could not translate host name \u0026quot;docker_env_postgre\u0026quot; to address: nodename nor servname provided, or not known 因為程式不認得「docker_env_postgre」這個 host 的真實位址，所以無法執行\n如果我們把 .env 中的 DB_HOST 換成真實位置，透過 docker inspect 指令取得\n就可以執行，但是每次容器重啟就會被刷新。看來並沒有解決問題\n如果真的很懶，覺得連進容器執行也很麻煩，就是要直接在本機資料夾執行該怎麼辦呢？\n再一次修改 etc/hosts 檔案，加上\n127.0.0.1 docker_env_postgre # 資料庫使用的容器名稱 完工啦，這樣在本機專案資料夾下執行 migrate 就會被指向本機容器\n 以上就是這次「用 Docker 建立 Laravel 開發環境」的全部內容\n好幾個小時終於打完這一篇，真的是心血結晶\n牽涉到很多伺服器知識，如果不熟的人建議還是去了解一下再進行操作 礙於篇幅只能簡單說明怎麼設定，跳過很多設定的詳細說明和作法\n還有很多部分沒提到，像是 docker network 的切分和使用\n",
    "ref": "/blog/202107-laravel-environment-with-docker/"
  },{
    "title": "環境初始化主機設定(Docker + Laravel)",
    "date": "",
    "description": "介紹如何在一台剛開的主機上設定基礎的 Docker 以及 Laravel 執行環境",
    "body": "如果今天開啟一台全新的雲端主機，要在上面使用 Docker 建立 Laravel 開發環境\n並且可以在遠端主機執行 Laravel 常用的 composer 與 artisan 指令\n因為這個步驟實在不常執行，所以記錄下來方便未來查找\n也為了接下來使用 Docker 建立 Laravel 環境文章做鋪陳\n1. 建立版本庫存取權限 要讓遠端主機可以對指定的 Repository 進行存取，需要加入 ssh key\n正規方法： ssh 登入遠端主機之後，在遠端主機使用指令產生 ssh key\nssh-keygen 然後把 public key 加到遠端版本庫\n小朋友不要學的方法： 也是可以把自己已經具有版本庫存取權限的 key pair 塞進遠端主機\n如果 .ssh 資料夾不存在要自己加，權限 700\nmkdir .ssh chmod 700 .ssh cd .ssh vim id_rsa chmod 600 id_rsa vim id_rsa.pub chmod 644 id_rsa.pub 2. 更新 linux 套件包 因為等等要裝套件，先更新主機的套件包\nsudo apt update 3. 安裝 docker 都說要建立 Docker 的環境，當然要安裝 Docker\nsudo apt install docker.io 4. 安裝 docker-compose 後面會使用 docker-compose 來組合多個 Docker container 啟動一個完整服務\n因為之後的 Laravel 專案中會同時啟動 nginx, PHP, redis, mysql 等容器\n透過 docker-compose 管理與操作會比較方便\nsudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 5. 安裝 php 套件 因為 Laravel 專案不需要編譯，當我們修改容器外的檔案，會同步對掛載進容器的檔案做變更\n所以不一定要連進容器裡執行指令，在本機的變更一樣會直接生效。當然不進行這一步也是可以的\n為了之後可以直接在主機上執行 php artisan 和 phpunit，還有安裝\u0026amp;執行 composer\nPHP 版本根據你的需求安裝\napt install php7.4-cli php7.4-gd install php7.4-mbstring php7.4-curl php7.4-xml php7.4-zip 如果不確定自己想找的套件名稱叫什麼，可以在 apt install php7.4 之後按兩下 tab\n這樣就會列出名稱為「php7.4」開頭的所有套件，如此就可以很方便的找到指定版本的套件！\n下圖用 apt install docker 按兩下 tab 顯示所有「docker」開頭的套件為例\n6. 安裝 PHP 的套件管理工具 composer 照官網步驟安裝即可：Download Composer  範例：（正確指令以官方網站為主）\nphp -r \u0026#34;copy(\u0026#39;https://getcomposer.org/installer\u0026#39;, \u0026#39;composer-setup.php\u0026#39;);\u0026#34; php -r \u0026#34;if (hash_file(\u0026#39;sha384\u0026#39;, \u0026#39;composer-setup.php\u0026#39;) === \u0026#39;756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3\u0026#39;) { echo \u0026#39;Installer verified\u0026#39;; } else { echo \u0026#39;Installer corrupt\u0026#39;; unlink(\u0026#39;composer-setup.php\u0026#39;); } echo PHP_EOL;\u0026#34; php composer-setup.php php -r \u0026#34;unlink(\u0026#39;composer-setup.php\u0026#39;);\u0026#34; 將 composer 移動到環境變數，讓全域都可以使用指令\n建議要執行此步驟，否則就只能在你安裝的路徑（有 composer.phar 檔案）的地方執行指令\nsudo mv composer.phar /usr/local/bin/composer 若要查看全域可以執行的指令與對應目錄\necho $PATH 7. 設定 .sh 檔案可執行 如果專案中有 shell 需要執行，必須要修改檔案權限\nchmod 755 {target file path}  如此就可以在主機中執行以下的指令\n docker composer php artisan  也就完成了接下來使用 Docker 建置 Laravel 環境的所需要的基礎設定\n",
    "ref": "/blog/202107-initialize-server-setting-with-docker-and-laravel/"
  },{
    "title": "[用 Drone 建立自動部署] 04 drone runner 介紹",
    "date": "",
    "description": "透過 Drone 建立自動部署流程，drone runner 介紹",
    "body": "我們在 [用 Drone 建立自動部署] 01 基本服務建置及串接 GitHub  文章中有 docker-compose.yml 的範例\n在範例中建立了兩個 docker runner，分別是 drone_runner_docker 和 drone-runner-ssh\n而在 [用 Drone 建立自動部署] 02 部署觸發條件(pipeline)設定  中使用到的其實只有 docker runner\n這篇文章來分別介紹兩個 runner，以及官方網站上提到的其他 runner\n所有的 runner 可以在官方網站的 runner overview  頁面找到\n預設的 runner 是 docker runner\n在文章編輯的時候有的 runner 列表\n Docker Runner   Kubernetes Runner   Exec Runner   SSH Runner   Digital Ocean Runner   Macstadium Runner    ssh runner 範例： kind: pipeline type: ssh name: default server: host: from_secret: GCP_IP_HOST user: from_secret: TESTING_USER ssh_key: from_secret: TESTING_PRIVATE_SSH_KEY steps: - name: greeting commands: - echo hello world - whoami - pwd - echo DRONE_REPO = ${DRONE_REPO} - echo DRONE_BRANCH = ${DRONE_BRANCH} 解說 當 type 使用 ssh 的時候，就是使用 ssh runner 執行\n在 server 區塊中指定了 ssh 所需要的參數，包含遠端的 host ip 位置以及登入的使用者名稱\nfrom_secret: SSH_KEY 代表從 Drone 服務後台設定的 Secrets 取用特定 index 的值\n如果有需要使用 ssh 登入主機操作，則這邊要填入主機的 id_rsa\n並且也要建立權限為 600 的 authorized_keys 檔案在用來登入的使用者目錄下 .ssh 中\n檔案內容則是 id_rsa.pub 的內容，如此 drone 的 ssh runner 才能正確的使用指定使用者的 ssh key 登入遠端主機\n這樣做的好處是敏感資料不用讓所有專案的部署者知道，只要知道使用的 secrets index 叫什麼就好\n未來若是有修改，也只需要在 Drone 後台操作，不需要每個專案修改檔案\nSecrets 官方說明  當然也可以使用 password 而不是 ssh 登入遠端主機，更多設定可以在 官方文件  裡面查看\ndocker runner 會使用指定的 image 去建立容器，並且用容器執行指定的行爲\n是預設的 runner，也是建議初學者使用的 runner\n若是你的多個 pipeline 會需要繼承對主機檔案進行操作的行為則不適合\n因為 Docker pipelines 是執行在 Docker 容器中，和實體主機是隔絕的，並不會直接影響主機上的檔案\n範例 kind: pipeline type: docker name: backend_dev steps: - name: submodules update image: alpine/git commands: - whoami - pwd - date - echo DRONE_REPO = ${DRONE_REPO} - echo DRONE_BRANCH = ${DRONE_BRANCH} - echo DRONE_COMMIT = ${DRONE_COMMIT} - echo DRONE_BUILD_NUMBER = ${DRONE_BUILD_NUMBER} - git submodule update --init --recursive trigger: branch: - dev event: - push 其他 runner Exec Runner 使用時機 不適合跑在容器內的專案，例如：MacOS 的專案\n不該使用的時機 由於 Exec runner 沒有和主機隔離，所有操作都是直接在服務建構的主機上操作\n如果專案和 Drone 服務沒有在同一台主機上，或是有人在專案內的 .drone.yml 加入危險的指令\n那會釀成悲劇，所以一般來說預設都使用 Docker runner\n並且 Exec runner 是 Beta 版本，並不建議使用在正式環境中\n範例 可以看到底下範例，pipeline 被觸發時會直接在主機上下指令！\n--- kind: pipeline type: exec name: default steps: - name: backend commands: - go build - go test - name: frontend commands: - npm install - npm test  以上就是常用的 Drone Runner 介紹，建議都是使用 Docker runner\n因為大部分所需要的操作都有現成的 Docker image 了\n沒有特別必要的話就別使用另外兩個 runner 直接對主機檔案系統操作，或是直接在主機下指令\n而 Kubernetes 我還沒有用過，所以並沒有介紹到 Kubernetes runner\n未來若有機會再補充\n",
    "ref": "/blog/202107-drone-cicd-4-advanced-runner/"
  },{
    "title": "[用 Drone 建立自動部署] 03 部署排程設定與權限管理",
    "date": "",
    "description": "透過 Drone 建立自動部署流程，部署排程設定與權限管理",
    "body": "使用 Drone  建立自己的自動部署服務\nDrone 是一套以 Golang 開發的一套 CI/CD 系統工具\n本篇進行部署排程設定與權限管理的教學\n定時執行 (Cron Job) 當初在設定排程的時候真的是各種坑，要是前面的服務啟動花了三天的話\n排程設定不斷查文件、看討論串、測試、除錯，整個大概花了半個月吧\n很多細節作者都只回在 gitter 或是論壇裡，並沒有寫進官方文件\n還有公司用的是 bitbucket，有些功能並不支援！\n自訂執行時間 服務本身的限制 Drone 1.0 最終版不給在介面上自訂因為容易出錯：來源  且最低重複執行時間半小時一次：來源  專案設定檔的設定方法 作者說明應該要用 CLI 定義好之後在專案的 .drone.yml 檔去設定觸發條件的 cron job 名稱\n而不是表達式：Cron job definition  表達式的時區居然是寫死的 官方說明排程的時區是使用 UTC 也就是 +0 時區，所以要自己換算：Cron Timezones   The current implementation calculates the execution time based on UTC as opposed to local time.\n 不過官方也說自訂排程時間不會在準確的時間被觸發，前後可能會差一點點：參考資料  建立 Cron Job 大部分教學都使用 Drone CLI，但是在官網發現可以用 API 建立：API drone cron create  ，結果一樣\n首先要去 Drone 頁面右上的 User Settings 取得 Token 作為 Post 的 header\n打開 Postman 建立一個 POST /api/repos/{owner}/{repo}/cron 請求\n並在 Headers 頁籤加入 Token\nTocken key 是 Authorization\n而對應的 value 長得像 Bearer {一串英文數字} 的格式\nBody 則是設定 Cron Job 名稱和執行條件還有要執行的分支\n{ \u0026quot;name\u0026quot;: \u0026quot;every2hour\u0026quot;, \u0026quot;expr\u0026quot;: \u0026quot;0 0 */2 * * *\u0026quot;, \u0026quot;branch\u0026quot;: \u0026quot;main\u0026quot; } 可以看到我的條件是 0 0 8-16,*/2 * * *，代表「8-16 點，每兩個小時執行一次」\n或是也可以設定成 0 0 10,12,14,16 * * *「每個 10 12 14 16 點」執行\n可以使用 線上工具  來依照條件產生\n 注意！這邊作者使用的時間套件是包含秒數的 6 位數格式！\n 查看 Cron Job Cron List 建立完成之後可以使用 GET /api/repos/{owner}/{repo}/cron 查看所有 Cron Job 列表\nCron Info 使用 GET /api/repos/{owner}/{repo}/cron/{name} 則可以查看指定 Cron Job 的詳細資訊\n回到 Drone 後台，點開專案的 settings 頁面會發現我們剛剛用 API 建立的 Cron Job 被加入了!\n等時間到就會執行 .drone.yml 中由指定 Cron Job 名稱觸發的 pipeline\n更新 Cron Job 更新Cron Job 使用 PATCH /api/repos/{owner}/{repo}/cron/{name}\nBody 帶入要改變的內容，例如把使用的分支換成 dev\n或是把執行時間換成每天的固定時間執行\n{ \u0026quot;name\u0026quot;: \u0026quot;every2hour\u0026quot;, \u0026quot;expr\u0026quot;: \u0026quot;0 0 2,4,6,8 * * *\u0026quot;, \u0026quot;branch\u0026quot;: \u0026quot;dev\u0026quot; } 刪除 Cron Job 可以使用 DELETE /api/repos/{owner}/{repo}/cron/{name} 刪除之前建立的 Cron Job\n但是我更偏好用後台的 UI 介面按下 DELETE 就好\n另外一種操作方式是 Drone CLI，不過這次沒用上，提供給各位參考\n Drone CLI Cron   CLI drone cron add    權限控管 如果沒設定使用者，服務上線到公開網址的話就是全世界都可以拿來使用：官方說明   Drone registration is open by default. This means any user can register an account and use the system.\n 管理員權限設定 在 drone_server 建立 admin 才能管理其他帳號：DRONE_USER_CREATE  - DRONE_USER_CREATE=username:ray247k,admin:true 使用者名單設定 藉由設定使用者名單來限制存取權限：官方文件  可以使用機構或是使用者 ID\n- DRONE_USER_FILTER=ray247k,lemon,JohnDoe 但如果版本控制使用的是 Bitbuctet 平台，則不支援 Organization 限制：討論串說明  所以只要有寫入權限就可以看到 setting 頁面\n使用 GitHub 測試，結果是可以使用組織進行權限控管的，並且不會開放 setting 分頁給所有人\n",
    "ref": "/blog/202106-drone-cicd-3-advanced-cron-job/"
  },{
    "title": "[用 Drone 建立自動部署] 02 部署觸發條件(pipeline)設定",
    "date": "",
    "description": "透過 Drone 建立自動部署流程，部署觸發條件(pipeline)設定",
    "body": "使用 Drone  建立自己的自動部署服務\nDrone 是一套以 Golang 開發的一套 CI/CD 系統工具\n本篇進行複數觸發條件設定，在不同觸發條件下觸發不同的部署步驟設定\n複數觸發條件(Multiple Conditions) 有時候專案中在特定分支要做不同的事件，這時候可以參考以下設定\n.drone.yml\n--- ################################################ # dev 每次推到分支就更新 # ################################################ kind: pipeline type: docker name: backend_dev steps: - name: submodules update image: alpine/git commands: - date - echo DRONE_REPO = ${DRONE_REPO} - echo DRONE_BRANCH = ${DRONE_BRANCH} - echo DRONE_COMMIT = ${DRONE_COMMIT} - echo DRONE_BUILD_NUMBER = ${DRONE_BUILD_NUMBER} - git submodule update --init --recursive - name: composer install image: composer:1.10.19 commands: - composer install --ignore-platform-reqs trigger: branch: - dev event: - push --- ################################################ # stage 根據排程設定執行 # ################################################ kind: pipeline type: docker name: backend_stage steps: - name: submodules update image: alpine/git commands: - date - echo DRONE_REPO = ${DRONE_REPO} - echo DRONE_BRANCH = ${DRONE_BRANCH} - echo DRONE_COMMIT = ${DRONE_COMMIT} - echo DRONE_BUILD_NUMBER = ${DRONE_BUILD_NUMBER} - git submodule update --init --recursive - name: composer install image: composer:1.10.19 commands: - composer install --ignore-platform-reqs trigger: event: - cron cron: - every2hour --- ################################################ # production 使用 git tag 發動部署 # ################################################ kind: pipeline type: docker name: backend_production steps: - name: submodules update image: alpine/git commands: - date - echo DRONE_REPO = ${DRONE_REPO} - echo DRONE_TAG = ${DRONE_TAG} - echo DRONE_COMMIT = ${DRONE_COMMIT} - echo DRONE_BUILD_NUMBER = ${DRONE_BUILD_NUMBER} - git submodule update --init --recursive - name: composer install image: composer:1.10.19 commands: - composer install --no-dev --ignore-platform-reqs trigger: event: - tag 如果 push dev 分支，則只會執行 dev_check_info 和 dev_run_update 兩個動作\n相對的 push testing 分支的行為則會等到指定排程 every2hour 被觸發才會執行\n如此就可以針對不同環境可能會偵測不同分支來做不同的操作，比較常見是啟動時的指令是否加上開啟除錯模式\n若是不同環境是部署在不同伺服器上，或是不同環境的部署流程不同的話是十分方便的\n每個 pipeline 都是獨立的，根據 trigger 的設定在不同條件下被觸發而執行不同步驟\n如果推送程式到 dev 分支，則只會觸發 backend_dev 這個 pipeline 以及內部的步驟 或是在版本控制中下 tag，當 webhook 監聽到新的 tag 被推送，則會觸發 backend_production\n也可以建立 cronjob 來進行排程定時執行\n例如 backend_stage 所設定的 testing 就是監聽名為 every2hour 的排程\n這部分之後會再獨立介紹相關的設定和使用方法\n更多的設定條件可以參考官方文件：Pipelines Conditions  了解更多關於 Pipeline：Pipelines Overview  ",
    "ref": "/blog/202106-drone-cicd-2-advanced-pipeline-configuration/"
  },{
    "title": "[用 Drone 建立自動部署] 01 基本服務建置及串接 GitHub",
    "date": "",
    "description": "透過 Drone 建立自動部署流程，基本服務建置及串接 GitHub",
    "body": "使用 Drone  建立自己的自動部署服務\nDrone 是一套以 Golang 開發的一套 CI/CD 系統工具\n本篇進行基礎服務啟動設定，以及串接 GitHub\n為什麼使用 drone  支援各大 git repository：github、gitlab、bitbucket、gittea 等等\n只要你的專案是使用 git 版控，你就可以輕鬆整合 drone ci 流程是以 yml 檔描述的，非常好理解，且可以靈活調整\n只要有使用過 docker-compose 的經驗應該都可以快速上手 本身是以 Go 語言打造的，服務啟動速度非常快 是一個 docker base 的服務，可以快速移植到不同平台上運行\n尤其非常適合在 k8s 叢集的環境中運行 drone 的社群上已經有各種插件可以使用，也可以用各種語言自製客製化插件\n只要包裝成 image 就能輕鬆加入 ci 流程當中，非常方便  分為 server 和 runner，server 負責收集 git repo 的事件，當偵測到 pipeline 中定義好的條件時\n比如說某個 branch push，就會觸發pipeline 的流程，分派給不同種類的 runner 執行\n常見有 Docker runner、Kubernetes runner, SSH runner 等\n 基礎建置 在本機環境使用 docker-compose 建立 Drone1.10 服務（因為 1.0 版沒有 ssh runner）\n並使用 ngrok 讓外部網路可以連線進入本機 8089 port，作為 github 的 webhook 的 callback 網址\n附註：中間 ngrok 重啟好幾遍，有些截圖的 ngrok 的網址可能會不同\n文章中只要是 ngrok.io 結尾的網址都是 ngrok 服務開通的對外網址\nSTEP 1 docker-compose.yml version: '3.7' services: drone-server: container_name: drone_server image: drone/drone:1.10 ports: - 8089:80 volumes: - /var/lib/drone:/data - /var/run/docker.sock:/var/run/docker.sock restart: always environment: - DRONE_GITHUB_CLIENT_ID=${DRONE_GITHUB_CLIENT_ID} - DRONE_GITHUB_CLIENT_SECRET=${DRONE_GITHUB_CLIENT_SECRET} - DRONE_AGENTS_ENABLED=true - DRONE_RPC_SECRET=${DRONE_RPC_SECRET} - DRONE_SERVER_HOST=${DRONE_SERVER_HOST} - DRONE_SERVER_PROTO=${DRONE_SERVER_PROTO} - DRONE_TLS_AUTOCERT=${DRONE_TLS_AUTOCERT} - DRONE_CRON_INTERVAL=1m - DRONE_USER_CREATE=${DRONE_USER_CREATE} - DRONE_USER_FILTER=${DRONE_USER_FILTER} drone-ssh-runner: container_name: drone-runner-ssh image: drone/drone-runner-ssh depends_on: - drone-server environment: - DRONE_RPC_HOST=${DRONE_SERVER_HOST} - DRONE_RPC_SECRET=${DRONE_RPC_SECRET} - DRONE_RPC_PROTO=${DRONE_SERVER_PROTO} - DRONE_RUNNER_CAPACITY=${DRONE_RUNNER_CAPACITY} drone-docekr-runner: container_name: drone_runner_docker image: drone/drone-runner-docker:1 depends_on: - drone-server volumes: - /var/run/docker.sock:/var/run/docker.sock environment: - DRONE_RPC_HOST=${DRONE_SERVER_HOST} - DRONE_RPC_SECRET=${DRONE_RPC_SECRET} - DRONE_RPC_PROTO=${DRONE_SERVER_PROTO} - DRONE_RUNNER_CAPACITY=${DRONE_RUNNER_CAPACITY} 可以在 docker-compose.yml 的同層用 .env 保存一些機密資料\n例如 ${DRONE_GITHUB_CLIENT_SECRET} 就可以從出版本控制中抽離\n關於設定的參數可以在 官方文件  了解更多\n設置 DRONE_CRON_INTERVAL=1m 讓 drone server 每一分鐘都去偵測有沒有需要執行的 cron\n預設是 30m，所以有人會遇到服務啟動之後 cron 延後被執行\n其實不是延後執行，而是 drone server 偵測未執行 cron 的行為還沒被觸發：參考資料  而在 .env 裡就直接定義名稱就好\n注意的是 DRONE_SERVER_HOST 不需要加上 protocol\n.env # GITHUB OAuth App 的設定 DRONE_GITHUB_CLIENT_ID= DRONE_GITHUB_CLIENT_SECRET= # 管理員帳號設定 DRONE_USER_CREATE=username:ray247k,admin:true # 具有存取權限的人，如果是 github 的話可以使用組織做設定。bitbucket 不行 DRONE_USER_FILTER=ray247k,lemon # Drone Server 的網址，這邊用 ngrok 開做範例 DRONE_SERVER_HOST=56662cd578da.ngrok.io # 如果沒有獨立網址，而是使用反向代理與自簽憑證的話，可能會因為驗證網域失敗報錯，這時候要改為 http 與 false DRONE_SERVER_PROTO=https DRONE_TLS_AUTOCERT=true # 隨便開心亂設定的密碼 DRONE_RPC_SECRET={亂數密碼} # 一次可以執行幾個 JOB，不可為 0 DRONE_RUNNER_CAPACITY=3 # 偵測未執行排程的間隔時間 DRONE_CRON_INTERVAL=1m DRONE_RPC_SECRET 可以使用指令來產生\nopenssl rand -hex 16 STEP 2 如果你本身有網址可以使用就不需要進行此步驟\nNgrok 開放 IP 讓外部連線 把剛剛架設的 drone 伺服器 localhost 的 8089 端口綁定到特定的 ngrok 網址\n這邊的網址等下需要複製貼上綁定到 Github OAuth App 上\nngrok http 8089 STEP 3 - 設定 Github 的 OAuth App 進入 github 的 OAuth App 設定頁面新增 OAuth 應用程式\n右上個人大頭貼-\u0026gt;settings-\u0026gt;左邊頁籤 Developer settings-\u0026gt;OAuth Apps\n開始新建 OAuth App\n填入剛剛建立好的 ngrok 網址，註冊 OAuth 應用程式\ncallback 網址設為 /login\n建立後就要開始串接 Drone CI 到 Github 了\nSTEP 4 修改 Drone 設定 點開剛剛建立的 github APP 設定\n修改剛剛 docker-compose.yml DRONE_GITHUB_CLIENT_ID 和 DRONE_GITHUB_CLIENT_SECRET\n對應頁面上的 Client ID 和 Client secrets 內容\n完成後重啟 drone 的 docker-compose.yml 服務，訪問你的 ngrok 網址查看\n驗證登入後代表你的 Drone CI 串接完成！可喜可賀！可喜可賀！\nSTEP 5 啟用服務 依照剛剛的步驟，應該可以開啟 ngrok 網址看到 Drone 的後台\n一進去是你所有的 Repository\n隨便點一個進去之後按下正中央的 ACTIVAE REPOSITORY 就可以在專案中啟用 webhook 啦\n如果想要確認的話，可以打開 Github 上剛剛的 Repository-\u0026gt;Settings-\u0026gt;Webhooks 應該會看到如圖上的畫面\n有一個 Webhook 正在使用中\n點進去可以看到更多設定，或是查看 Webhook 發送過的請求\n",
    "ref": "/blog/202106-drone-cicd-1-basic-usage/"
  },{
    "title": "Docker 常用指令",
    "date": "",
    "description": "介紹基本 Docker 操作常用指令",
    "body": "一些 Docker 上常用的指令和相關參數使用方法\n實際使用上一定不只這些指令\n服務基本指令 docker stats 顯示容器的資源使用統計 docker start 啟動一個或多個停止的容器 docker stop 停止一個或多個正在運行的容器 docker restart 重啟一個或多個容器 Log 常用指令 $ docker logs [OPTIONS] CONTAINER Options: --details 顯示詳細資料 -f, --follow 追蹤即時 log --since string 顯示自某個 timestamp「之後」的 log，或相對時間，如42m（即42分鐘） --tail string 從 log 末尾顯示多少行內容， 默認是all -t, --timestamps 顯示時間戳 --until string 顯示自某個 timestamp「之前」的 log，或相對時間：如42m（即42分鐘） 使用範例 查看某個時間之後的 log\n$ docker logs -t --since=\u0026quot;2018-02-08T13:23:37\u0026quot; {CONTAINER_ID} 顯示某個時間後的 log，且只要最後 100 行\n$ docker logs -f -t --since=\u0026quot;2018-02-08\u0026quot; --tail=100 {CONTAINER_ID} 查看最近 30 分鐘的 log\n$ docker logs --since 30m {CONTAINER_ID} 查看某個時間區間內的 log\n$ docker logs -t --since=\u0026quot;2018-02-08T13:23:37\u0026quot; --until \u0026quot;2018-02-09T12:23:37\u0026quot; CONTAINER_ID 執行容器 從本地環境的 image 建立 container\n如果不存在從 repository 訪問，private repo 必須要有「登入」行為\nimage的格式可以為[IMAGE NAME]:[TAG]\ndocker run 範例： # 執行nginx docker run -idt nginx # 執行nginx並且暴露port為8080 docker run -idt -p 8080:80 nginx # 執行nginx在8080，在失敗的時候會自動重啟動 docker run -idt -p 8080:80 --restart on-failure nginx # 執行nginx，結束後移除 docker run --rm -idt nginx 常用到的 flag `-d` detach 將 container 置於背景執行 `-i` interactive 維持 STDIN，可互動 `-t` 提供 tty 允許 container 使用 tty `-p` expose socket 對外:對內 port (ex -p 8080:80) `-p Host Port:Docker Port` `--restart` 失敗重啟(always-default, none, on-failure) `--rm` 關閉後 container 自動消滅，若不刪可能會不斷累積，即使已經死掉了 container 相關指令 列出所有活著的容器\ndocker ps 列出所有活的死的容器\ndocker ps -a 進到已存在、執行中的 container 執行指令\ndocker exec -ti nginx bash 取得 container 或是 image 的 Metadata\ndocker inspect {container name} 刪除 docker container\ndocker rm [CONTAINER] image 相關指令 列出所有 image\ndocker images 刪除指定 image\ndocker rmi [IMAGE] 如果對外開放要給別人用怎麼辦\ndocker run -i -t -d -p 80:80 nginx 如果服務遇到意外中斷\ndocker run -i -t -d -p 80:80 --restart always nginx 如果要連node.js\ndocker run -i -d -t -p 80:80 --link node nginx Volume 相關指令 列出所有 volume\ndocker volume ls 清除指定 volume\ndocker volume rm [OPTIONS] VOLUME [VOLUME...] 清除「全部」volume\ndocker volume prune 其他指令 docker build 從 Dockerfile 建立 docker image\n-f 手動指定 Dockerfile 名稱\n# 在目前的資料夾建立image，來源是Dockerfile docker build . -t image-name # 在目前的資料夾建立image，來源是Dockerfile-alt docker build . -t image-name -f Dockerfile-alt docker push / pull 將 docker image 從 repository 上拉/推上去\n要先登入 docker login\ndocker login 登入 docker repository\n",
    "ref": "/blog/202106-docker-common-commands/"
  },{
    "title": "[LeetCode] #11 Container With Most Water (Medium)",
    "date": "",
    "description": "LeetCode 第 11 題 Container With Most Water，難度 Medium",
    "body": "用 PHP 解 LeetCode 系列，Container With Most Water，屬於 Medium\n原始題目 Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai).\nn vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0).\nFind two lines, which, together with the x-axis forms a container, such that the container contains the most water.\nNotice that you may not slant the container.\nExample:\nInput: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Input: height = [1,1] Output: 1 Input: height = [4,3,2,1,4] Output: 16 Input: height = [1,2,1] Output: 2 題目分析  輸入 height 是一串正整數，代表木板高度 找出中間面積最大的兩個數字（容納最多水）  解題過程 這題難在找出中間邏輯，運算本身並不難\n使用雙指針這個方法，從頭尾向內夾找出最大值\n第一指針 p1 理所當然就是陣列初始鍵值 0，第二指針 p2 則是陣列最後一個鍵值\n又因為陣列鍵值是從 0 開始，所以是 陣列長度 - 1\n使用 while 迴圈，因為鍵值交叉後算出來的結果會和先前重複，所以不需要計算\n計算當前兩個指針之間的面積 $area，如果當前面積大於原先最大面積，則設定新最大面積\n因為最大容量是用比較短的一端決定，且向內移動勢必讓寬度下降，若兩端高度不變則面積也會變小\n所以比較兩個指針在陣列中的長度，長度較短的指針向中心移動\n在這個邏輯下，若指針向內移動找到更長的一端，面積才有變大的可能！\nclass Solution { /** * @param Integer[] $height * @return Integer */ function maxArea($height) { $p1 = 0; $p2 = count($height) - 1; $max_area = 0; while($p1 \u0026lt; $p2){ $area = ($p2 - $p1) * min($height[$p1], $height[$p2]); if ($area \u0026gt; $max_area) { $max_area = $area; } if($height[$p1] \u0026lt; $height[$p2]) { $p1++; } else { $p2--; } } return $max_area; } } 結果 ",
    "ref": "/blog/202105-leetcode-no11-container-with-most-water/"
  },{
    "title": "[LeetCode] #540 Single Element in a Sorted Array (Medium)",
    "date": "",
    "description": "LeetCode 第 540 題 Single Element in a Sorted Array，難度 Medium",
    "body": "用 PHP 解 LeetCode 系列，Single Element in a Sorted Array，屬於 Medium\n原始題目 You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.\nFollow up: Your solution should run in O(log n) time and O(1) space.\nExample:\nInput: nums = [1,1,2,3,3,4,4,8,8] Output: 2 Input: nums = [3,3,7,7,10,11,11] Output: 10 題目分析  一個排序過的純整數陣列，其中除了一個數字外，其他數字都是兩兩一組 找出落單的那個整數  解題過程 第一種是用 for 迴圈的做法\n因為陣列為排序好的內容，且只有一個數字單一出現\n所以可以使用 for 迴圈，每次計數器 +2 然後和下一個數字比較。例如 n+1 數字等於 n，則判斷 n+2 和 n+3 是否相等\n若不相等代表該數字只出現一次\n另一種做法是用 foreach 迴圈\n判斷所當前數字和下一個數字相等，則記錄在陣列中\n若當前數字不等於下一個數字，則和陣列比對\n若數字也不在陣列紀錄中，則代表該數字和下一位數不相等，且尚未出現過！\n依據題目規則，可以判斷是唯一數字\n我覺得這種做法比較有彈性\n萬一之後變成有數字會出現兩次以上，或是不只一個數字只出現一次的情況下程式也不需大量調整\n故最後採用第二種方法\nclass Solution { /** * @param Integer[] $nums * @return Integer */ function singleNonDuplicate($nums) { $skip = []; foreach($nums as $key =\u0026gt; $num) { if (isset($nums[$key + 1]) \u0026amp;\u0026amp; $num == $nums[$key + 1]) { $skip[] = $num; } elseif( ! in_array($num, $skip)) { return $num; } } } } 結果 ",
    "ref": "/blog/202105-leetcode-no540-single-element-in-a-sorted-array/"
  },{
    "title": "[LeetCode] #791 Custom Sort String (Medium)",
    "date": "",
    "description": "LeetCode 第 791 題 Custom Sort String，難度 Medium",
    "body": "用 PHP 解 LeetCode 系列，Custom Sort String，屬於 Medium\n原始題目 order and str are strings composed of lowercase letters. In order, no letter occurs more than once.\norder was sorted in some custom order previously. We want to permute the characters of str so that they match the order that order was sorted.\nMore specifically, if x occurs before y in order, then x should occur before y in the returned string.\nReturn any permutation of str (as a string) that satisfies this property.\nNote:\n order has length at most 26, and no character is repeated in order. str has length at most 200. order and str consist of lowercase letters only.  Example:\nInput: order = \u0026#34;cba\u0026#34; str = \u0026#34;abcd\u0026#34; Output: \u0026#34;cbad\u0026#34; Explanation: \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; appear in order, so the order of \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; should be \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, and \u0026#34;a\u0026#34;. Since \u0026#34;d\u0026#34; does not appear in order, it can be at any position in the returned string. \u0026#34;dcba\u0026#34;, \u0026#34;cdba\u0026#34;, \u0026#34;cbda\u0026#34; are also valid outputs. 題目分析  order 指定了特定字母之間的順序 輸入的 str 如果包含 order 的字母，則要照順序排列 不在 order 中的剩餘字母則直接接到整理好的字串後面後回傳  解題過程 看起來很簡單，但是實際開始解才發現要考慮的細節很多！\n第一次解題看到範例輸入的 order = \u0026quot;cba\u0026quot;, str = \u0026quot;abcd\u0026quot;\n直覺就是把 order 遍歷一遍，找尋每一個字母有沒有出現在 str 裡面？\n有的話存進結果字串，並且從 str 字串中移除該字母\n最後再將 str 剩下的字母，也就是不在 order 字串中的字母們補上\n這樣的確可以完成這個 testcase 的預期結果 Output = \u0026quot;cbad\u0026quot;\n下一組輸入是 order = \u0026quot;cbafg\u0026quot;, str = \u0026quot;abcd\u0026quot;，並期望得到 Output = \u0026quot;cbad\u0026quot; 也通過了\nclass Solution { /** * @param String $order * @param String $str * @return String */ function customSortString($order, $str) { $order_array = str_split($order); $str_array = str_split($str); foreach($order_array as $char) { $key = array_search($char, $str_array); if ( ! ($key == false)) { $result .= $char; unset($str_array[$key]); } } $result .= implode(\u0026#39;\u0026#39;, $str_array); return $result; } } 事情沒有這麼簡單！下一組輸入是 order = \u0026quot;kqep\u0026quot;, str = \u0026quot;pekeq\u0026quot;，期望得到 Output = \u0026quot;kqeep\u0026quot;\n但是依照這個邏輯我們回傳了 Output = \u0026quot;kqepe\u0026quot;，因為 str 中 e 出現了兩次！\n而我們遍歷的 order 只有一個 e\n如此遍歷 order 是不可行了，題目說 order 每個字母最多出現一次，於是轉換思路改為遍歷輸入字串 str\n 首先遍歷輸入字串 str 判斷當前字母是不是存在 order 字串中 若有則存入一個二維陣列，該陣列的第一維是該字母在 order 字串中的位置\n使用二維陣列是為了處理 str 字串中字母重複出現的情境 若該字母不存在 order 中，則存入剩餘字串的變數中 將剛剛的二維陣列依照第一維的值(在 order 中的順序)排序，由小到大(必須保留鍵值) 遍歷二維陣列的每一組字母集合，將其串成字串，並串上剩餘字串  於是這個 testcase 就通過了！以下是完成之後的完整程式碼\nclass Solution { /** * @param String $order * @param String $str * @return String */ function customSortString($order, $str) { $order_array = str_split($order); $str_array = str_split($str); $result_array = []; $result = \u0026#39;\u0026#39;; $else_char = \u0026#39;\u0026#39;; foreach($str_array as $char) { if (in_array($char, $order_array)) { $key = array_search($char, $order_array); $result_array[$key][] = $char; } else { $else_char .= $char; } } ksort($result_array); foreach ($result_array as $char_nub) { $result .= implode($char_nub); } $result .= $else_char; return $result; } } 結果 ",
    "ref": "/blog/202105-leetcode-no791-custom-sort-string/"
  },{
    "title": "網頁伺服器壓力測試 - 使用 Apache Bench",
    "date": "",
    "description": "使用 Apache Bench 對網頁伺服器做壓力測試，測試伺服器性能",
    "body": "MacOS 預設已經安裝了 Apache Bench 又簡稱為 ab，是 Apache 開發的其中一個開源測試工具\n主要用來測試網站或 API 的伺服器執行效能，並查看執行後伺服器的性能測試結果\nApache Bench 介紹 可以使用 ab \u0026lt;url\u0026gt; 開始對某一網址做測試，有很多參數可以使用\n常用參數 使用 ab -h 指令可以看到\nUsage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform -c concurrency Number of multiple requests to make at a time -t timelimit Seconds to max. to spend on benchmarking This implies -n 50000 -s timeout Seconds to max. wait for each response Default is 30 seconds -b windowsize Size of TCP send/receive buffer, in bytes -B address Address to bind to when making outgoing connections -p postfile File containing data to POST. Remember also to set -T -u putfile File containing data to PUT. Remember also to set -T -T content-type Content-type header to use for POST/PUT data, eg. \u0026#39;application/x-www-form-urlencoded\u0026#39; Default is \u0026#39;text/plain\u0026#39; -v verbosity How much troubleshooting info to print -w Print out results in HTML tables -i Use HEAD instead of GET -x attributes String to insert as table attributes -y attributes String to insert as tr attributes -z attributes String to insert as td or th attributes -C attribute Add cookie, eg. \u0026#39;Apache=1234\u0026#39;. (repeatable) -H attribute Add Arbitrary header line, eg. \u0026#39;Accept-Encoding: gzip\u0026#39; Inserted after all normal header lines. (repeatable) -A attribute Add Basic WWW Authentication, the attributes are a colon separated username and password. -P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password. -X proxy:port Proxyserver and port number to use -V Print version number and exit -k Use HTTP KeepAlive feature -d Do not show percentiles served table. -S Do not show confidence estimators and warnings. -q Do not show progress when doing more than 150 requests -l Accept variable document length (use this for dynamic pages) -g filename Output collected data to gnuplot format file. -e filename Output CSV file with percentages served -r Don\u0026#39;t exit on socket receive errors. -m method Method name -h Display usage information (this message) -I Disable TLS Server Name Indication (SNI) extension -Z ciphersuite Specify SSL/TLS cipher suite (See openssl ciphers) -f protocol Specify SSL/TLS protocol (TLS1, TLS1.1, TLS1.2 or ALL) -E certfile Specify optional client certificate chain and private key 比較常用的參數是\n -n：測試時執行的 request 數量，預設為1 -c：一次執行下同時的 request 數量，模擬同時在線使用者數，預設為1 -e output.csv：將測試的效能原始資料匯出成叫做 output.csv 的 CSV 檔  參考來源：The Will Will Web - 使用 ApacheBench 進行網站的壓力測試  調整 php-fpm 參數 參數設定參考：kejyun/ubuntu-learning-notes  docker 進到 php-fpm 的容器裡面\n可以找到 /usr/local/etc/php-fpm.d/www.conf 設定檔\n就像 nginx config 檔案一樣，可以從外部調整後掛載進來\n範例文章：Linux、nginx、php-fpm 連線數優化  ",
    "ref": "/blog/202105-web-server-stress-testing/"
  },{
    "title": "[LeetCode] #1833 Maximum Ice Cream Bars (Medium)",
    "date": "",
    "description": "LeetCode 第 1833 題 Maximum Ice Cream Bars，難度 Medium",
    "body": "用 PHP 解 LeetCode 系列，Maximum Ice Cream Bars，屬於 Medium\n原始題目 It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nNote: The boy can buy the ice cream bars in any order.\nExample:\nInput: costs = [1,3,2,4,1], coins = 7 Output: 4 Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7. Input: costs = [10,6,8,7,7,8], coins = 5 Output: 0 Explanation: The boy cannot afford any of the ice cream bars. Input: costs = [1,6,3,1,2,5], coins = 20 Output: 6 Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18. 題目分析  輸入所有冰淇淋的價錢列表 costs，以及男孩擁有的所有錢 coins 計算男孩最多可以買幾支冰淇淋  解題過程 這邊採用所謂的：貪婪演算法  ，理論上能買最多冰淇淋的情況下就是全部買便宜的\n所以先對輸入的冰淇淋價錢列表 costs 做排序，排序完之後就是簡單的計算\n當剩餘的錢比冰淇淋多，可購買冰淇淋數量就 +1，並且扣掉買冰的錢\n一般會做 coins \u0026gt;= 0 的判斷\n如果金額小於等於 0，合理推斷他不可能再買任何冰淇淋\n但是這樣會多一個判斷式，執行時間和記憶體用量反而會上升\n原本以為用 break 終止迴圈會更省資源的！\n在一般情況下也不可能存在價錢是負數的冰淇淋，所以就不做剩餘金額判斷\n如果不是特別要跑數字還是應該加一下，比較安全\nclass Solution { /** * @param Integer[] $costs * @param Integer $coins * @return Integer */ function maxIceCream($costs, $coins) { sort($costs); $ice_cream_num = 0; foreach($costs as $cost) { if($coins \u0026gt;= $cost) { $ice_cream_num += 1; $coins -= $cost; } } return $ice_cream_num; } } 結果 ",
    "ref": "/blog/202105-leetcode-no1833-maximum-ice-cream-bars/"
  },{
    "title": "[LeetCode] #1732 Find the Highest Altitude (Easy)",
    "date": "",
    "description": "LeetCode 第 1732 題 Find the Highest Altitude，難度 Easy",
    "body": "用 PHP 解 LeetCode 系列，Find the Highest Altitude，屬於 Easy\n原始題目 There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes.\nThe biker starts his trip on point 0 with altitude equal 0.\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i and i + 1 for all (0 \u0026lt;= i \u0026lt; n).\nReturn the highest altitude of a point.\nExample:\nInput: gain = [-5,1,5,0,-7] Output: 1 Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1. Input: gain = [-4,-3,-2,-1,4,3,2] Output: 0 Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0. 題目分析  輸入一個陣列，代表一個自行車手的海拔變化。從 0 開始騎 每一個點代表和前一個點的海拔「差距」 回傳最高海拔的點  解題過程 用差異計算出當前的真實海拔存進陣列\n再取出最大值，有想過把海拔全部存進陣列，再用 max 函數\n但是想想這樣有點偷懶，而且用陣列儲存後用函式判斷對記憶體負擔可能比較大\n最後改成用單一變數去紀錄最高海拔\nclass Solution { /** * @param Integer[] $gain * @return Integer */ function largestAltitude($gain) { $current_altitude = 0; $max = 0; foreach($gain as $k =\u0026gt; $v) { $current_altitude += $v; if ($current_altitude \u0026gt; $max) { $max = $current_altitude; } } return $max; } } 結果 ",
    "ref": "/blog/202105-leetcode-no1732-find-the-highest-altitude/"
  },{
    "title": "[LeetCode] #1 Two Sum (Easy)",
    "date": "",
    "description": "LeetCode 第 1 題 Two Sum，難度 Easy",
    "body": "用 PHP 解 LeetCode 系列，這次是經典題目 Two Sum，屬於 Easy\n原始題目 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample:\nInput: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1]. Input: nums = [3,2,4], target = 6 Output: [1,2] Input: nums = [3,3], target = 6 Output: [0,1] 題目分析  輸入一個還有多個數字的陣列，以及預期數字 找出陣列中兩數和等於預期數字的值，並用陣列方式回傳兩個數字在陣列中的鍵值  解題過程 直覺的暴力解是兩個迴圈嵌套，類似九九乘法的做法。但是這麼做時間複雜度會很高\n並且內層迴圈會重複遍歷當前鍵值的數字，每次外層迴圈都要先建立新的內層陣列物件才能比對\n對記憶體使用也會增加\n最終使用一次迴圈的解決方案\n遍歷傳入的陣列，比對 target 減掉當前數字的差值是否存在陣列剩餘的數字中\n為什麼說是 剩餘 的數字中呢？先看完程式碼再繼續說明\nclass Solution { /** * @param Integer[] $nums * @param Integer $target * @return Integer[] */ function twoSum($nums, $target) { foreach ($nums as $k1 =\u0026gt; $v1) { unset($nums[$k1]); if ($k2 = array_search($target - $v1, $nums)) { return [$k1, $k2]; } } return []; } } 如果不使用 unset 永久把數字從陣列排除掉\nunset($nums[$k1]); 在輸入 inpout = [3, 3], target = 6，預期結果為 [0, 1] 的時候\n會因為 array_search 在查詢值等於 3 (6 - 3) 的數字的時候，因為第一個數字就是 3\n而造成 $k2 = 0 而輸出 [0, 0]！\n",
    "ref": "/blog/202105-leetcode-no1-two-sum/"
  },{
    "title": "透過 Cloudflare 設定子網域，並客製 GitHub Page 網址",
    "date": "",
    "description": "購買網址後可設定子網域給不同網站使用，本篇以 Cloudflare + GitHub Page 靜態網站為例",
    "body": "之前已經買好了自己的網址，接著要利用 Cloudflare DNS 服務建立子網域\n並且設定給指定的 GitHub Page 專案作為客製網址\n學會這項技能之後，只要有一組主要網址，就可以根據需求產生不同的子網域網址\n各家 DNS 服務提供商都有這個功能，本篇以 Cloudflare 為例\n1. 設定子網域 前往 cloudflare 管理後台，點選 DNS 頁籤\n建立 DNS 紀錄，選擇類型是 CNAME，並指向自己的網域\n2. 設定 GitHub Page CNAME 在靜態網站的根目錄下建立一個檔名為 CNAME 的檔案，並上傳至 GitHub\n內容為子域名的完整網址，像我就是 tech.ray247k.com\n3. 設定 GitHub Page 網址 前往專案 Settings \u0026gt; Pages 頁籤中 Custom domain 區塊\n貼上剛剛在 cloudflare DNS 加入且上傳到專案 CNAME 檔案中的完整網址\n如此就完成了在 cloudflare 建立子網域，並自訂 GitHub Page 的網址\n",
    "ref": "/blog/202105-set-custom-domain-for-github-page/"
  },{
    "title": "設定 Cloudflare 免費 CDN，並啟用 DNS 代管",
    "date": "",
    "description": "從 Google Domains 把 DNS 代管交給 Cloudflare 管理",
    "body": "Google Domains 服務原本就有網域名稱伺服器(Domain Name System, DNS)服務\n透過 DNS 可以管理你的域名，加子網域什麼的\n之所以會把 DNS 轉到 Cloudflare 是因為要用到 Cloudflare 提供的 CND (Content Delivery Network) 以及快取\n如此可以增加網站的載入速度，節省伺服器資源。雖然我用的是 GitHub Page，伺服器資源不用在意\n之後再寫一篇來說明怎麼設定子網域並且設定給 GitHub Page\n有這項技能你只要有一個網域，就可以一直生出新的網址囉！\n就像我買的 ray247k.com，這個部落格的網址是 tech.ray247k.com  就是子網域的應用\n所以一開始才選擇 .com 的頂級網域，而不是 .dev\n設定 cloudflare 代管子網域和 DNS 1. 註冊 cloudflar 沒什麼難度，就照著網站流程註冊就好\n2. 跟著 cloudflare 引導加入網站(Domain) 把之前買的網址加入管理列表\n3. 調整 DNS 伺服器 加入網站後我們會在 cloudflare 看到這個提示\n接著去 Google Domain 那邊 DNS 的頁籤畫面\n可以看到預設的 DNS 是上一步驟中 cloudflare 叫我們移除的 DNS 伺服器\n點「使用自訂名稱伺服器」換成他給的兩個網址即可\n4. 收到信通知網站 cloudflare 已經啟用 5. 啟用一律使用 HTTPS 將所有透過「http」協定的所有請求重新導向至「https」\n因為 cloudflare 有預設的 SSL/TLS 憑證，並不用自己購買就可以開啟 https\n如此在瀏覽器網址最前面有「鎖頭」顯示為安全的連線！\n我們只需要做去啟用重新導向的服務\n前往SSL/TLS 頁籤，往下滑看到「一律使用HTTPS」把他點成開啟，然後等待陣子讓設定生效\n啟用之後，就算你使用 http 造訪網頁也會自動導轉到 https 開頭的網頁囉！\n",
    "ref": "/blog/202105-cloudflare-dns-add-domain/"
  },{
    "title": "如何從 Google Domains 購買屬於自己的網址",
    "date": "",
    "description": "購買屬於自己的網址 - 使用Google Domains 教學",
    "body": "以前都一直是使用免費的部落(blogger)，隨著近幾年個人品牌意識崛起，以及覺得原本部落格不敷使用\n且搬家非常不方便，還有不能自訂 SEO 和埋設追蹤碼。在媒體業做過就會想自己動手處理這些\n當初一度從 blogger 搬到 medium，又搬回 blogger轉移十分麻煩\n而且還有程式碼內容格式會跑掉，以及想都用 markdown 語法紀錄等等原因\n興起了自架的想法，一方面也是想要作為展現自己的能力的平台\n最終決定使用 Hugo  這套框架來自架部落格\n想好了要自架之後面臨有好幾個選項，直接架在 github page 並使用預設的網址看來很方便，而且也沒什麼缺點\n不過就是想要有個「自己的」感覺，不寄人籬下。未來萬一又不自架了，網址的 SEO 是自己可以帶著走的\n前言說到這，來開始買網址\ngoogle domain 網址可以在很多地方買到，從最有名的 Godaddy 到最不推薦的 PChome\n這次選擇 Google Domains 這個服務，主要就是想嚐鮮，試試看別人沒用過的服務\n並且 Godaddy 第一年雖然便宜，但是第二年價錢調漲之後反而不如 Google Domains 每年固定的價錢\n當然也可以第一年買 Godaddy，快到期再轉移到 Google Domains。這樣似乎是最便宜的做法\n但是我懶得轉換，不想要未來為了轉換多花心思\n1. 查詢想買的網址有沒有被註冊 前往：Google Domains  查詢你想買的網址\n以我現在使用的網址為例，可以看到不同頂級網域會有不同價錢\n選擇你喜且順眼的，不建議使用太奇怪的名稱\n開發者的話，可以考慮看看 Google Domains 獨家販賣的 .dev！\n但是因為我是要多個站用子域名共用的（之後會有發一篇教手把手教學），不一定全部是面向開發者\n所以最後還是選擇了每年固定 12 美金的 .com 的域名\n不要因為一時的中二病讓自己的網站變成黑歷史！但是我承認我有查奇怪的名稱，例如 .in 這個頂級域名\n教練！我好想要 gg.in.in這個網址，但是我真的只有查而已，信我！因為 in.in 不給買\n2. 前往購物車準備結帳 就跟著網站步驟輸入資料＋按下一步，最好都照實填寫\n畢竟是自己個人品牌用的網域，真的出問題還是要能連絡上比較好\n隱私保護服務也要啟用，這服務在 Godaddy 可是要收錢的呢！\n ╰(⊙Д⊙)╮佛心公司╭(⊙Д⊙)╯\n╭(⊙-⊙)╯佛心公司╰(⊙-⊙)╮\n 建議開啟自動續約功能，否則要是突然某一天網址沒續約不能使用導致網站連不上可就麻煩了\n之前某科技內容網站就因為沒續約，網站一整個早上無法造訪\n一開始以為是程式部署出問題，查了半天發現是網址到期沒續約而鬧了笑話\nGoogle Domains 的結帳頁面好像有改版過\n我看網路其他文章，在最後輸入信用卡號的時後都是輸入完卡號就直接送出結帳\n而我是遇到他要我輸入卡號外還要輸入 zip code，而且必須是美國的格式\n如果你們也有遇到需要輸入 zip code 的情況\n我是使用 90004，這是一個 Los Angeles\tLos Angeles\tCalifornia (CA) 的郵遞區號\n結帳完成之後應該就會收到信告訴你可以開始使用剛剛買到的網址囉！\n其他關於怎麼設定 Github Page 自訂網址，和使用 cloudflare 管理子網域就留在之後的文章說明了\n",
    "ref": "/blog/202105-how-to-buy-a-domain-from-google/"
  },{
    "title": "設定 ssh 金鑰登入遠端主機",
    "date": "",
    "description": "使用 ssh key 登入遠端主機而不使用密碼登入",
    "body": "一般登入伺服器是使用帳號與密碼進行登入，但是密碼可能會因為抄錄或是傳遞給人而外洩\n安全性的程度會比較沒有像SSH key 那麼安全，而且使用SSH key 登入可以就不用每次手動輸入密碼\n建立登入端的 ssh key 使用者端建立 ssh key，使用指令 ssh-keygen  注意：ssh key 要是 RSA 的格式，如果是 OPENSSH 會不斷的報錯\n參考資料：mac majave 10.14.1 ssh-keygen 金鑰格式問題   預設會產生在 .ssh/ 路徑下\n如果是用複製別人的 id_rsa 和 id_rsa.pub 的話需要重新設定權限，否則會報錯\nchmod 600 id_rsa chmod 644 id_rsa.pub 權限說明 -rw------- (600) -- 只有屬主有讀寫權限。 -rw-r--r-- (644) -- 只有屬主有讀寫權限；而屬組用戶和其他用戶只有讀權限。 -rwx------ (700) -- 只有屬主有讀、寫、執行權限。 -rwxr-xr-x (755) -- 屬主有讀、寫、執行權限；而屬組用戶和其他用戶只有讀、執行權限。 -rwx--x--x (711) -- 屬主有讀、寫、執行權限；而屬組用戶和其他用戶只有執行權限。 -rw-rw-rw- (666) -- 所有用戶都有文件讀、寫權限。這種做法不可取。 -rwxrwxrwx (777) -- 所有用戶都有讀、寫、執行權限。更不可取的做法。 以下是對目錄的兩個普通設定： drwx------ (700) - 只有擁有者可在目錄中讀、寫。 drwxr-xr-x (755) - 所有用戶可讀該目錄，但只有擁有者才能改變目錄中的內容 遠端主機設定 登入遠端主機之後，檢查使用者家目錄是否存在 ./ssh/authorized_keys 檔案\n若沒有則自行建立，並設定權限 chmod 600 authorized_keys\n檔案內容為剛剛產生的 id_res.pub 的內容\n範例：\nssh-rsa AABAB3NzaC1yc2Gmy80/{...中略...}/UD9CBSzNAya7r6w== 補充 讓雲端主機可以存取版本庫  建立 GCP 使用者後，依照上面做法產生 ssh key 把 public key 加到版本庫的 ssh key 列表中 ",
    "ref": "/blog/202104-use-ssh-key-login-remote-server/"
  },{
    "title": "雲端主機啟動 Docker 服務",
    "date": "",
    "description": "介紹如何在雲端主機啟用 docker 服務",
    "body": "新開主機啟用 docker 與 docker-compose 服務的操作步驟\n安裝 Docker sudo apt-get install docker.io sudo apt install docker.io 將使用者加入群組 此操作可以讓使用者不需要 sudo 就執行 docker 指令，為非必要步驟\nsudo usermod -a -G docker {ec2-user} ref: Ubuntu Linux 安裝 Docker 步驟與使用教學  也有人直接將使用者加入 sudoer 群組中，有一樣的結果\n安裝 docker-compose sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose ref: Install Docker Compose   如此就可以在新開的雲端主機進行 Docker 容器的操作\n",
    "ref": "/blog/202103-enable-docker-service-in-remote-server/"
  },{
    "title": "PostgreSQL 資料庫建置 - 使用 Docker",
    "date": "",
    "description": "介紹如何使用 Docker 建置 PostgreSQL 資料庫",
    "body": "使用 Docker 來建置一個 PostgreSQL 資料庫\n包含 資料庫建置、資料持久化、使用 GUI 操作資料庫\nPostgreSQL 基礎教學：後端前進PostgreSQL 系列  環境建置 - 使用 Docker-compose 使用的映像檔：postgres: alpine  參考文章：Getting Started with PostgreSQL using Docker-Compose  docker-compose.yml version: \u0026#39;3\u0026#39; services: postgres: container_name: postgres ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:alpine\u0026#34; volumes: - database-data:/var/lib/postgresql/data # persist data even if container shuts down restart: always environment: POSTGRES_USER: superuser POSTGRES_PASSWORD: superpassword POSTGRES_DB: demo_db volumes: database-data: # named volumes can be managed easier using docker-compose 啟動容器：\ndocker-compose up  GUI 安裝 因為 sequel ace 不支援 PostgreSQL 所以另外裝一個 GUI 來用\n安裝 DBeaver  會需要安裝 JAVA 包\nbrew install --cask dbeaver-community 存取在遠端的 PostgreSQL container 取得該遠端的對外 ip 作為 host 之後連線到指定的 port (5432)\n就可以在其他機器上存取 PostgreSQL container\n 資料持久化 (persist data) 官方文件說明  使用docker-compose啟動服務時，初始化資料庫和資料(以Mysql為例)  Different Types of Volumes  named volume：  docker-compose up 啟動容器 docker volume ls 確認有建立 volume docker-compose stop 停止容器 docker-compose up，使用 GUI 連線容器確認資料有被重新掛載 docker-compose down，移除容器 docker ps -a 確認容器確實被移除 docker-compose up，volume 成功掛載回去  host volume 調整容器內 volume 目標資料夾位置到本機特定資料夾下\n如果有多台容器需要一起掛載同一份資料：官方文件  這個做法使用 docker volume ls 就不會有結果，要自己去看指定的路徑。因為管理 volume 已經不是透過 docker\nversion: \u0026#39;3\u0026#39; services: postgres: container_name: postgres ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:alpine\u0026#34; volumes: - ./database_data:/var/lib/postgresql/data # persist data even if container shuts down restart: always environment: POSTGRES_USER: superuser POSTGRES_PASSWORD: superpassword POSTGRES_DB: trp  調整 yml 檔 service 內 volumes，改為指定路徑 docker-compose up 啟動容器 使用路徑管理 volume 後 docker volume ls 不會有反應 查看指定路徑 ./database_data，volume 檔案成功寫入 docker-compose up，使用 GUI 連線容器確認資料有被重新掛載 docker-compose down，用 docker ps -a 確認 container 確實被移除 docker-compose up，volume 成功掛載回去  補充 如果在同一台機器上想要啟用多個 PostgreSQL 容器\n則 5432 port 會被佔用，當然可以將外部 port 改為不衝突的 port\n但是內部 port 使用的依然是 5432 如果在容器網路內直接溝通，例如 Laravel 的 .env 設定的 port\n當透過容器外部網路線連線時使用調整後錯開的 port 連線正常\n但是當執行 php artisan migrate 之類指令，執行者是容器時\n要使用的卻是內部的 5432 port，如此在管理上會十分麻煩\n此情境下可以透啟動容器時指定內部運行的 port 來解決\npostgre: container_name: trp_stage_postgre ports: - \u0026#34;5430:5430\u0026#34; image: \u0026#34;postgres:12.6\u0026#34; volumes: - /trp/database/stage/database_data:/var/lib/postgresql/data # persist data even if container shuts down command: -p 5430 environment: POSTGRES_USER: ${TRP_DB_USER} POSTGRES_PASSWORD: ${TRP_DB_PASSWORD} POSTGRES_DB: ${TRP_DB_NAME} restart: always 如上面的設定中 command: -p 5430 指定了內部 postgres 使用的 port\n所以在 ports: 設定中就直接將外部 port 5430 指定給內部的 port 5430\n這樣不管在容器內或外部都可以使用一樣的 port 來進行連線\n使用 GUI 存取在遠端的 PostgreSQL container 取得該遠端的對外 ip 作為 host 之後連線到指定的 port (5432)\n就可以在其他機器上存取 PostgreSQL container\n",
    "ref": "/blog/202103-build-postgresql-database-useing-docker/"
  },{
    "title": "反向代理 - 在 Docker 環境建置",
    "date": "",
    "description": "介紹基本反向代理以及在 Docker 環境中建置",
    "body": "反向代理的基本說明，以及在 Docker 容器中如何建立反向代理\n反向代理 系統設計 - 正向代理跟反向代理  不同實體主機 使用 nginx proxy-pass 目標  使用者造訪指定網頁路徑 /new_path 或是整個跳轉 / 設定測試機 nginx proxy_pass 使其跳轉到其他主機專案相同路徑下 確認使用者 IP 沒有被變成為代理伺服器的 IP 確認在代理目標的專案可以讀取 Cookie 確認 Post 請求的 payload 也會被轉送過去  設定 nginx config 第一台主機的 nginx 設定 # 把所有前往 domain/new_path 的請求反向代理到另一台主機上 location /new_path { # 要代理到哪個網址 proxy_pass http://laravel55.test.com; # 傳送使用者真實 IP 到目標主機 proxy_set_header X-Real-IP $remote_addr; # 設定伺服器為代理前的伺服器，否則 HTTP_HOST 會變成 proxy 那台代理伺服器的位址 proxy_set_header Host $host; # 設定 cookie 轉發 proxy_set_header Cookie $http_cookie; # 用來確認最初的用戶端原始 ip 位置 proxy_set_header X-Forwarded-Host $host; # 記錄從使用者端出來經過的每個代理 X-Forwarded-For: \u0026lt;client\u0026gt;, \u0026lt;proxy1\u0026gt;, \u0026lt;proxy2\u0026gt; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 識別網路連線協定 proxy_set_header X-Forwarded-Proto $scheme; # 隱藏伺服器資訊 proxy_hide_header Server; proxy_hide_header X-Powered-By; # 因為自行加大 header 所以把空間也加大 proxy_headers_hash_bucket_size 128; proxy_headers_hash_max_size 512; } 第二台主機的 nginx 設定 server { listen 80; server_name ray200; root /home/toc/www/laravel55/public; access_log /var/log/nginx/www/laravel55.access.log; error_log /var/log/nginx/www/laravel55.error.log; index index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~* \\.(jpg|jpeg|gif|css|png|js|ico|html|svg|ttf|woff|woff2|eotD)$ { access_log off; expires max; } location ~ \\.php$ { include snippets/fastcgi-php.conf; # php-fpm 的位置 fastcgi_pass 127.0.0.1:9000; } } 注意事項  server_name 必須要是 proxy_pass 過來那台的 domain，如果不這樣設定，proxy_pass 過來會進到預設的 server_name 下 在程式中判斷真實 IP 的方法要改成讀讀取 header 中的 x-real-ip 才是真實使用者 ip 位置  確認 cookie 可以讀取 如果設定 nginx 有設定 proxy_set_header Cookie $http_cookie;\n那 dump($_COOKIE); 可以取得 cookie，但是 Laravel 內建的 request()-\u0026gt;cookie(); 卻沒有取到值\n解決方案 Laravel 預設的 web middleware \\App\\Http\\Middleware\\EncryptCookies::class, 會要求 cookie 是加密過後的，如果沒有加密當然就讀不到。\n解決方案一個是在 EncryptCookies 這個 class 中的 $except 加入要排除的 cookie 名稱，另一個就是直接把 middleware 註解掉。\n 使用 Docker 架構示意圖 參考資料：How to set up NGINX Docker Reverse Proxy?  步驟 1. 手動建立 network  反向代理會根據載入的設定檔把請求導向到指定的容器名稱內\n故代理的目標容器必須在同一網路內，才能直接使用容器名稱做代理目標\n 因為不想讓 network 前面帶上 prefix，還有避免依賴，所以手動建立 network\ndocker network create nginx-network 這個情境屬於來自外部的 nginx-proxy，要多給一個 external network 有需要連接到這個 network 裡面的服務都要設定\nnetworks: default: external: name: nginx-network 如此就可以讓不同 docker-compose.yml 中的服務互相溝通：官方說明  2. 建立測試用的服務 因為懶得建太複雜的服務，所以抓現成的 portainer 服務來做為 proxy 的目標\n只是為了要有一個只要 docker-compose up 就可以運行的服務，也可以換成自己比較熟的映像檔\n為了測試從 80 port poxy 到其他 port，所以這邊開在 8080 port\n服務啟動之後可以先去 localhost:8080 查看 portainer 服務有沒有啟動\nversion: '3' networks: default: external: name: nginx-network services: portainer: container_name: nginx_test_portainer image: portainer/portainer-ce command: -H unix:///var/run/docker.sock restart: always ports: - 8080:9000 volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data volumes: portainer_data: 3. Nginx 的 proxy 設定 3.1 設定 docker-compose.yml version: '3' networks: default: external: name: nginx-network services: nginx: container_name: test_nginx image: nginx:1.18 ports: - \u0026quot;80:80\u0026quot; - \u0026quot;443:443\u0026quot; volumes: - ./conf.d/:/etc/nginx/conf.d/ - ./ssl/:/ssl/ 3.2 設定 mount 進去給反向代理伺服器使用的 nginx config 可以看到底下設定中，我們把所有發往 test.example 網址的請求都轉到\nhttp://nginx_test_portainer:9000 在容器中使用的模式是\n http://{container_name}:{port}\n 可以看到 container_name 對應了上面建立測試服務  時候使用的容器名稱\n而 port 對應到了容器的內部 port！\n這邊特別把上面的容器內外使用的 port 區隔開來顯示差別，我們代理的目標是內部的 9000 port\n而不是對外的 8080 port\nserver { listen 80; listen [::]:80; server_name test.example; return 301 https://$host$request_uri; } server { listen 443 ssl; listen [::]:443 ssl; server_name test.example; ssl_certificate /ssl/ssl.crt; ssl_certificate_key /ssl/ssl.key; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { proxy_set_header Host $host; proxy_set_header Cookie $http_cookie; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $host; proxy_pass http://trp_portainer:9000; } } 要特別注意的是，這邊 proxy_pass 的目標網址中，http:// 不可以省略\n如果轉址過去的網址有自己的 https 證書驗證(例如另一個 nginx 環境)，則必須改成 https:// 開頭\n參考資料：What value should I use for Nginx proxy_pass running in Docker?  3.3 編輯 etc/hosts 127.0.0.1 test.example 接著啟動 nginx 服務，用瀏覽器開啟剛剛設定的 test.example\n正確設定的話，監聽 80 port 的 nginx 服務應該會把所有目標是 test.example 的請求利用 proxy_pass 送到 portainer 容器的指定 port\n所以畫面上會顯示 portainer 服務的畫面\n 要在所有服務都啟動之後再啟動反向代理服務，否則會報錯指出被代理的容器目標不存在\n 注意事項 如果要把全部沒有匹配到的 server_name 請求統一處理\n可以在指定的 nginx config 加上 default_server 定義\n如果沒有定義 default_server，則第一個 server 會被預設成 default server \nserver { listen 8080 ssl default_server; listen [::]:8080 ssl default_server; ssl_certificate /ssl/ssl.crt; ssl_certificate_key /ssl/ssl.key; # Virtual Host Domain server_name _; # where code is root /var/trp/dev/www/trp_backend/public; index index.php index.html index.htm; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri /index.php =404; fastcgi_pass trp_dev_php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ /\\.ht { deny all; } } 因為要處理沒有被其他 server_name 捕獲的請求\n所以 server_name 就不是什麼重點，可以用 _, __, ___ 都可以\n這個情境會發生在當前端的 API 設定檔使用的路徑網址是指定後端容器名稱的時候 因為不是使用網址經過反向代理轉發，而是直接將請求發至容器\n而這個 nginx 容器中又有多個 server config 設定\n所以 nginx 沒有 server_name 可以判斷要使用哪個 config 設定\n案例說明 同一個 nginx 容器(dev_nginx) 裡面有多個 server config\n alex_backend john_backend dev_backend  如果現在有一個在同樣 docker network 的前端容器要打 API 到 dev_backend\n他會在設定檔指定網址是 dev_nginx\n這時候問題就來了，當 dev_nginx 收到這個請求會不知道是發給誰的\n如果沒有設定 default_server，就會把請求派發給第一個 server，也就是 alex_backend\n這不是我們要的結果\n所以會把 dev_backend 設定為 default_server\n如此之後，只要是送進這個容器的請求\n若沒有被其他設定檔捕獲，就會被送進 dev_backend 處理\n",
    "ref": "/blog/202102-reverse-proxy-in-docker-service/"
  },{
    "title": "Laravel 執行環境建置",
    "date": "",
    "description": "介紹 Laravel 執行環境所需要的環境設定，包含 composer 安裝",
    "body": "開發 Laravel 專案所需要做的設定與套件安裝，不論是在遠端主機或是本機都適用\n更新套件包 sudo apt-get update 安裝 composer php -r \u0026#34;copy(\u0026#39;https://getcomposer.org/installer\u0026#39;, \u0026#39;composer-setup.php\u0026#39;);\u0026#34; php -r \u0026#34;if (hash_file(\u0026#39;sha384\u0026#39;, \u0026#39;composer-setup.php\u0026#39;) === \u0026#39;756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3\u0026#39;) { echo \u0026#39;Installer verified\u0026#39;; } else { echo \u0026#39;Installer corrupt\u0026#39;; unlink(\u0026#39;composer-setup.php\u0026#39;); } echo PHP_EOL;\u0026#34; php composer-setup.php php -r \u0026#34;unlink(\u0026#39;composer-setup.php\u0026#39;);\u0026#34; 執行結果 Composer (version 2.0.12) successfully installed to: //composer.phar Use it: php composer.phar 將指令改成全域 執行後可以直接使用 composer 指令操作\n很方便，建議要執行這個步驟\nmv composer.phar /usr/local/bin/composer 安裝 PHP extension 以 PHP 版本 7.4 的主機為例\n要在容器外運行 composer install，需要安裝以下 extension\n php7.4-mbstring php7.4-cli php7.4-gd ext-dom(php-xml) zip unzip php7.4-zip  apt install php7.4-cli apt-get install mbstring ext-dom zip unzip php7.4-zip php7.4-mbstring php-xml php7.4-gd 安裝資料庫對應的 extension 依照專案使用的資料庫自行安裝\n例如：\n php7.4-pgsql php7.4-mysql  php artisan 必要套件 php artisan 要在 php 指令介面(php Command Line Interface) 下執行\n所以必須依照自身 php 版本安裝 cli 套件\napt install php7.4-cli  以上就是建置 Laravel 環境所需要的最基本設定\n若是容器化的使用者，在打包 php 映像檔的時候一併執行即可\n",
    "ref": "/blog/202102-laravel-environment-basic-settings/"
  },{
    "title": "Ngrok 讓 localhost 可以被外部連線",
    "date": "",
    "description": "Ngrok 開發測試 webhook 的利器",
    "body": "ngrok 做為一個轉發的伺服器，他可以把外界的請求轉發到你指定的 Port\n使用的背景原理是連接到 ngrok 雲端伺服器將你本機指定的地址公開\n再將由 ngrok 一串公開的網址來存取內容\n他的優點是快速而且還提供了 https 的服務讓你使用上更安全，甚至你還可以設置密碼保護\n官方文件與載點：https://ngrok.com/download  安裝 Mac brew install ngrok Linux 確認自己的主機硬體架構\ncat /proc/cpuinfo 再去官網下載指定檔案依照官網安裝  或是直接使用 snap 安裝\nsudo apt update sudo apt install snapd sudo snap install ngrok 使用 啟動並監聽 8080 Port\nngrok http 8080 就可以看到對外開放的網址\n註冊 ngrok 不註冊的話過一段時間就會被斷線，開發階段使用免費版本就足夠了\nNgrok authtoken 頁面  複製 Authtoken 之後到 terminal 輸入\nngrok authtoken {Your Authtoken} 看到以下訊息代表認證完成\nAuthtoken saved to configuration file: /Users/user_name/.ngrok2/ngrok.yml ",
    "ref": "/blog/202102-ngrok-share-your-local-development-site/"
  },{
    "title": "Portainer - 視覺化管理 Docker 的工具",
    "date": "",
    "description": "介紹如何使用 Portainer 視覺化管理 Docker 服務",
    "body": "本機開發大部分使用指令操作，或是使用 Docker 本身的 GUI 介面管理服務\nPortainer  是一個 open-source 的 UI tool\n可以查看 docker image, container，並執行 start, stop, restart, remove 等動作\n也可查看每個 container 的 log 及 error\n在雲端主機上啟動服務的話，即使沒有 Docker 執行權限的人也可以透過帳號密碼登入\n使用視覺化的介面進行 Docker 服務的各種管理\nDockerhub image: portainer/portainer-ce  docker-compose.yml version: \u0026#39;3\u0026#39; services: portainer: image: portainer/portainer-ce command: -H unix:///var/run/docker.sock restart: always ports: - 9000:9000 - 8000:8000 volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data volumes: portainer_data: 為了 edge agent 而開啟 8000 port：文件說明   補充 如果遠端主機不想開放 port 造成任意使用者都有機會開啟後台畫面\n可以使用超外道的連線方式：How to Create SSH Tunneling or Port Forwarding in Linux  ssh -i ~/.ssh/id_rsa -L 8081:localhost:9000 ray@{你的遠端主機 IP} 在容器啟動後可以在本機終端機執行\n接著就可以在本機 localhost:8081 看到我們在遠端主機的 9000 port\n原理是透過 ssh 連線將本機 8081 port 的請求轉發到遠端主機的 9000 port\n這個方法不論遠端防火牆有沒有開放該 port 都可以執行，十分不講武德\n也不限於 Portainer 服務才能使用\n",
    "ref": "/blog/202101-portainer-open-source-container-management-gui/"
  },{
    "title": "Docker 筆記 3 - docker-compose",
    "date": "",
    "description": "介紹如何使用 docker-compose 管理多個容器",
    "body": "如果同時要管理彼此是有關連的多個 docker 容器，單純使用 docker 指令必須要自行記得容器之間的關聯\n而使用 docker-compose，則可以輕鬆定義多容器服務\n簡介  Docker for Mac 預設 python 所寫成的工具 由yaml定義 設定檔為 docker-compose.yml 依賴 docker 版本  官方文件：docker-compose  設定檔構成 docker-compose.yml 由兩個部分所構成\n version（版本要字串） services  key -\u0026gt; DNS name(hostname)    docker-compose 範例  其他工具 docker-swarm    看成 kubernetes 的分身 落地方便（kubernetes 準備工作很多） 高可用性 HA   價格便宜  組成（Node）\n 分兩個節點。  Manager：  分派任務給 worker node 同時也是 worker node 控制整個 Docker Swarm 的部署 主控制節點 如果死掉，整個 docker swarm 就死掉了 可以有多台 manager，但只有一台 \u0026amp;*$%^^#???   Worker：  被分派任務 不會主動分派任務 不知道其他 worker node     可以隨時 rolling update。 在所有 node 底下：  Service：  一個Service包含一種container Service啟動不代表container啟動 可以對container進行health check Service可以啟動複數個container(replicas)   Task  主要是由Service帶起來的 代表在docker container內執行的指令 task會在node上到執行結束為止     ",
    "ref": "/blog/202101-docker-note-3-introduce-docker-compose/"
  },{
    "title": "Docker 筆記 2 - 基本使用",
    "date": "",
    "description": "Docker 的基本使用方法",
    "body": "容器化可以隔離不同環境，將環境打包後工程師可以專注開發，不用花過多心力在開發環境安裝上\n而 Docker 是目前非常成熟且流行的一個容器化技術\n玩轉docker指令 查看容器資訊 docker ps 列出所有運行中的容器 docker ps -a 列出所有存在的容器 看 log docker logs [CONTAINER] 印出 log docker logs -f [CONTAINER] 持續印出最新 log 執行容器 從本地環境的 image 建立 container\n如果不存在從 repository 訪問，private repo 必須要有「登入」行為\nimage的格式可以為[IMAGE NAME]:[TAG]\ndocker run 範例： # 執行nginxdocker run -idt nginx# 執行nginx並且暴露port為8080docker run -idt -p 8080:80 nginx# 執行nginx在8080，在失敗的時候會自動重啟動docker run -idt -p 8080:80 --restart on-failure nginx# 執行nginx，結束後移除docker run --rm -idt nginx常用到的 flag  -d detach 將 container 置於背景執行 -i interactive 維持 STDIN，可互動 -t 提供 tty 允許 container 使用 tty -p expose socket 對外:對內 port (ex -p 8080:80) -p Host Port:Docker Port --restart 失敗重啟(always-default, none, on-failure) --rm 關閉後 container 自動消滅，若不刪可能會不斷累積，即使已經死掉了  常用指令 進入運行中的容器，並開啟終端機指令介面\ndocker exec -ti [CONTAINER] bash 取得 container 或是 image 的 Metadata\ndocker inspect [CONTAINER] 刪除 docker container\ndocker rm [CONTAINER] 刪除 docker image\ndocker rmi [IMAGE] 查看容器運行 process\ndocker top [CONTAINER] 其他指令 使用 Dockerfile 建立 docker image\n-f 手動指定 Dockerfile 名稱\n# 在目前的資料夾建立image，來源是Dockerfile docker build . -t image-name # 在目前的資料夾建立image，來源是Dockerfile-alt docker build . -t image-name -f Dockerfile-alt 將 docker image 從 repository 上拉/推上去\n要先登入 docker login\ndocker push / pull 登入 docker repository\ndocker login 怎麼寫自己的dockerfile  先註冊 Docker Hub Alpine Linux   體積非常的小 (5MB) 有完整的Linux架構 豐富的元件支援    常見 Dockerfile 命令 基本  FROM：指定基底 image，不指定版本的話預設都是 latest RUN：  docker build 時候執行命令，裝一些相依套件。 每一個 RUN 都是獨立事件   ARG：  container docker build 時的建置參數 無法在 container 中被使用   ENV：  printenv 容器內使用的環境變數 格式：ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; 或是 ENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt;    檔案複製  COPY：  複製「來源文件\\目錄」到的容器中的「文件\\目錄」中 COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;source path\u0026gt;... \u0026lt;dist path\u0026gt; dist path 可以是 Container 內的絕對路徑，也可以是相對於 WORKDIR 的相對路徑 會保留來源數據的各種屬性   ADD：  強化版的 COPY ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;source path\u0026gt;... \u0026lt;dist path\u0026gt; 允許 source path 是一個 URL 文件權限自動設置為 600    執行指令  ENTRYPOINT：  Container 起來預設會執行的指令 最後指令，啟動時要保持在前景的指令   CMD：  container起來預設會執行的指令（或參數） ENTRYPOINT, CMD 同時存在 CMD 當參數使用   WORKDIR(cd + mkdir):  初始容器內工作目錄    指令差異 ARG vs ENV ARG 由建立 image 的時候帶入\ndocker build . --build-arg FOO=bar ENV是在docker container內作為環境變數使用\nCMD vs ENTRYPOINT ENTRYPOINT 在 container 啟動時預設執行 CMD 在 ENTRYPOINT 存在時作為參數使用\nFROM ubuntu ENTRYPOINY [\u0026#34;ping\u0026#34;] CMD [\u0026#34;localhost\u0026#34;] COPY vs ADD COPY 適用在將本地端的檔案複製到container內\nADD 適用將遠端的檔案複製到container內\n除錯  docker: Got permission denied\n 這個錯誤是因為當前使用者的權限不足\n可以將使用者提升至 root 保證權限\n但是比較安全且正確的做法應該是\n 建立 docker 執行群組 將使用者加入 docker 群組  指令如下，需要退出重新登錄後才會生效！\nsudo groupadd docker sudo usermod -aG docker user_name ",
    "ref": "/blog/202101-docker-note-2-basic-usage/"
  },{
    "title": "Docker 筆記 1 - 認識 Docker",
    "date": "",
    "description": "介紹什麼是 Docker，以及容器化技術",
    "body": "容器化可以隔離不同環境，將環境打包後工程師可以專注開發，不用花過多心力在開發環境安裝上\n而 Docker 是目前非常成熟且流行的一個容器化技術\n將OS做為 Application 化\n所有 container 只能允許一個指令執行\n預設權限都會是 root\n商業來說\n 方便部署 可攜性  容器進化史 What is a Container?  名詞介紹  Stateful   Stateless：在未設的前提之下，每次建立時會消除舊的資料 Repository  就像是 apt、brew 或是 yum 的來源一樣 存了很多 image (Package)   Image  相當於 Package 產生特殊的 cache，本地有 cache 的話，就不需再從 Respository (如 Docker hub) 抓   Container  由 image 建立而成 相當於一個一個的程式，可以持續執行 必須要有一個 foreground 在跑的程式   Network  none：沒有網路 bridge：區網 overlay：不同網段 container：Docker 預設的網路連線, 無法由外部直接進來 host：與本機共用網路介面   Volume   Docker 內的持久化(Stateful)空間，可以 stateful 的秘密(空間) 等同本機空間    架構 生命週期  client 呼叫 docker daemon docker daemon 與 host network / host cgroups 溝通 判斷 docker container 是否存在 從 local image 將 layer 解開 如果 local image 不存在的話從 repository 拿 建立 docker container  學習資源 線上練習環境：Play with Docker  Docker 基本觀念與使用教學：自行建立 Docker 影像檔 - G. T. Wang  鸟瞰Docker  30 天與鯨魚先生做好朋友  ",
    "ref": "/blog/202101-docker-note-1-what-is-docker/"
  },{
    "title": "[Express+Vue 搭建電商網站] 22 使用 Docker 將專案容器化",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用 Docker 將專案容器化",
    "body": "接著我們會把整個專案使用 Docker  來將服務容器化，也會在 MongoDB 設定身份驗證機制\n如果對 Docker 不熟的話必須先去了解，才有辦法進行\n或是直接跳過這個章節 交給熱心的攤主處理\n在這邊我們會用到三個容器\n nginx 伺服器：處理 Vue 框架實現的前端靜態頁面 api：運行我們使用 Express 建立的 API 服務 db：就是一個運行 MongoDB 資料庫的容器  流程會變成\n 資料進來由 nginx 分派，如果是前端或是靜態資源就直接從 nginx 回傳\n若是 API 類型的請求則轉交給 API 容器處理後再回傳資料。\n 這種架構有以下優勢\n 透過 nginx 過濾非法請求 解決前後端跨域問題，因為兩者間都透過相同端點訪問 可以輕鬆擴增伺服器大小，並且使用 Nginx 做負載平衡  前端容器化 首先容器化的是先前用 Vue 寫的前端專案，將專案打包成靜態頁面\nnpm run build 接著增加 nginx 設定檔 client/config/nginx.conf\nserver { listen 80; root /www; index index.html; sendfile on; sendfile_max_chunk 1M; tcp_nopush on; gzip_static on; location /api/v1 { proxy_pass http://api:3000; } location / { try_files $uri $uri/ /index.html; } } 其中要特別注意的是 location 規則\n 請求目標如果是 /api/v1，那就把請求傳到 api 容器裡 請求目標 /，則直接回傳靜態頁面 index.html  然後要回頭稍微修改一下前端訪問後端的網址，打開 client/src/store/actions.js 修改 API_BASE 成\nconst API_BASE = \u0026#39;/api/v1\u0026#39;; 這樣改了之後前端在對 API 發起請求時就是取決於當前頁面的網址，而不是固定的 http://localhost:3000/api/v1\n接著就是要撰寫 Docker 相關設定\n首先建立 client/src/Dockerfile\nFROMnginx:1.13# 刪除預設的 Nginc 設定RUN rm /etc/nginx/conf.d/default.conf# 加入自己定義的 Nginx 設定檔COPY config/nginx.conf /etc/nginx/conf.d/# 將前端靜態檔案映射到容器的 /www 目錄下COPY dist /www接著建立 client/.dockerignore，裡面只有短短一行\nnode_modules 代表不 mount 進 docker 的資料夾\n後端容器化 前端容器化之後，接著準備進行後端的容器化。首先把寫死的 MongoDB 連線字串透過環境變數注入，修改 server/app.js 連線資料庫的部分成\nmongoose.connect(process.env.MONGO_URI || `mongodb://localhost:27017/test`); 接著一樣新建 server/Dockerfile\nFROMnode:10# 指定工作目錄為 /usr/src/app，接下来的指令全部在這個路徑下操作WORKDIR/usr/src/app# 將 package.json 複製到根目錄COPY package*.json ./# 安裝 npm 依賴RUN npm install# 複製全部程式內容COPY . .# 設定環境變數ENV NODE_ENV=production ENV MONGO_URI=mongodb://db:27017/testENV HOST=0.0.0.0ENV PORT=3000 # 曝露出 3000 portEXPOSE3000# 設定映像檔內執行的指令CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;]和前端一樣建立 server/.dockerignore 確定不會把 node_modules 給映射進容器裡\n裡面也只有一行：\nnode_modules Docker Compose Docker Compose  可以讓我們很好的管理 docker 容器，只需要透過一個 YAML 檔就可以修改設定。\n在專案的根目錄下建立（跟 client 和 server 兩個資料夾同層）docker-compose.yml\nversion: \u0026#39;3\u0026#39; services: db: image: mongo restart: always api: build: server restart: always ports: - 3000:3000 nginx: build: client restart: always ports: - 8080:80 可以看到我們建立了三個 service，對應到前面說的 db、api、nginx\n db：指定使用 mongo 映像檔，然後當服務意外停止則總是重啟 api：映像檔透過 server 資料夾內來建立，對外 port 為 3000:3000 nginx：映像檔透過 client 資料夾內來建立，對外 port 為 8080:80，外部的 8080 port 會指向到內部 80 port   如果 docker-compose.yml 中的 service 使用 image 指定映像檔，則會去Docker Hub  上拉回指定的映像檔\n若是使用 build 則會根據指定目錄下的 Dockerfile 來建立映像檔。\n 接著就是測試的時間！打開 Docker 之後，在終端機輸入\ndocker-compose up --build 第一次執行會多花一些時間，因為先前提過的要從Docker Hub  上拉回指定的映像檔，如下圖\n可以藉由\ndocker ps 來觀察目前所有的容器狀態，看起來沒問題的話就可以開啟 localhost:8080 來看看專案是不是跟原本一樣\nMongoDB 身份驗證 在之前的設定中我們的 MongoDB 資料庫並沒定任何身份驗證\n所以任何人只要能夠發送請求到資料庫都可以對資料庫做修改，這是一個可怕的資安問題！\n接著我們要來搞定 MongoDB 的身份驗證，增加系統的安全性\n修改 MongoDB 連線設定 打開 server/app.js，修改連線資料庫的部分成以下\nongoose.connect(process.env.MONGO_URI || `mongodb://localhost:27017/test`, { useNewUrlParser: true, useUnifiedTopology: true, user: process.env.MONGO_USER, pass: process.env.MONGO_PASSWORD, }); 這代表\n useNewUrlParser：使用新的 MongoDB 驅動 URL 解析器 useUnifiedTopology：使用新的連線管理引擎，支持重新連線，這樣可以大大提升連線穩定性 user：連線的使用者名稱，通過環境變數注入 pass：連線使用的密碼，通過環境變數注入  Dockerfile 中注入環境變數 在 server/Dockerfile 中加入下面的環境變數：\nENV NODE_ENV=production ENV MONGO_URI=mongodb://db:27017/adminENV MONGO_USER=mongoadmin ENV MONGO_PASSWORD=secret ENV HOST=0.0.0.0ENV PORT=3000 可以發現一些不同的地方，調整了 MONGO_URI，把預設的 test 換成 admin\n這是為了啟用驗證功能並且使用 admin 作為 Authentication Database 的使用者\n設定 Docker Compose 預設密碼 接著在 docker-compose.yml 裡面幫 db 服務加入預設密碼的環境變數\ndb: image: mongo restart: always environment: MONGO_INITDB_ROOT_USERNAME: mongoadmin MONGO_INITDB_ROOT_PASSWORD: secret測試 首先使用\ndocker-compose down --volumes 不只關閉了原本運行中的 docker 容器，還透過 --volumes 把原本的建立 MongoDB 的容器徹底刪除\n若不這麼做，之後重啟容器會跳過初始化使用者的過程，這樣我們的驗證資料庫就沒辦法被建立，而會載入之前的資料\n接著重新啟動容器\ndocker-compose up --build 應該會看到網頁一切正常，不過資料庫已經有了驗證，不是「裸奔」的狀態了\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202012-express-vue-build-ecommerce-22-docker-containerized/"
  },{
    "title": "[Express+Vue 搭建電商網站] 21 使用 Element UI 加入載入過動畫",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 套用 Element UI 加入載入動畫",
    "body": "等待的時候很無聊，所以我們加點動畫\n基本的動畫是用來告訴使用者動作執行結果，做到這樣使用者才知道自己剛剛做的事情有沒有完成\nManufactureForm 組件 在這個組件中，會在使用者新建或是修改製造商資訊後，當後端完成處理前出現 Loading 的動態效果\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;manufacturerInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; label-width=\u0026#34;180px\u0026#34; v-loading=\u0026#34;loading\u0026#34; element-loading-text=\u0026#34;Loading...\u0026#34; element-loading-spinner=\u0026#34;el-icon-loading\u0026#34; element-loading-background=\u0026#34;rgba(0, 0, 0, 0.8)\u0026#34; \u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;manufacturerData.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; native-type=\u0026#34;submit\u0026#34; @click=\u0026#34;onSubmit\u0026#34; \u0026gt;Update Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;model\u0026#34;, \u0026#34;isEditing\u0026#34;], data() { return { manufacturerData: { name: \u0026#34;\u0026#34; } }; }, created() { this.manufacturerData = this.model; }, watch: { model(val) { this.manufacturerData = val; } }, computed: { loading() { return this.$store.state.showLoader; } }, methods: { onSubmit() { this.$emit(\u0026#34;save-manufacturer\u0026#34;, this.manufacturerData); } } }; \u0026lt;/script\u0026gt; 使用 element-ui 组件庫提供的指令 v-loading 來判斷 loading 是否為真來決定是否要顯示載入動畫\n而 loading 這個 computed 屬性使用 store.state.showLoader 的資料\n同時也把當初在 ProductForm 中解決過「無法修改標單內容」的問題用同樣方法解決了\nProductForm 組件 當然啦，製造商表單的效果在 ProductForm 中應該也要有\n接著就打開 ProductForm 組件進行編輯\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;productInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; label-width=\u0026#34;180px\u0026#34; v-loading=\u0026#34;loading\u0026#34; element-loading-text=\u0026#34;Loading...\u0026#34; element-loading-spinner=\u0026#34;el-icon-loading\u0026#34; element-loading-background=\u0026#34;rgba(0, 0, 0, 0.8)\u0026#34; \u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Price\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.price\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Manufacturer \u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;modelData.manufacturer.name\u0026#34; clearable placeholder=\u0026#34;請選擇製造商\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34; :label=\u0026#34;manufacturer.name\u0026#34; :value=\u0026#34;manufacturer.name\u0026#34; \u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Image \u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.image\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Description \u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;modelData.description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; native-type=\u0026#34;submit\u0026#34; @click=\u0026#34;onSubmit\u0026#34; \u0026gt;Update Product\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Product\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { modelData: { manufacturer: { name: \u0026#34;\u0026#34; } } }; }, props: [\u0026#34;model\u0026#34;, \u0026#34;manufacturers\u0026#34;, \u0026#34;isEditing\u0026#34;], created() { const product = this.model; this.modelData = { ...product, manufacturer: { ...product.manufacturer } }; }, watch: { model(val) { this.modelData = val; } }, computed: { loading() { return this.$store.state.showLoader; } }, methods: { onSubmit() { // 表單中只有 modelData.manufacturer.name，但後端需要整個製造商物件，所以要找出對應的製造商物件寫入到 modelData 中  const manufacturer = this.manufacturers.find( item =\u0026gt; item.name === this.modelData.manufacturer.name ); this.modelData.manufacturer = manufacturer; this.$emit(\u0026#34;save-product\u0026#34;, this.modelData); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .productInfo { padding-top: 10px; } .form { margin: 0 auto; width: 500px; } .el-input__inner { height: 60px; } \u0026lt;/style\u0026gt; 在這個組件中我們也加入了 loading() 這個 computed 屬性\n實現提示功能 在組件中加入功能後，我們要實際把提示功能完成\n首先打開 src/store/actions.js 加入提示訊息的功能\nimport axios from \u0026#39;axios\u0026#39;; import { Message } from \u0026#39;element-ui\u0026#39;; import { ADD_PRODUCT, ADD_PRODUCT_SUCCESS, PRODUCT_BY_ID, PRODUCT_BY_ID_SUCCESS, UPDATE_PRODUCT, UPDATE_PRODUCT_SUCCESS, REMOVE_PRODUCT, REMOVE_PRODUCT_SUCCESS, ALL_PRODUCTS, ALL_PRODUCTS_SUCCESS, ALL_MANUFACTURERS, ALL_MANUFACTURERS_SUCCESS, MANUFACTURER_BY_ID, MANUFACTURER_BY_ID_SUCCESS, ADD_MANUFACTURER, ADD_MANUFACTURER_SUCCESS, UPDATE_MANUFACTURER, UPDATE_MANUFACTURER_SUCCESS, REMOVE_MANUFACTURER, REMOVE_MANUFACTURER_SUCCESS, } from \u0026#39;./mutation-types\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; export const productActions = { allProducts({ commit }) { commit(ALL_PRODUCTS) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { commit(ALL_PRODUCTS_SUCCESS, { products: response.data, }); }) }, productById({ commit }, payload) { commit(PRODUCT_BY_ID); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(PRODUCT_BY_ID_SUCCESS, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(REMOVE_PRODUCT); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`) .then(() =\u0026gt; { // 回傳 productId，用來刪除對應商品  commit(REMOVE_PRODUCT_SUCCESS, { productId, }); Message({ message: \u0026#39;產品刪除完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;產品刪除失敗\u0026#39;); }) }, updateProduct({ commit }, payload) { commit(UPDATE_PRODUCT); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product) .then(response =\u0026gt; { commit(UPDATE_PRODUCT_SUCCESS, { product: response.data, }); Message({ message: \u0026#39;商品更新成功\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;商品更新失敗\u0026#39;); }) }, addProduct({ commit }, payload) { commit(ADD_PRODUCT); const { product } = payload; axios.post(`${API_BASE}/products`, product) .then(response =\u0026gt; { commit(ADD_PRODUCT_SUCCESS, { product: response.data, }) Message({ message: \u0026#39;已新建商品\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;商品建立失敗\u0026#39;); }) } }; export const manufacturerActions = { allManufacturers({ commit }) { commit(ALL_MANUFACTURERS); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(ALL_MANUFACTURERS_SUCCESS, { manufacturers: response.data, }); }) }, manufacturerById({ commit }, payload) { commit(MANUFACTURER_BY_ID); const { manufacturerId } = payload; axios.get(`${API_BASE}/manufacturers/${manufacturerId}`).then(response =\u0026gt; { commit(MANUFACTURER_BY_ID_SUCCESS, { manufacturer: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(REMOVE_MANUFACTURER); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`) .then(() =\u0026gt; { // 回傳 manufacturerId，用來刪除對應的製造商  commit(REMOVE_MANUFACTURER_SUCCESS, { manufacturerId, }); Message({ message: \u0026#39;製造商刪除完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商刪除完成失敗\u0026#39;); }) }, updateManufacturer({ commit }, payload) { commit(UPDATE_MANUFACTURER); const { manufacturer } = payload; axios.put(`${API_BASE}/manufacturers/${manufacturer._id}`, manufacturer) .then(response =\u0026gt; { commit(UPDATE_MANUFACTURER_SUCCESS, { manufacturer: response.data, }); Message({ message: \u0026#39;製造商更新完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商更新失敗\u0026#39;); }) }, addManufacturer({ commit }, payload) { commit(ADD_MANUFACTURER); const { manufacturer } = payload; axios.post(`${API_BASE}/manufacturers`, manufacturer) .then(response =\u0026gt; { commit(ADD_MANUFACTURER_SUCCESS, { manufacturer: response.data, }); Message({ message: \u0026#39;製造商建立完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商建立失敗\u0026#39;); }) } } 首先導入了 element-ui 组件庫提供的 Message 提示訊息組件\n接著在各個操作中加入提示訊息的物件，成功或失敗都會回傳對應的訊息\n接著開啟 src/store/mutations.js 做部分內容修改，為的是修改購物車的提示訊息\nexport const cartMutations = { [ADD_TO_CART](state, payload) { const { product } = payload; state.cart.push(product); Message({ message: \u0026#39;成功加入購物車\u0026#39;, type: \u0026#39;success\u0026#39; }) }, [REMOVE_FROM_CART](state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) Message({ message: \u0026#39;已從購物車移除商品\u0026#39;, type: \u0026#39;success\u0026#39; }) }, } 同樣導入了 element-ui 组件庫提供的 Message 提示訊息組件\n當使用者加入或移除購物車商品時就會收到提示了！\n結果看起來像這樣，十分酷炫有型\n重構到這邊，測試起來似乎又有點什麼問題\n那就是在表單按下更新後，看到了更新成功的訊息，但畫面上的資料似乎沒有同步成最新的\n當資料出現問題，應該依據 Vue 的單向資料流原則來修正\n使用者更新資料後，應該從後端同步更新資料到狀態池中進行渲染\n因此我們要修改的就是 src/store/actions.js 的內容\n可以大膽的猜測，是因為後端請求結束後 action 提交到 mutations.js 中的不是修改後的最新資料\n所以才沒有改變狀態池中的物件\n修改 src/store/actions.js 檔案中更新數據的部分\n兩個方法在不同的常數中，但為了節省版面就只展示其中關鍵的方法\nupdateProduct({ commit }, payload) { commit(UPDATE_PRODUCT); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product) .then(() =\u0026gt; { commit(UPDATE_PRODUCT_SUCCESS, { product: product, }); Message({ message: \u0026#39;商品更新成功\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;商品更新失敗\u0026#39;); }) }, updateManufacturer({ commit }, payload) { commit(UPDATE_MANUFACTURER); const { manufacturer } = payload; axios.put(`${API_BASE}/manufacturers/${manufacturer._id}`, manufacturer) .then(() =\u0026gt; { commit(UPDATE_MANUFACTURER_SUCCESS, { manufacturer: manufacturer, }); Message({ message: \u0026#39;製造商更新完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商更新失敗\u0026#39;); }) }, 可以看到我們不理會 axios 返回的結果\n直接使用原本作為 payload 去執行 API 的資料回傳到 mutations 來修改狀態\n所以接著就要修改 mutations.js，將新的資料同步到狀態池中\n也是針對更新的部分做局部修改，將最新的資料同步到狀態池中\n[UPDATE_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { product: newProduct } = payload; state.products = state.products.map(product =\u0026gt; { if (product._id === newProduct._id) { return newProduct; } return product; }); state.product = newProduct; }, [UPDATE_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer: newManufacturer } = payload; state.manufacturers = state.manufacturers.map(manufacturer =\u0026gt; { if (manufacturer._id === newManufacturer._id) { return newManufacturer; } return manufacturer; }); state.manufacturer = newManufacturer; }, 於是我們就修好了表單的修改功能並直接顯示最新資料！\n這就是在實際開發中使用 element-ui 組件庫套用在前端樣板中的流程，並且一步一步的進行了重構\n到了這邊整個專案基本上已經可以正常運行了，使用者的體驗也得到的明顯的改善！\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202011-express-vue-build-ecommerce-21-elemen-ui-loading-animation/"
  },{
    "title": "[Express+Vue 搭建電商網站] 20 重構後的頁面功能恢復",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 重構後的頁面功能恢復",
    "body": "要是你跟老闆說：現在我們專案的畫面好看了，但是功能全壞了\n老闆應該會一臉問號問你在講什麼？\n廢話不多說，趕快來修好上一篇中被我們弄壞的功能！\n修復雙向綁定的問題 上一篇中有提過 element-ui 的輸入組件不接受 v-model 的功能\n所以為了雙向綁定資料，我們需要利用其他方法\nEdit 組件 首先打開 Edit 組件進行修復\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-form @save-product=\u0026#34;updateProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; :isEditing=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { created() { const { name = \u0026#34;\u0026#34; } = this.modelData || {}; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, model() { const product = this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); const res = { ...product, manufacturer: { ...product.manufacturer } }; return res; } }, methods: { updateProduct(product) { this.$store.dispatch(\u0026#34;updateProduct\u0026#34;, { product }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 這一步中我們又將 data 屬性中的 model 給恢復到了 computed 中，用來暫存 model 物件的資料提高效能\n而雙向綁定的問題會在其中的 ProductForm 解決\nProductForm 組件 我們來嘗試另一種方式修復雙向綁定，先看程式碼\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;productInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; label-width=\u0026#34;180px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Price\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.price\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Manufacturer \u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;modelData.manufacturer.name\u0026#34; clearable placeholder=\u0026#34;請選擇製造商\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34; :label=\u0026#34;manufacturer.name\u0026#34; :value=\u0026#34;manufacturer.name\u0026#34; \u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Image \u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.image\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Description \u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;modelData.description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Update Product\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Product\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { modelData: { manufacturer: { name: \u0026#34;\u0026#34; } } }; }, props: [\u0026#34;model\u0026#34;, \u0026#34;manufacturers\u0026#34;, \u0026#34;isEditing\u0026#34;], created() { const product = this.model; this.modelData = { ...product, manufacturer: { ...product.manufacturer } }; }, watch: { model(val) { this.modelData = val; } }, methods: { onSubmit() { const manufacturer = this.manufacturers.find( item =\u0026gt; item.name === this.modelData.manufacturer.name ); this.modelData.manufacturer = manufacturer; this.$emit(\u0026#34;save-product\u0026#34;, this.modelData); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .productInfo { padding-top: 10px; } .form { margin: 0 auto; width: 500px; } .el-input__inner { height: 60px; } \u0026lt;/style\u0026gt; 在上面的程式中，不直接使用父組件的 model 作為表單的資料物件\n而是在目前的組件中自訂一個新的 modelData 物件\n並且在組件剛被建立時就先從父組件取得 modle 物件，暫定為 product\n然後將 product 需要用到的屬性解構給 modelData 物件\n這樣就避免了表單物件操作 computed，但這只解決了一半問題，說好的雙向綁定呢？\n所以我們要透過監測組件的變化，利用 watch 方法監測使用者輸入\n並且將新的資料儲存到 modelData 物件中，這樣就完成雙向綁定啦！而且表單也可以隨意編輯\n商品資訊表單錯誤問題 當修改或是新建表單時，會看到錯誤的提示訊息：id 屬性未定義\n因為錯誤訊息說是在 ProductForm 中，就來看看發生什麼事情了吧\n應該都還記得，商品的物件的製造商包含了 id 和 name 屬性\n但是我們的下拉選單的 value 只有傳回 name\n而後端資料庫要求製造商物件必須也要有 id 屬性\n所以在送出時使用了 find 方法找到了對應 name 的製造商物件\n並且將 modelData 中的製造商物件覆蓋掉，這樣就符合後端資料庫的要求了！\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202011-express-vue-build-ecommerce-20-element-ui-fix-function/"
  },{
    "title": "[Express+Vue 搭建電商網站] 19 使用 Element UI 重構畫面",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 套用 Element UI 到頁面上",
    "body": "重構可能會造成一些功能癱瘓，本章先著重在畫面，讓畫面變美美噠\n後續的文章會把功能修復，莫急莫慌莫害怕\n管理後台畫面重構 由於我們之前在 App 組件中已經有了共用的工具列，所以打開 src/views/admin/Index.vue 修改成\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;admin-new\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;In Admin\u0026lt;/h1\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 後台商品列表頁面重構 接著打開後台的商品組件 src/views/admin/Products.vue，將 \u0026lt;template\u0026gt; 修改成\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;el-table class=\u0026#34;table\u0026#34; :data=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;名稱\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;price\u0026#34; label=\u0026#34;售價\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;manufacturer.name\u0026#34; label=\u0026#34;製造商\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;管理\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-button class=\u0026#34;modify\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;\u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/edit/\u0026#39; + scope.row._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt;\u0026lt;/el-button\u0026gt; \u0026lt;el-button class=\u0026#34;remove\u0026#34; @click=\u0026#34;removeProduct(scope.row._id), deleteRow(scope.$index, products)\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 看起來和前台的 ProductItem 組件中表格非常相似，差在對商品物件的操作\n一個是將商品加入或移出購物車，一個是刪除或修改商品\n後台編輯商品頁面重構 打開 ProductForm 組件，在 \u0026lt;template\u0026gt; 內使用組件庫提供的 el-form 表單組件代替原本簡陋的 form 表單\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;productInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; :model=\u0026#34;model\u0026#34; label-width=\u0026#34;180px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Price\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.price\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Manufacturer \u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;model.manufacturer.name\u0026#34; clearable placeholder=\u0026#34;请选择制造商\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34; :label=\u0026#34;manufacturer.name\u0026#34; :value=\u0026#34;manufacturer.name\u0026#34; \u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Image \u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.image\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Description \u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;model.description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Update Product\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Product\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 接著要解決 src/views/admin/Edit.vue 組件內傳入的 computed model 無法被編輯的問題\n理由是 input 作為受控的組件，會一直顯示 Vue 的綁定資料\n輸入框內容將無法進行編輯：Input 输入框  結果送出之後還是沒反應，這很正常先繼續把畫面調好，等等我們會來修復它\n打開 Edit 組件，將原本在 computed 中的 model 屬性放到 data 屬性中，並移除原本在 computed 中的屬性\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-form @save-product=\u0026#34;updateProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; :isEditing=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { data() { const product = this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); return { // 回傳 product 的備份，是為了在修改 product 的備份之後，在保存之前不修改本地 Vuex store 的 product 屬性  model: { ...product, manufacturer: { ...product.manufacturer } } }; }, created() { const { name } = this.model; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, }, methods: { updateProduct(product) { this.$store.dispatch(\u0026#34;updateProduct\u0026#34;, { product }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 接著，長得跟 Edit 組件很像的 New 組件也一起重構\n\u0026lt;template\u0026gt; \u0026lt;product-form @save-product=\u0026#34;addProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34;\u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { data() { return { model: { manufacturer: { name: \u0026#34;\u0026#34; } } }; }, created() { if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; } }, methods: { addProduct(model) { this.$store.dispatch(\u0026#34;addProduct\u0026#34;, { product: model }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 後台編輯製造商頁面重構 和 Products 組件類似，開啟 Manufacturers 使用 el-table 替換掉原本的表單的 \u0026lt;template\u0026gt; 部分\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;manufacturers\u0026#34;\u0026gt; \u0026lt;el-table class=\u0026#34;table\u0026#34; :data=\u0026#34;manufacturers\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;製造商\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;管理\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-button class=\u0026#34;modify\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/manufacturers/edit/\u0026#39; + scope.row._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt; \u0026lt;/el-button\u0026gt; \u0026lt;el-button class=\u0026#34;remove\u0026#34; @click=\u0026#34;removeManufacturer(scope.row._id), deleteRow(scope.$index, products)\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34; \u0026gt;刪除\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 接著重構 NewManufacturers 組件，一樣將 computed 的 model 換到 data 屬性中\n\u0026lt;template\u0026gt; \u0026lt;manufacturer-form @save-manufacturer=\u0026#34;addManufacturer\u0026#34; :model=\u0026#34;model\u0026#34;\u0026gt;\u0026lt;/manufacturer-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ManufacturerForm from \u0026#34;@/components/ManufacturerForm.vue\u0026#34;; export default { data() { return { model: {} }; }, methods: { addManufacturer(model) { this.$store.dispatch(\u0026#34;addManufacturer\u0026#34;, { manufacturer: model }); } }, components: { \u0026#34;manufacturer-form\u0026#34;: ManufacturerForm } }; \u0026lt;/script\u0026gt; 接著重構 ManufacturerForm\n程式結構和 ProductForm 組件很類似，將 \u0026lt;template\u0026gt; 區塊替換成組件庫樣式\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;manufacturerInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; :model=\u0026#34;model\u0026#34; label-width=\u0026#34;180px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Update Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 重構前台購物車 最後！重構 Cart 組件，和 ProductList 類似，兩者都用了 ProductItem 組件\n一樣那句話：將 \u0026lt;template\u0026gt; 區塊替換成組件庫樣式\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-item :products=\u0026#34;cart\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在這篇文章中主要就是使用 element-ui 組件庫將畫面做得比較酷炫\n但也造成一些功能癱瘓，當下一定很緊張，但不要緊！我們馬上就要來修復功能了！\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202011-express-vue-build-ecommerce-19-elemen-ui-refactor-page/"
  },{
    "title": "[Express+Vue 搭建電商網站] 18 套用 Element UI 到頁面上",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 套用 Element UI 到頁面上",
    "body": "先前我們已經把電商的基本功能完成了，只是畫面有點差強人意。\n在這一節中我們使用 Element UI 來讓畫面更加美觀\n安裝 Element UI Element UI  是一套 Vue 2.0 的組件庫\n提供了許多模板。在很多時候可以減少我們重造輪子的麻煩\n現在也有 Vue 3.x 的版本了\n有三方法可以進行\n  使用 npm 套件管理安裝，這也是官方推薦的作法\nnpm i element-ui -S   使用 CDN 安裝\n在 index.html 中加入 CDN 連結\n\u0026lt;!-- 引入样式 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/element-ui/lib/theme-chalk/index.css\u0026#34;\u0026gt; \u0026lt;!-- 引入组件库 --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/element-ui/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 若是使用 CDN 版本作法，建議加入版本號避免因為 Element UI 升級而受到影響\n  使用 vue-ui 鑑於 vue/cli 3.0 的釋出，也提供了從 vue-cli 中安裝的套件 官方說明    導入套件 打開主目錄中的 src/main.js 我們要把剛剛安裝的套件導入到專案中註冊依賴\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.config.productionTip = false Vue.use(ElementUI); new Vue({ router, store, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 除了導入 element-ui 組件庫外，還需要單獨把 CSS 樣式也導入\n並且聲明 Vue.use(ElementUI); 來註冊組件庫，接著就是快樂的開始使用組件庫了\n重構選單列 打開 src/App.vue 愉快的使用 element-ui 改成酷炫的樣子\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-menu class=\u0026#34;menu\u0026#34; :default-active=\u0026#34;activeIndex2\u0026#34; mode=\u0026#34;horizontal\u0026#34; @select=\u0026#34;handleSelect\u0026#34; background-color=\u0026#34;#545c64\u0026#34; text-color=\u0026#34;#fff\u0026#34; active-text-color=\u0026#34;#ffd04b\u0026#34;\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;首頁\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-submenu index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;控制台\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-1\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;產品列表\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-2\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin/new\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;新增商品\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-3\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin/manufacturers\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;製造商列表\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-4\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin/manufacturers/new\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;新增製造商\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt;  \u0026lt;el-menu-item index=\u0026#34;3\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/cart\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;購物車\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39;, data() { return { activeIndex: \u0026#39;1\u0026#39;, activeIndex2: \u0026#39;1\u0026#39; }; }, methods: { handleSelect(key, keyPath) { console.log(key, keyPath); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u0026lt;/style\u0026gt; 先不要在意 data 屬性以及 handleSelect 方法，暫時不會碰到\n首先看到 \u0026lt;el-menu\u0026gt; 這個標籤，其中的 el-menu-item 帶有幾個屬性\n其中 tag 屬性代表將這個內容用 \u0026lt;div\u0026gt; 這個標籤渲染，如果沒設定則預設是 \u0026lt;a\u0026gt; 連結並帶有底線\n所以這邊設定為 div 就是為了避免出現底線\n重構商品列表 接著要重構 ProductItem 同時因為子組件被修改，所以 ProductList 也需要修改\nProductList 打開 src/components/products/ProductList.vue 將 \u0026lt;template\u0026gt; 部分修改為\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;This is ProductList\u0026lt;/div\u0026gt; \u0026lt;!-- \u0026lt;template v-for=\u0026#34;product in products\u0026#34;\u0026gt; --\u0026gt; \u0026lt;product-item :products=\u0026#34;products\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;!-- \u0026lt;/template\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以藉由註解了解到，原本是分別將產品傳入子組件再進行渲染。但現在變成了傳入全部商品\n至於為什麼？就讓我們看下去\nProductItem 打開 src/components/products/ProductItem.vue 修改成以下內容\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;el-table class=\u0026#34;table\u0026#34; :data=\u0026#34;products\u0026#34; max-height=\u0026#34;250\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;產品名稱\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;description\u0026#34; label=\u0026#34;介紹\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;price\u0026#34; label=\u0026#34;售價\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;manufacturer.name\u0026#34; label=\u0026#34;製造商\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;!-- \u0026lt;el-table-column label=\u0026#34;圖片\u0026#34;\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;image\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;product__image\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt;--\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;product-button :id=\u0026#34;scope.row._id\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductButton from \u0026#34;./ProductButton\u0026#34;; export default { name: \u0026#34;product-item\u0026#34;, props: [\u0026#34;products\u0026#34;], components: { \u0026#34;product-button\u0026#34;: ProductButton } }; \u0026lt;/script\u0026gt; 第一，針對傳入值改成 props: [\u0026quot;products\u0026quot;], 因為在父組件做了改變，但是為什麼呢？\n再往回看 \u0026lt;template\u0026gt; 中，原來是因為 \u0026lt;el-table\u0026gt; 這個表格組件要傳入一個陣列作為 data 屬性\n而最後一個 el-table-column 作為按鈕，所以沒有定義 prop 屬性\n為了作為按鈕操作，使用了 scope.row 取得指定物件的 id 作為值傳給了子組件 ProductButton 來操作\n 透過 slot-scope 可以取得 row, column, $index 和 store（table 内部的狀態管理）資料\n ProductButton 接著就是修改 src/components/products/ProductButton.vue 組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button v-if=\u0026#34;isAdding\u0026#34; @click=\u0026#34;addToCart\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;加入購物車\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;removeFromCart(id)\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;從購物車移除\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;id\u0026#34;], computed: { product() { let product = this.$store.getters.allProducts.find( product =\u0026gt; product._id === this.id ); return product; }, isAdding() { let isAdding = true; this.cart.map(product =\u0026gt; { if (product._id === this.product._id) { isAdding = false; } }); return isAdding; }, cart() { return this.$store.state.cart; } }, methods: { addToCart() { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product: this.product }); }, removeFromCart(productId) { this.$store.commit(\u0026#34;REMOVE_FROM_CART\u0026#34;, { productId }); } } }; \u0026lt;/script\u0026gt; 使用 element-ui 組件庫提供的按鈕組件 el-button 替換先前普通的按鈕，並且改變了對應的按鈕方法 將父組件傳來的 product 物件換成了單純的 id\n因為在 ProductItem 組件中傳入的是指定物件的 id\n所以定義了一個 computed product，來取得指定 id 的產品物件\n到這邊我們先看看運行的結果\n上方的功能列已經變成比較好看的樣式了產品列表也用表單的形式，看起來整齊多了\n基本的 Element UI 套用就到這邊，接著我們會把畫面一步步變得更好看！\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202011-express-vue-build-ecommerce-18-element-ui-product-list/"
  },{
    "title": "[Express+Vue 搭建電商網站] 17 使用常數管理變數",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用常數管理變數",
    "body": "很多時候我們會把功能封裝到組件內，以便重複使用組件，而在組件內我們會定義很多方法名稱去呼叫不同的事件\n這中間只要有一個字打錯，整個流程就會錯誤，並且非常難除錯，因此我們會使用常數維持一致\n打錯字的時候就會報錯，方便除錯\n建立 ManufacturerForm 組件 和商品資訊一樣，我們也要將製造商資訊封裝到另一個單獨的組件 ManufacturerForm\n新增 src/components/ManufacturerForm.vue 檔案\n\u0026lt;template\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;saveManufacturer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Name\u0026#34; v-model=\u0026#34;model.name\u0026#34; name=\u0026#34;name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group new-button\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-pencil\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;!-- Conditional rendering for input text --\u0026gt; \u0026lt;span v-if=\u0026#34;isEditing\u0026#34;\u0026gt;Update Manufacturer\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;Add Manufacturer\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;model\u0026#34;, \u0026#34;isEditing\u0026#34;], methods: { saveManufacturer() { this.$emit(\u0026#34;save-manufacturer\u0026#34;, this.model); } } }; \u0026lt;/script\u0026gt; 重構 getters 檔案 在建立編輯生產商的組件前，需先加入對應的 getter 屬性\n打開 src/store/getters.js 檔案，對 manufacturerGetters 增加一個屬性\n用來取得狀態庫中的指定生產商\nmanufacturerById: (state, getters) =\u0026gt; id =\u0026gt; { if (getters.allManufacturers.length \u0026gt; 0) { return getters.allManufacturers.filter(manufacturer =\u0026gt; manufacturer._id === id)[0] } else { return state.manufacturer; } } 建立 EditManufacturers 頁面 在建立好顯示製造商資訊的表單組件 ManufacturerForm 以及設定好取得資料的 getter 之後\n我們要來建立編輯製造商的頁面 src/views/admin/EditManufacturers.vue\n\u0026lt;template\u0026gt; \u0026lt;manufacturer-form @save-manufacturer=\u0026#34;addManufacturer\u0026#34; :model=\u0026#34;model\u0026#34; :isEditing=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/manufacturer-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ManufacturerForm from \u0026#34;@/components/ManufacturerForm.vue\u0026#34;; export default { created() { this.$store.dispatch(\u0026#34;manufacturerById\u0026#34;, { manufacturerId: this.$route.params[\u0026#34;id\u0026#34;] }); }, computed: { model() { const manufacturer = this.$store.getters.manufacturerById( this.$route.params[\u0026#34;id\u0026#34;] ); return { ...manufacturer }; } }, methods: { addManufacturer(model) { this.$store.dispatch(\u0026#34;updateManufacturer\u0026#34;, { manufacturer: model }); } }, components: { \u0026#34;manufacturer-form\u0026#34;: ManufacturerForm } }; \u0026lt;/script\u0026gt; 組件在創建時會使用 action 去異步取得製造商資訊，並透過 mutation 修改狀態池 之所以在 model 這個 computed 中回傳製造商資料的備份資料\n是為了在修改資料被送出前不對當前 store 的生產商屬性做操作\n而組件內如果對生產商有操作，會透過 action 修改商品資訊，然後呼叫 mutation 變更狀態池\n建立 NewManufacturers 頁面 跟剛剛的編輯頁面邏輯差不多，這邊要建立新增頁面 src/views/admin/NewManufacturers.vue\n\u0026lt;template\u0026gt; \u0026lt;manufacturer-form @save-manufacturer=\u0026#34;addManufacturer\u0026#34; :model=\u0026#34;model\u0026#34;\u0026gt;\u0026lt;/manufacturer-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ManufacturerForm from \u0026#34;@/components/ManufacturerForm.vue\u0026#34;; export default { computed: { model() { return {}; } }, methods: { addManufacturer(model) { this.$store.dispatch(\u0026#34;addManufacturer\u0026#34;, { manufacturer: model }); } }, components: { \u0026#34;manufacturer-form\u0026#34;: ManufacturerForm } }; \u0026lt;/script\u0026gt; 重構 Admin menu 在 src/views/admin/Index.vue 加入新的頁面用來增加製造商，沒什麼多解釋的\n\u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/manufacturers/new\u0026#34;\u0026gt;新增製造商\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; 增加路由邏輯 頁面跟連結都做好了，打開 src/router/index.js 引入路由設定\nimport NewManufacturers from \u0026#39;@/views/admin/NewManufacturers\u0026#39;; import EditManufacturers from \u0026#39;@/views/admin/EditManufacturers\u0026#39;; 增加 admin 頁面下路由 children 屬性\n{ path: \u0026#39;manufacturers/new\u0026#39;, name: \u0026#39;NewManufacturers\u0026#39;, component: NewManufacturers, }, { path: \u0026#39;manufacturers/edit/:id\u0026#39;, name: \u0026#39;EditManufacturers\u0026#39;, component: EditManufacturers, }, 用常數管理通用名稱 很多時候我們會把功能封裝到組件內，以便重複使用組件\n而在組件內我們會定義很多方法名稱去呼叫不同的事件，例如當使用者按下了送出，觸發了 ADD_PRODUCT 事件\n那在 action 中就要有相應的事件\n並且 action 在後端處理完請求後，也會呼叫指定的 mutations 來處理狀態的變更\n這中間只要有一個字打錯，整個流程就會錯誤，並且非常難除錯\n因此我們會使用常數的方式定義 actions 和 mutations 中的事件\n只要我們都使用同一組常數就可以維持一致。關鍵的是如果這麼做打錯字的時候就會報錯，方便除錯\n接著就來實作建立 src/store/mutation-types.js 檔案作為 mapping 表\nexport const ALL_PRODUCTS = \u0026#39;ALL_PRODUCTS\u0026#39;; export const ALL_PRODUCTS_SUCCESS = \u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;; export const PRODUCT_BY_ID = \u0026#39;PRODUCT_BY_ID\u0026#39;; export const PRODUCT_BY_ID_SUCCESS = \u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;; export const ADD_PRODUCT = \u0026#39;ADD_PRODUCT\u0026#39;; export const ADD_PRODUCT_SUCCESS = \u0026#39;ADD_PRODUCT_SUCCESS\u0026#39;; export const UPDATE_PRODUCT = \u0026#39;UPDATE_PRODUCT\u0026#39;; export const UPDATE_PRODUCT_SUCCESS = \u0026#39;UPDATE_PRODUCT_SUCCESS\u0026#39;; export const REMOVE_PRODUCT = \u0026#39;REMOVE_PRODUCT\u0026#39;; export const REMOVE_PRODUCT_SUCCESS = \u0026#39;REMOVE_PRODUCT_SUCCESS\u0026#39;; export const ADD_TO_CART = \u0026#39;ADD_TO_CART\u0026#39;; export const REMOVE_FROM_CART = \u0026#39;REMOVE_FROM_CART\u0026#39;; export const ALL_MANUFACTURERS = \u0026#39;ALL_MANUFACTURER\u0026#39;; export const ALL_MANUFACTURERS_SUCCESS = \u0026#39;ALL_MANUFACTURER_S\u0026#39;; export const MANUFACTURER_BY_ID = \u0026#39;MANUFACTURER_BY_ID\u0026#39;; export const MANUFACTURER_BY_ID_SUCCESS = \u0026#39;MANUFACTURER_BY_ID_SUCCESS\u0026#39;; export const ADD_MANUFACTURER = \u0026#39;ADD_MANUFACTURER\u0026#39;; export const ADD_MANUFACTURER_SUCCESS = \u0026#39;ADD_MANUFACTURER_SUCCESS\u0026#39;; export const UPDATE_MANUFACTURER = \u0026#39;UPDATE_MANUFACTURER\u0026#39;; export const UPDATE_MANUFACTURER_SUCCESS = \u0026#39;UPDATE_MANUFACTURER_SUCCESS\u0026#39;; export const REMOVE_MANUFACTURER = \u0026#39;REMOVE_MANUFACTURER\u0026#39;; export const REMOVE_MANUFACTURER_SUCCESS = \u0026#39;REMOVE_MANUFACTURER_SUCCESS\u0026#39;; 重構 actions 檔案 打開 src/store/actions.js 檔案，引入剛剛的常數表文件後，把其中的方法名稱通通改成使用常數表內的常數\nimport axios from \u0026#39;axios\u0026#39;; import { ADD_PRODUCT, ADD_PRODUCT_SUCCESS, PRODUCT_BY_ID, PRODUCT_BY_ID_SUCCESS, UPDATE_PRODUCT, UPDATE_PRODUCT_SUCCESS, REMOVE_PRODUCT, REMOVE_PRODUCT_SUCCESS, ALL_PRODUCTS, ALL_PRODUCTS_SUCCESS, ALL_MANUFACTURERS, ALL_MANUFACTURERS_SUCCESS, MANUFACTURER_BY_ID, MANUFACTURER_BY_ID_SUCCESS, ADD_MANUFACTURER, ADD_MANUFACTURER_SUCCESS, UPDATE_MANUFACTURER, UPDATE_MANUFACTURER_SUCCESS, REMOVE_MANUFACTURER, REMOVE_MANUFACTURER_SUCCESS, } from \u0026#39;./mutation-types\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; export const productActions = { allProducts({ commit }) { commit(ALL_PRODUCTS) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { commit(ALL_PRODUCTS_SUCCESS, { products: response.data, }); }) }, productById({ commit }, payload) { commit(PRODUCT_BY_ID); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(PRODUCT_BY_ID_SUCCESS, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(REMOVE_PRODUCT); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`).then(() =\u0026gt; { // 回傳 productId，用來刪除對應商品  commit(REMOVE_PRODUCT_SUCCESS, { productId, }); }) }, updateProduct({ commit }, payload) { commit(UPDATE_PRODUCT); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product).then(() =\u0026gt; { commit(UPDATE_PRODUCT_SUCCESS, { product, }); }) }, addProduct({ commit }, payload) { commit(ADD_PRODUCT); const { product } = payload; axios.post(`${API_BASE}/products`, product).then(response =\u0026gt; { commit(ADD_PRODUCT_SUCCESS, { product: response.data, }) }) } }; export const manufacturerActions = { allManufacturers({ commit }) { commit(ALL_MANUFACTURERS); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(ALL_MANUFACTURERS_SUCCESS, { manufacturers: response.data, }); }) }, manufacturerById({ commit }, payload) { commit(MANUFACTURER_BY_ID); const { manufacturerId } = payload; axios.get(`${API_BASE}/manufacturers/${manufacturerId}`).then(response =\u0026gt; { commit(MANUFACTURER_BY_ID_SUCCESS, { manufacturer: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(REMOVE_MANUFACTURER); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() =\u0026gt; { // 回傳 manufacturerId，用來刪除對應的製造商  commit(REMOVE_MANUFACTURER_SUCCESS, { manufacturerId, }); }) }, updateManufacturer({ commit }, payload) { commit(UPDATE_MANUFACTURER); const { manufacturer } = payload; axios.put(`${API_BASE}/manufacturers/${manufacturer._id}`, manufacturer).then(() =\u0026gt; { commit(UPDATE_MANUFACTURER_SUCCESS, { manufacturer, }); }) }, addManufacturer({ commit }, payload) { commit(ADD_MANUFACTURER); const { manufacturer } = payload; axios.post(`${API_BASE}/manufacturers`, manufacturer).then(response =\u0026gt; { commit(ADD_MANUFACTURER_SUCCESS, { manufacturer: response.data, }) }) } } 重構 manufacturer 檔案 在 src/store/mutations.js 也做跟上一步一樣的事情\nimport { ADD_PRODUCT, ADD_PRODUCT_SUCCESS, PRODUCT_BY_ID, PRODUCT_BY_ID_SUCCESS, UPDATE_PRODUCT, UPDATE_PRODUCT_SUCCESS, REMOVE_PRODUCT, REMOVE_PRODUCT_SUCCESS, ADD_TO_CART, REMOVE_FROM_CART, ALL_PRODUCTS, ALL_PRODUCTS_SUCCESS, ALL_MANUFACTURERS, ALL_MANUFACTURERS_SUCCESS, MANUFACTURER_BY_ID, MANUFACTURER_BY_ID_SUCCESS, ADD_MANUFACTURER, ADD_MANUFACTURER_SUCCESS, UPDATE_MANUFACTURER, UPDATE_MANUFACTURER_SUCCESS, REMOVE_MANUFACTURER, REMOVE_MANUFACTURER_SUCCESS, } from \u0026#39;./mutation-types\u0026#39;; export const productMutations = { [ALL_PRODUCTS](state) { state.showLoader = true; }, [ALL_PRODUCTS_SUCCESS](state, payload) { const { products } = payload; state.showLoader = false; state.products = products; }, [PRODUCT_BY_ID](state) { state.showLoader = true; }, [PRODUCT_BY_ID_SUCCESS](state, payload) { state.showLoader = false; const { product } = payload; state.product = product; }, [REMOVE_PRODUCT](state) { state.showLoader = true; }, [REMOVE_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { productId } = payload; state.products = state.products.filter(product =\u0026gt; product._id !== productId); }, [UPDATE_PRODUCT](state) { state.showLoader = true; }, [UPDATE_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { product: newProduct } = payload; state.product = newProduct; state.products = state.products.map(product =\u0026gt; { if (product._id === newProduct._id) { return newProduct; } return product; }) }, [ADD_PRODUCT](state) { state.showLoader = true; }, [ADD_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { product } = payload; state.products = state.products.concat(product); }, }; export const cartMutations = { [ADD_TO_CART](state, payload) { const { product } = payload; state.cart.push(product) }, [REMOVE_FROM_CART](state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, } export const manufacturerMutations = { [ALL_MANUFACTURERS](state) { state.showLoader = true; }, [ALL_MANUFACTURERS_SUCCESS](state, payload) { const { manufacturers } = payload; state.showLoader = false; state.manufacturers = manufacturers; }, [MANUFACTURER_BY_ID](state) { state.showLoader = true; }, [MANUFACTURER_BY_ID_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer } = payload; state.manufacturer = manufacturer; }, [REMOVE_MANUFACTURER](state) { state.showLoader = true; }, [REMOVE_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturerId } = payload; state.manufacturers = state.manufacturers.filter(manufacturer =\u0026gt; manufacturer._id !== manufacturerId); }, [UPDATE_MANUFACTURER](state) { state.showLoader = true; }, [UPDATE_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer: newManufacturer } = payload; state.manufacturers = state.manufacturers.map(manufacturer =\u0026gt; { if (manufacturer._id === newManufacturer._id) { return newManufacturer; } return manufacturer; }) }, [ADD_MANUFACTURER](state) { state.showLoader = true; }, [ADD_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer } = payload; state.manufacturers = state.manufacturers.concat(manufacturer); } } 如此就完成了用常數替換 actions 和 mutations 兩隻檔案中的事件類型\n後續要維護就不會東一塊西一塊的過於分散，還要用全域搜尋人工替換，增加了維護的可行性\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202010-express-vue-build-ecommerce-17-use-const-instead-of-variable/"
  },{
    "title": "[Express+Vue 搭建電商網站] 16 抽離 Vuex store 中的邏輯",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 抽離 Vuex store 中的邏輯",
    "body": "隨著我們的迷你電商網站越來越完整，在 Vuex store 中的程式也越來越龐大\n不只有 getters、mutation 還有 actions\n在章節中先試著將這些複雜的邏輯拆分成個別的檔案，抽出 Getters、Mutations 和 Actions 邏輯\n重構 Admin 首頁 打開 src/views/admin/Index.vue 頁面，將選單換成中文。並且加上查看查看製造商的選項\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;admin-new\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-3 col-md-3 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;admin-menu\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;查看商品\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/new\u0026#34;\u0026gt;新建商品\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/manufacturers\u0026#34;\u0026gt;查看製造商\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以預期到的接下來我們會做一個關於製造商的頁面，然後透過後端 API 取得製造商資料\n建立 Manufacturers 頁面 新建 src/views/admin/Manufacturers.vue 檔案\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;製造商\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{manufacturer.name}}\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;modify\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/manufacturers/edit/\u0026#39; + manufacturer._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;remove\u0026#34;\u0026gt; \u0026lt;a @click=\u0026#34;removeManufacturer(manufacturer._id)\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt;刪除\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; table { margin: 0 auto; } .modify { color: blue; } .remove a { color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { created() { if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; } }, methods: { removeManufacturer(manufacturerId) { const res = confirm(\u0026#34;是否刪除此製造商？\u0026#34;); if (res) { this.$store.dispatch(\u0026#34;removeManufacturer\u0026#34;, { manufacturerId }); } } } }; \u0026lt;/script\u0026gt; 可以看到這邊我們用了一些先前沒用過的方法\n例如 computed 中的 manufacturers、生命週期 created() 時候會使用到的 allManufacturers\n還有製造商刪除用的 method 中 removeManufacturer，這些會在之後實作出來\n重構 Products 組件 接著要動手重構的就是 src/views/admin/Products.vue 組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;名稱\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;價錢\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;製造商\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;product in products\u0026#34; :key=\u0026#34;product._id\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{product.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{product.price}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{product.manufacturer.name}}\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;modify\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/edit/\u0026#39; + product._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;remove\u0026#34;\u0026gt; \u0026lt;a @click=\u0026#34;removeProduct(product._id)\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt;刪除\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; table { margin: 0 auto; } .modify { color: blue; } .remove a { color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { created() { if (this.products.length === 0) { this.$store.dispatch(\u0026#34;allProducts\u0026#34;); } }, computed: { products() { return this.$store.getters.allProducts; } }, methods: { removeProduct(productId) { const res = confirm(\u0026#34;是否刪除此商品？\u0026#34;); if (res) { this.$store.dispatch(\u0026#34;removeProduct\u0026#34;, { productId }); } } } }; \u0026lt;/script\u0026gt; 基本上和使用者畫面中的商品頁差不多，就是將加入購物車換成了修改與刪除商品\n也和剛剛操作過的 Manufacturers 組件相似，相關的東西講了許多次了，就交給你來思考\n加入路由設定 頁面跟組件都完成了，接著就要讓頁面可以被訪問\n打開 vue-router 的設定 src/router/index.js，加入製造商相關的路由參數\n引入頁面檔案\nimport Manufacturers from \u0026#39;@/views/admin/Manufacturers\u0026#39; 在 admin 路由的 children 屬性中加入頁面\n{ path: \u0026#39;manufacturers\u0026#39;, name: \u0026#39;Manufacturers\u0026#39;, component: Manufacturers, }, 接著開啟專案，可以看到製造商連結已經生效，可以把我們帶到製造商頁面，但是資料還是沒有取得\n記得嗎？之前說要從後端 API 取得資料的方法還沒寫，接下來就一邊重構一邊把這個功能完成吧！\n分離 Getter 邏輯 首先建立 src/store/getters.js 檔案，用來存放各種不同的 getter\nexport const productGetters = { allProducts(state) { return state.products }, productById: (state, getters) =\u0026gt; id =\u0026gt; { if (getters.allProducts.length \u0026gt; 0) { return getters.allProducts.filter(product =\u0026gt; product._id === id)[0] } else { return state.product; } } } export const manufacturerGetters = { allManufacturers(state) { return state.manufacturers; } } 可以看到我們導出了 productGetters 和 manufacturerGetters 兩個方法\n前者包含商品的 getters，後者則是負責製造商的 getter，如此就補上了前面幾段缺少的 manufacturer getters\n分離 Mutations 邏輯 就像剛剛分離 Getter 邏輯，接著新建 src/store/mutations.js 檔案作為 store 中 mutation 的程式管理\nexport const productMutations = { ALL_PRODUCTS(state) { state.showLoader = true; }, ALL_PRODUCTS_SUCCESS(state, payload) { const { products } = payload; state.showLoader = false; state.products = products; }, PRODUCT_BY_ID(state) { state.showLoader = true; }, PRODUCT_BY_ID_SUCCESS(state, payload) { state.showLoader = false; const { product } = payload; state.product = product; }, REMOVE_PRODUCT(state) { state.showLoader = true; }, REMOVE_PRODUCT_SUCCESS(state, payload) { state.showLoader = false; const { productId } = payload; state.products = state.products.filter(product =\u0026gt; product._id !== productId); } }; export const cartMutations = { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, } export const manufacturerMutations = { ALL_MANUFACTURERS(state) { state.showLoader = true; }, ALL_MANUFACTURERS_SUCCESS(state, payload) { const { manufacturers } = payload; state.showLoader = false; state.manufacturers = manufacturers; }, REMOVE_MANUFACTURER(state) { state.showLoader = true; }, REMOVE_MANUFACTURER_SUCCESS(state, payload) { state.showLoader = false; const { manufacturerId } = payload; state.manufacturers = state.manufacturers.filter(manufacturer =\u0026gt; manufacturer._id !== manufacturerId); } } 分別導出了\n productMutations cartMutations manufacturerMutations  來操作 vuex store 中的不同狀態，這邊也加入了生產商相關的狀態管理 mutations，讓之後的 actions 可以呼叫\n重構 Store 物件 既然剛剛都把 Getter 和 Mutations 抽離文件完成了，這邊就要重構 Store 檔案。\n要做的事情有兩件：\n 移除原有的 getters 和 mutations 引入新建的 getters 和 mutations  下面就是新的 src/store/index.js\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import axios from \u0026#39;axios\u0026#39;; import { productGetters, manufacturerGetters } from \u0026#39;./getters\u0026#39;; import { productMutations, cartMutations, manufacturerMutations } from \u0026#39;./mutations\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [], // all manufacturers  manufacturers: [], }, mutations: { ...productMutations, ...cartMutations, ...manufacturerMutations, }, getters: { ...productGetters, ...manufacturerGetters, }, actions: { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { console.log(\u0026#39;response\u0026#39;, response); commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) }, productById({ commit }, payload) { commit(\u0026#39;PRODUCT_BY_ID\u0026#39;); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(\u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(\u0026#39;REMOVE_PRODUCT\u0026#39;); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`).then(() =\u0026gt; { // 傳入 manufacturerId，用來刪除指定商品  commit(\u0026#39;REMOVE_PRODUCT_SUCCESS\u0026#39;, { productId, }); }) }, allManufacturers({ commit }) { commit(\u0026#39;ALL_MANUFACTURERS\u0026#39;); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(\u0026#39;ALL_MANUFACTURERS_SUCCESS\u0026#39;, { manufacturers: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(\u0026#39;REMOVE_MANUFACTURER\u0026#39;); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() =\u0026gt; { // 傳入 manufacturerId，用來刪除指定製造商  commit(\u0026#39;REMOVE_MANUFACTURER_SUCCESS\u0026#39;, { manufacturerId, }); }) }, } }); 移除原有 getters 和 mutations 不難理解，而引入新建的 getters 和 mutations 就值得說明了！\n首先藉由\nimport { productGetters, manufacturerGetters } from \u0026#39;./getters\u0026#39;; import { productMutations, cartMutations, manufacturerMutations } from \u0026#39;./mutations\u0026#39;; 引入剛剛分離出去的檔案\n接著使用 ES6 中的：擴展運算符（spread operator）  將剛剛引入的屬性以及包含的方法導入到 store 物件中。\n除此之外我們還偷偷在 actions 加入一些 action 屬性，稍後我們也會把它抽離出去\n這樣整個 store 看起來就會更簡潔了\n分離 Actions 邏輯 上面抽出了 Getters、Mutations 終於輪到 Actions 了\n重構 Edit 頁面 打開 src/views/admin/Edit.vue 替換成\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-form @save-product=\u0026#34;updateProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; :isEditing=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { created() { const { name } = this.model; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, model() { const product = this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); // 回傳 product 的備份，是為了在修改 product 的備份之後，在保存之前不修改本地 Vuex store 的 product 屬性  return { ...product, manufacturer: { ...product.manufacturer } }; } }, methods: { updateProduct(product) { this.$store.dispatch(\u0026#34;updateProduct\u0026#34;, { product }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 可以看到我們有兩個 computed：manufacturers 和 model，分別回傳製造商和當前商品\n之所以要回傳當前的 product 是為了在編輯了 product 的副本之後\n在存入資料庫之前先不變更使用者端 Vuex store 中的 product 屬性\n當組件被建立時，判斷 model 是否有值，如果沒有代表本機狀態庫中沒有資料\n必須透異步 API 取得商品資料，並且使用對應的 mutation 修改狀態庫中的資料\n在 \u0026lt;template\u0026gt; 中使用了子組件 ProductForm 來顯示商品資料\n按下表單送出時則會對送出 updateProduct 的異步 action，通知指定 mutation 來更新狀態\n重構 New 頁面 src/views/admin/New.vue 負責建立新的商品，邏輯與 Edit 類似\n只是一個負責新增商品，一個修改\n在這邊我們將組件中原本寫死的資料改為從後端動態取得，並將資料傳入給子組件 ProductForm\n\u0026lt;template\u0026gt; \u0026lt;product-form @save-product=\u0026#34;addProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34;\u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { created() { if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, model() { return {}; } }, methods: { addProduct(model) { this.$store.dispatch(\u0026#34;addProduct\u0026#34;, { product: model }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 跟 Edit 組件類似，只是這邊的 model 屬性回傳的是空物件，畢竟當前是不存在商品的\n拆分 Actions 邏輯 就像之前一樣建立 src/store/actions.js 檔案，用來管理 store 物件中 actions 屬性的內部屬性\n就跟上面處理 Getters 和 Manufacturers 時類似做法\nimport axios from \u0026#39;axios\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; export const productActions = { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) }, productById({ commit }, payload) { commit(\u0026#39;PRODUCT_BY_ID\u0026#39;); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(\u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(\u0026#39;REMOVE_PRODUCT\u0026#39;); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`).then(() =\u0026gt; { // 回傳 productId，用來刪除對應商品  commit(\u0026#39;REMOVE_PRODUCT_SUCCESS\u0026#39;, { productId, }); }) }, updateProduct({ commit }, payload) { commit(\u0026#39;UPDATE_PRODUCT\u0026#39;); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product).then(() =\u0026gt; { commit(\u0026#39;UPDATE_PRODUCT_SUCCESS\u0026#39;, { product, }); }) }, addProduct({ commit }, payload) { commit(\u0026#39;ADD_PRODUCT\u0026#39;); const { product } = payload; axios.post(`${API_BASE}/products`, product).then(response =\u0026gt; { commit(\u0026#39;ADD_PRODUCT_SUCCESS\u0026#39;, { product: response.data, }) }) } }; export const manufacturerActions = { allManufacturers({ commit }) { commit(\u0026#39;ALL_MANUFACTURERS\u0026#39;); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(\u0026#39;ALL_MANUFACTURERS_SUCCESS\u0026#39;, { manufacturers: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(\u0026#39;REMOVE_MANUFACTURER\u0026#39;); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() =\u0026gt; { // 回傳 manufacturerId，用來刪除對應的製造商  commit(\u0026#39;REMOVE_MANUFACTURER_SUCCESS\u0026#39;, { manufacturerId, }); }) }, } 可以發現我們把 API 的設定與使用都搬到這邊了，所以可以猜到下一步我們要做的就是「重構 Store」\n重構 Store 再次回到 src/store/index.js 檔案中，導入 Actions 邏輯相關的設定\n並且移除 API 相關的設定，包含引入 axios 和 API 網址的參數設定\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import { productGetters, manufacturerGetters } from \u0026#39;./getters\u0026#39;; import { productMutations, cartMutations, manufacturerMutations } from \u0026#39;./mutations\u0026#39;; import { productActions, manufacturerActions } from \u0026#39;./actions\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [], // all manufacturers  manufacturers: [], }, mutations: { ...productMutations, ...cartMutations, ...manufacturerMutations, }, getters: { ...productGetters, ...manufacturerGetters, }, actions: { ...productActions, ...manufacturerActions, } }); 於是我們就完成了 Actions 邏輯的抽換，來賓請掌聲鼓勵！\n新增 mutations 屬性 接著我們要在 src/store/mutations.js 的 productMutations 下新增一些 mutation 屬性\n用來處理使用者不同的操作時更新狀態庫中的內容同步\nUPDATE_PRODUCT(state) { state.showLoader = true; }, UPDATE_PRODUCT_SUCCESS(state, payload) { state.showLoader = false; const { product: newProduct } = payload; state.product = newProduct; state.products = state.products.map(product =\u0026gt; { if (product._id === newProduct._id) { return newProduct; } return product; }) }, ADD_PRODUCT(state) { state.showLoader = true; }, ADD_PRODUCT_SUCCESS(state, payload) { state.showLoader = false; const { product } = payload; state.products = state.products.concat(product); } 上面幾個 mutation 屬性分別處理了更新商品以及加入商品的邏輯，如此就完成了第一階段的重構\n本來還想把更多的重構寫在一起，但由於此篇篇幅以及資訊量已經很龐大，就在下一篇繼續優化我們的程式吧！\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202010-express-vue-build-ecommerce-16-refactor-vue-store/"
  },{
    "title": "[Express+Vue 搭建電商網站] 15 使用 Vuex Getters 複用資料邏輯",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用 Vuex Getters 複用資料邏輯",
    "body": "有時候我們需要 computed store 中的 state，在每個組件中複製貼上同樣的 computed 似乎不是一個明智的作法\nVuex Getter  是 Vuex 提供讓我們可以對 Vuex store 中 state 資料做預處理的方法，就可以達成這個目的\n建立 Getter 首先在原本的 src/store/index.js 檔案裡加入一些新的 action、mutation 屬性\n以及這次要使用的 getter\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import axios from \u0026#39;axios\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [], // all manufacturers  manufacturers: [], }, mutations: { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, ALL_PRODUCTS(state) { state.showLoader = true; }, ALL_PRODUCTS_SUCCESS(state, payload) { const { products } = payload; state.showLoader = false; state.products = products; }, PRODUCT_BY_ID(state) { state.showLoader = true; }, PRODUCT_BY_ID_SUCCESS(state, payload) { state.showLoader = false; const { product } = payload; state.product = product; } }, getters: { allProducts(state) { return state.products; }, productById: (state, getters) =\u0026gt; id =\u0026gt; { if (getters.allProducts.length \u0026gt; 0) { return getters.allProducts.filter(p =\u0026gt; p._id == id)[0]; } else { return state.product; } } }, actions: { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { console.log(\u0026#39;response\u0026#39;, response); commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) }, productById({ commit }, payload) { commit(\u0026#39;PRODUCT_BY_ID\u0026#39;); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(\u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;, { product: response.data, }); }) } } }); 主要增加了三個部分\n mutations：增加了 PRODUCT_BY_ID、PRODUCT_BY_ID_SUCCESS 用來管理單一商品的資訊狀態 actions：增加了 productById 來呼叫 mutations中的方法取得商品資訊 getters：建立 getters，並且加入 allProducts 和 productById 方法\nallProducts 取得所有商品；productById 則會回傳指定 id 的商品資料，如果商品不存在則回傳空的物件  在後台 Products 組件中使用 Getters 先使用一個簡單的範例說明 Getters 是怎麼運作的，打開 src/views/admin/Products.vue 組件\n並且把以下內容\nreturn this.$store.state.products[0]; 替換成\nreturn this.$store.getters.allProducts[0]; 在這個範例中，我們通過 this.$store.getters.allProducts 來調用 getter 中的 allProducts 屬性\n並且顯示出第一個商品的名稱\n建立 ProductDetail 組件 在簡單的了解 Getter 是怎麼運作之後，要來實現單一商品詳細內容的組件\n新建 src/components/products/ProductDetail.vue\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;product-details\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product-details__image\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;image\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;product-details__info\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product-details__description\u0026#34;\u0026gt; \u0026lt;small\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/small\u0026gt; \u0026lt;h3\u0026gt;產品名稱：{{product.name}}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;product-details__price-cart\u0026#34;\u0026gt; \u0026lt;p\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;product-button :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product-details__image .image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductButton from \u0026#34;./ProductButton\u0026#34;; export default { props: [\u0026#34;product\u0026#34;], components: { \u0026#34;product-button\u0026#34;: ProductButton } }; \u0026lt;/script\u0026gt; 可以看到這個組件將會利用父組件傳入的 product 物件來顯示內容\n並且複用了先前建立的 ProductButton 組件\n在 ProductItem 組件中為商品加入連結 有了詳細頁面，我們還需要設定怎麼進入商品詳細頁面的連結\n打開 src/components/products/ProductItem.vue 組件，將 \u0026lt;template\u0026gt; 區塊編輯成以下樣式\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/detail/\u0026#39; + product._id\u0026#34; class=\u0026#34;product-link\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;商品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;售價：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;/router-link\u0026gt; \u0026lt;product-button :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; 可以發現我們使用了之前學過的 vue-router 中的 router-link 方法跳轉到指定編號的商品頁面\n在 ProductList 中使用 Getters 而原先商品列表組件（src/components/products/ProductList.vue）「取得所有商品」功能\n也是直接操作 Vuex store 中的 state\ncomputed: { products() { return this.$store.state.products; } }, 在這邊我們也改用剛剛學到的 Getter 改寫成以下內容，使用指定的 getter：allProducts 取得所有商品資料\ncomputed: { products() { return this.$store.getters.allProducts; } }, 建立 Detail 頁面組件 現在子組件都完成了，只缺一個詳細商品頁面將組件拿來使用\n建立 src/views/Detail.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;product-detail :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-detail\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductDetail from \u0026#34;@/components/products/ProductDetail.vue\u0026#34;; export default { created() { // 如果使用者儲存的狀態中不存在此商品，則從後端取得商品資訊  const { name } = this.product; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } }, computed: { product() { return this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); } }, components: { \u0026#34;product-detail\u0026#34;: ProductDetail } }; \u0026lt;/script\u0026gt; 引入了 ProductDetail 組件，並且在生命週期中頁面建立「created()」時檢查使用者端是否有指定商品的資料\n沒有則使用異步方法呼叫 Vuex action 取得資訊，並透過 mutation 修改狀態\n其中的 computed 屬性用於取得狀態管理中的指定商品\n而其中的 id 參數透過 this.$route.params['id'] 取得路由中的產品編號，傳入指定的 getter 取得指定商品資料\n設定 Detail 頁面路由 剛剛提到會使用路由傳入的產品編號來查詢產品資料，有沒有想起什麼事情？\n打開 vue-router 的設定檔 src/router/index.js 引入 Detail 頁面\nimport Detail from \u0026#39;@/views/Detail\u0026#39;; 在路由規則中加入 Detail 頁面設定值\n{ path: \u0026#39;/detail/:id\u0026#39;, name: \u0026#39;Detail\u0026#39;, component: Detail, }, 成果 打開專案頁面，可以在商品列表發現所有商品現在都有了超連結\n點擊超連結之後會進入商品詳細頁面，而顯示的就是該商品的詳細資料\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202010-express-vue-build-ecommerce-15-use-vuex-getters/"
  },{
    "title": "[Express+Vue 搭建電商網站] 14 使用組件思維重構頁面邏輯",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用組件思維重構頁面邏輯",
    "body": "在先前我們學會怎麼使用 Vuex 進行狀態管理、如何使用 Action 取得 API 資料，以及使用 Mutation 更改狀態\n而這一篇中將透過 Vue 的組件化思維簡化原本複雜且分散於各個頁面的邏輯\n建立 ProductButton 組件 新建一個 src/components/products/ProductButton.vue 檔案\n準備用這個組件替換掉操作購物車中狀態按鈕的組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button v-if=\u0026#34;isAdding\u0026#34; class=\u0026#34;button\u0026#34; @click=\u0026#34;addToCart\u0026#34;\u0026gt;加入購物車\u0026lt;/button\u0026gt; \u0026lt;button v-else class=\u0026#34;button\u0026#34; @click=\u0026#34;removeFromCart(product._id)\u0026#34;\u0026gt;從購物車移除\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;product\u0026#34;], computed: { isAdding() { let isAdding = true; this.cart.map(product =\u0026gt; { if (product._id === this.product._id) { isAdding = false; } }); return isAdding; }, cart() { return this.$store.state.cart; } }, methods: { addToCart() { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product: this.product }); }, removeFromCart(productId) { this.$store.commit(\u0026#34;REMOVE_FROM_CART\u0026#34;, { productId }); } } }; \u0026lt;/script\u0026gt; 在這個組件中，透過了 v-if 來判斷 isAdding 這個 computed 是否為真\n而 isAdding 使用了來自 Vuex store 中 state 的 cart 參數\n藉由遍歷整個 cart 判斷當前的商品是否在購物車內，進而顯示對應的按鈕，並綁定不同的行為\naddToCart 和 removeFromCart 這兩個方法會調用 mutation 而改變 Vuex store 中的狀態\n建立 ProductItem 組件 建立好了按鈕後，要建立個別商品在渲染時使用的組件\n建立 src/components/products/ProductItem.vue 顯示商品相關資訊\n並引入上一步建立的 ProductButton 組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;商品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;售價：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;product-button :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductButton from \u0026#34;./ProductButton\u0026#34;; export default { name: \u0026#34;product-item\u0026#34;, props: [\u0026#34;product\u0026#34;], components: { \u0026#34;product-button\u0026#34;: ProductButton } }; \u0026lt;/script\u0026gt; 透過 import ProductButton from \u0026quot;./ProductButton\u0026quot; 引入剛剛建立的 ProductButton 組件\n並註冊在 components 物件中，最後在模板中使用組件\n重構 ProductList 組件 接著就可以把 src/components/products/ProductList.vue 這個組件重構\n把跟商品相關的模板部分移除，methods 中的加入購物車方法也一併移除\n因為單一商品的資料以及按鈕都已經加入到剛剛的 ProductItem 組件中\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;This is ProductList\u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in products\u0026#34;\u0026gt; \u0026lt;product-item :product=\u0026#34;product\u0026#34; :key=\u0026#34;product._id\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductItem from \u0026#39;./ProductItem.vue\u0026#39;; export default { name: \u0026#34;product-list\u0026#34;, created() { if (this.products.length === 0) { this.$store.dispatch(\u0026#34;allProducts\u0026#34;); } }, computed: { // a computed getter  products() { return this.$store.state.products; } }, components: { \u0026#39;product-item\u0026#39;: ProductItem }, }; \u0026lt;/script\u0026gt; 我們在引用了 ProductItem 組件後，利用 v-for 把每個商品都傳入組件用來建立商品列表\n重構 Cart 頁面 就跟在 ProductItem 組件中一樣，我們也將 src/views/Cart.vue 頁面中的商品列表組件化\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in cart\u0026#34;\u0026gt; \u0026lt;product-item :product=\u0026#34;product\u0026#34; :key=\u0026#34;product._id\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductItem from \u0026#34;@/components/products/ProductItem.vue\u0026#34;; export default { name: \u0026#34;home\u0026#34;, data() { return { msg: \u0026#34;Welcome to the Cart Page\u0026#34; }; }, computed: { cart() { return this.$store.state.cart; } }, components: { \u0026#34;product-item\u0026#34;: ProductItem } }; \u0026lt;/script\u0026gt; 一樣引入 ProductItem 組件，並且在 components 中註冊\n接著就可以在模板中把購物車內的商品傳入給組件使用\n而頁面的功能不會有所改變，只是把重複的部分整合成組件來共用，增加維護性\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202010-express-vue-build-ecommerce-14-refactor-component/"
  },{
    "title": "[Express+Vue 搭建電商網站] 13 使用 Axios 取得 API 資料",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用 Axios 取得 API 資料",
    "body": "使用 Axios 取得後端 API 的資料\n使用 Axios 取得 API 資料 首先先安裝 axios  npm i axios 在 Vuex store 中可以使用 action  屬性\n乍看之下跟 mutation 類似，不同的地方在於\n Action 提交的是 mutation，而不是直接變更狀態 Action 可以包含任意異步操作，用於響應 Vue 組件中分派的事件或動作  一個 action 是類似於 (context, payload) =\u0026gt; response.data 的函數：\nproductById(context, payload) { // 異步操作，從後端取得資料  return response.data; } 其中 productById 是從組件分派的事件或動作名稱，接收兩個參數 context、payload\ncontext 具有跟 store 相同的方法與屬性，可以透過 context.commit 來提交一個 mutation\n或是透過 context.state 和 context.getters 來取得 state 和 getters\npayload 就是攜帶的參數，可以透過他來執行異步操作，從而取得後端資料並回傳\n所以我們可以在 Action 中異步執行 axios 來抓取後端 API 的資料\n取得回傳結果後將結果提交給 mutation，並更新使用者端的資料\n實現 Action 再次修改 src/store/index.js\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import axios from \u0026#39;axios\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [], // all manufacturers  manufacturers: [], }, mutations: { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, ALL_PRODUCTS(state) { state.showLoader = true; }, ALL_PRODUCTS_SUCCESS(state, payload) { const { products } = payload; state.showLoader = false; state.products = products; } }, actions: { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { console.log(\u0026#39;response\u0026#39;, response); commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) } } }); 我們總共做了幾件事情\n 導入 axios，定義了後端 API 的網址到 API_BASE 刪除 store 中的假資料，清空 products 陣列 mutations 增加了 ALL_PRODUCTS 和 ALL_PRODUCTS_SUCCESS 方法\u0026lt; 用來處理撈取後端資料的載入狀態以及資料 最後加入了 actions 屬性，定義了 allProducts 函數，用來響應組件的對應事件\n首先提交了 ALL_PRODUCTS mutation，接著在 axios 取得後端資料後提交了 ALL_PRODUCTS_SUCCESS\n並且把取得的資料命名為 products 一併作為 payload 傳入   提示：\n可以看到在 allProducts 中我們傳入了 { commit } 參數\n這地方使用了解構賦值 const { commit } = context\n代替比較長的 context.commit\n因為目前我們沒用到其他 context 屬性，所以這麼做是可以的\n 更新組件 ProductList 將 src/components/products/ProductList.vue 的 \u0026lt;script\u0026gt; 區塊改成以下\n\u0026lt;script\u0026gt; export default { name: \u0026#34;product-list\u0026#34;, created() { if (this.products.length === 0) { this.$store.dispatch(\u0026#34;allProducts\u0026#34;); } }, computed: { // a computed getter  products() { return this.$store.state.products; } }, methods: { addToCart(product) { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product }); } } }; \u0026lt;/script\u0026gt; 增加了一個 created() 生命週期方法，在這個組件被建立時判斷使用者端是否有商品資料\n若是沒有，則需要跟後端 API 要資料\n於是通過 this.$store.dispatch 方法觸發名叫 allProducts 的 action\n為什麼我們這邊不使用 commit 操作 mutation 而是使用 dispatch 呢？\n是因為 mutation 必須是一個同步執行的程式，而這邊是一個異步請求\n需要使用 dispatch 來操作 Action 進行異步請求\n再來是 \u0026lt;template\u0026gt;，我們做部分修改，讓畫面渲染時的資料符合當初後端 API 定義的格式\n\u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/p\u0026gt; Cart 接著打開 src/views/Cart.vue 頁面，因為上面也有顯示生產商的名稱\n同樣把 {{product.manufacturer}} 改成 {{product.manufacturer.name}}\n測試結果 首先確認先前的後端 API 專案已經啟動，並且 MongoDB 也在運行中\n如果先前在撰寫 API 時你沒有進行測試，則資料庫應該為空。先去加一些資料吧！\n完成之後進入前端測試，應該就可以發現商品的資料就是後端 API 傳來的資料\n如果不確定的話，可以照著先前的教學，使用 Postman 取得 API 中的商品列表和前端的資料比對\n取得的資料和先前一樣，可以加入與移出購物車\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202009-express-vue-build-ecommerce-13-how-to-use-axios/"
  },{
    "title": "[Express+Vue 搭建電商網站] 12 在 Vuex 使用 Mutation 管理狀態",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 在 Vuex 使用 Mutation 管理狀態",
    "body": "透過 Mutation 管理 Vuex中的狀態\n使用 Mutation 在 Vuex 中 Mutation 是修改 Vuex store 內容的唯一方法\nMutation  是定義在 Vuex store 物件中 mutations 屬性的一系列函數\n長得會像\nACTION_NAME(state, payload) { return state++; } 其中 ACTION_NAME 就是組件發出的事件或動作的名稱\n這個函數接收兩個參數 state 和 payload。state 就是在 Vuex store 裡面儲存的 state\npayload 則是跟著呼叫的事件或是動作一起傳來的參數\n然後就可以對現有的 state 做操作而回傳新的 state，透過這種方式我們可以輕鬆的管理所有狀態\n初始化 mutations 狀態 打開 src/store/index.js 檔案，修改其中的 state\n並加入 mutations，這邊我們先把資料寫死，未來會接上先前寫的後端 API\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [ { _id: \u0026#39;1\u0026#39;, name: \u0026#39;iPhone 11\u0026#39;, description: \u0026#39;全新雙相機系統，捕捉所見所愛，範圍更多更廣。智慧型手機歷來最快速的晶片，加上滿足一天的電池續航力，讓你完成更多事，充電更少次。而智慧型手機中最高的影片畫質，讓你的點滴回憶，看起來比過去更加動人精彩。\u0026#39;, image: \u0026#39;https://i.gadgets360cdn.com/large/iPhone11_leak_1567592422045.jpg\u0026#39;, price: 44000, manufacturer: \u0026#39;Apple Inc\u0026#39; }, { _id: \u0026#39;2\u0026#39;, name: \u0026#39;Pixel 4\u0026#39;, description: \u0026#39;只要用Pixel 4 拍照，不用進工作室後製編輯，也能拍出相同品質的相片！Pixel 4 是第一支能夠拍下銀河的手機，只要輕輕一點，就能拍下美麗星空。\u0026#39;, image: \u0026#39;https://pgw.udn.com.tw/gw/photo.php?u=https://uc.udn.com.tw/photo/2019/10/16/realtime/6946830.jpg\u0026#39;, price: 24990, manufacturer: \u0026#39;Google\u0026#39; }, { _id: \u0026#39;3\u0026#39;, name: \u0026#39;Xperia 1 II\u0026#39;, description: \u0026#39;由於 Sony 先前整合了 Mobile 手機部門到 Sony 本家消費性電子產品部門的緣故，所以這次以這樣的命名方式出現也不讓人意外。\u0026#39;, image: \u0026#39;https://timgm.eprice.com.tw/tw/mobile/img/2020-02/24/5484360/innocences_1_a8c4b844f3c0c83646b79e366c3d8111.jpg\u0026#39;, price: 29000, manufacturer: \u0026#39;SONY\u0026#39; }, { _id: \u0026#39;4\u0026#39;, name: \u0026#39;V30S\u0026#39;, description: \u0026#39;LG V30 S ThinQ 最大的改變是 Vision AI 功能的加入，拍照的同時相機會自動識別畫面中的場景，準確的設定場景模式。\u0026#39;, image: \u0026#39;https://img.eprice.com.tw/img/mobile/5858/large.png\u0026#39;, price: 12500, manufacturer: \u0026#39;LG\u0026#39; }, { _id: \u0026#39;5\u0026#39;, name: \u0026#39;Galaxy Note 9\u0026#39;, description: \u0026#39;做為三星每年下半年度的旗艦手機，Note 系列從 2011 年的第一代 Galaxy Note 起，就以 S Pen 做為最大賣點，並且帶動大螢幕智慧手機的風潮直到今日。\u0026#39;, image: \u0026#39;https://timgm.eprice.com.tw/tw/mobile/img/2018-08/09/5115231/hat7029_1_77763a4f06a1fba43ab32e66d90bcba1.jpg\u0026#39;, price: 18900, manufacturer: \u0026#39;Samsung\u0026#39; } ], // all manufacturers  manufacturers: [], }, mutations: { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) } } }); 除了 state 中暫時寫死的商品內容外，我們加了兩個 mutations 屬性下的方法\n分別代表組件中「將商品加入購物車」以及「從購物車移除移出商品」的動作\nProductList 組件 接著要新建「商品列表」的組件，用來展示商品詳細資訊\n新建 /src/components/products/ProductList.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;This is ProductList\u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in products\u0026#34;\u0026gt; \u0026lt;div :key=\u0026#34;product._id\u0026#34; class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;產品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;addToCart(product)\u0026#34;\u0026gt;加入購物車\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;product-list\u0026#34;, computed: { // a computed getter  products() { return this.$store.state.products; } }, methods: { addToCart(product) { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product }); } } }; \u0026lt;/script\u0026gt; 在 \u0026lt;script\u0026gt; 中定義了一個 computed 作為商品資料的預處理\n這樣在模板渲染時就只需要使用 {products} 就可以取得在 Vuex store 中的 products 資料\n然後定義了一個點擊事件 addToCart 來處理加入購物車按鈕的點擊\n會通過 this.$store.commit 方法\n將目前商品物件 {product} 當作 payload 來操作 Vux store 中 mutation 所定義的 ADD_TO_CART 方法做狀態修改\n組件建立完之後要在畫面引入才能使用\n修改首頁 src/pages/Home.vue 把剛剛建立的 ProductList.vue 組件加入畫面\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;In Stock\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-list\u0026gt;\u0026lt;/product-list\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductList from \u0026#39;@/components/products/ProductList.vue\u0026#39;; export default { name: \u0026#39;home\u0026#39;, data () { return { msg: \u0026#39;Welcome to Your Vue.js App\u0026#39; }; }, components: { \u0026#39;product-list\u0026#39;: ProductList } } \u0026lt;/script\u0026gt; 購物車 接著要修改購物車頁面 /src/views/Cart.vue 將商品資訊顯示出來。\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in cart\u0026#34;\u0026gt; \u0026lt;div :key=\u0026#34;product._id\u0026#34; class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;產品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;removeFromCart(product._id)\u0026#34;\u0026gt;從購物車中移除\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;home\u0026#34;, data() { return { msg: \u0026#34;Welcome to the Cart Page\u0026#34; }; }, computed: { cart() { return this.$store.state.cart; } }, methods: { removeFromCart(productId) { this.$store.commit(\u0026#34;REMOVE_FROM_CART\u0026#34;, { productId }); } } }; \u0026lt;/script\u0026gt; 同樣的加入 computed 對商品做預處理\n這邊接收的是 this.$store.state.cart 也就是購物車中的商品列表\n寫好觸發 Vuex mutation 中移出購物車的按鈕方法 removeFromCart\n接著就可以開啟瀏覽器預覽執行結果\n一開始購物車是空的，我們隨便加了幾款手機進購物車後，在購物車頁面可以看見剛剛有選中的商品！\n而在購物車頁面可以將商品從購物車移除。\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202009-express-vue-build-ecommerce-12-vuex-mutation/"
  },{
    "title": "[Express+Vue 搭建電商網站] 11 認識 vuex",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 認識 vuex",
    "body": "vuex  來協助我們集中管理組件狀態，就不用到處維護狀態\n使得組件只需要專注於渲染頁面，而前端狀態都保留在 vuex 中建立的狀態庫中\n所謂狀態庫，其實也就是一個 Javascript 物件\n安裝 vuex 可以使用指令\nnpm install vuex --save 或是依然使用 vue ui 來安裝\n如果是使用 vue ui 安裝，會發現專案下多了一個檔案：/src/store/index.js，先用以下內容取代原本的檔案\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [ { name: \u0026#39;產品 1\u0026#39;, } ], // all manufacturers  manufacturers: [], } }) 上面我們做了一些事情\n 導入了 Vue 和 Vuex 調用 Vue.use 方法宣告使用 Vuex，聽起來和 vue-router 的時候一樣 最後導出 Vuex.Store 物件，並傳入 strict 和 state 參數\nstrict 宣告我們必須使用 Vuex 的 Mutation 函數來改變 state，否則會報錯（這部分會在之後的章節說明）\n而 state 參數儲存全域的狀態，比如在這邊定義了 cart、showLoader 等屬性\n都是後面我們操作會使用到的資料  整合 Vuex 和 Vue 當我們建立了 Vuex 的 store 物件後就可以使用它了，打開 src/main.js\n在開頭導入之前建立的 store，並且將 store 添加到 Vue 初始化的參數列表裡\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; Vue.config.productionTip = false new Vue({ router, store, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 如果你是使用 Vue ui 安裝，打開檔案可以見到程式已經幫我們完成了以上的內容\n當我們將 store 導入到了 Vue 中進行初始化後，Vue 會將 store 裡面的 state 注入到所有的組件中\n這樣所有的 Vue 組件就共享了一個全域的 state\n而所有的狀態變化都是針對這個 javascript 物件進行操作，然後觸發組件的重新渲染\n同時也避免了組件嵌套層級過多時，組件之間傳遞屬性的複雜性，便於大型程式與團隊合作\n查看結果 在整合好 Vuex 和 Vue 之後，馬上來看看 Vuex 帶來的變化。打開 src/pages/admin/Products.vue 修改成以下內容\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt;{{ product.name }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { computed: { product() { return this.$store.state.products[0]; } } }; \u0026lt;/script\u0026gt; 可以在 \u0026lt;script\u0026gt; 中看到一個沒見過的東西 computed，先來了解一下這是什麼\nComputed 如果在前端模板內加入太多的邏輯運算，不但可讀性差也難以維護，這問題在後端套版時常常發生，很難一眼看出它到底要渲染什麼\n而 計算屬性 (computed) 有點類似於 method，但 method 需要括號來觸發\n而且 method 不管相依的資料有沒有改變，都會重新計算。computed 則是在相依的資料有改變時才做計算並渲染\n所以需要每次更新的行為用 method，在意效能的話使用 computed\n講完了 computed 屬性，回頭來看剛剛的改動，我們在 computed 定義了一個 product 屬性\n會去 Vuex 也就是 store 中的 state 中 products 的第一個元素\n然後在頁面上使用剛剛取到的內容中的 name 屬性渲染\n於是我們知道可以使用 this.$store.state 來取得 Vuex store 中保存的 state\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202009-express-vue-build-ecommerce-11-install_vuex/"
  },{
    "title": "[Express+Vue 搭建電商網站] 10 用 vue 建立一個表單",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 用 vue 建立一個表單",
    "body": "後端的 API 上次已經開了出來，接著來建立前端使用的表單\n這次的目標是建立新增商品時所用的表單，會使用到基本的 Vue 知識，如果沒看過文件的可以先了解一下官方文件\n架構規劃 之前我們建立了 /src/views/admin/New.vue 這個模板做為網址 /admin/new 的顯示頁面\n在這節中會建立一個表單，然後讓他作為頁面組件顯示在 New.vue 中\n程式實作 建立一個新的檔案 /src/components/products/ProductForm.vue 作為表單的組件\n可以看到我們在這邊的存放位置不再是 /src/views/ 因為他是組件\n好好的放在「components」內是比較好的架構方式\n\u0026lt;template\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;saveProduct\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-5 col-md-5 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Name\u0026#34; v-model=\u0026#34;model.name\u0026#34; name=\u0026#34;name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Price\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Price\u0026#34; v-model=\u0026#34;model.price\u0026#34; name=\u0026#34;price\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Manufacturer\u0026lt;/label\u0026gt; \u0026lt;select type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; v-model=\u0026#34;model.manufacturer\u0026#34; name=\u0026#34;manufacturer\u0026#34;\u0026gt; \u0026lt;template v-for=\u0026#34;manufacturer in manufacturers\u0026#34;\u0026gt; \u0026lt;option :key=\u0026#34;manufacturer._id\u0026#34; :value=\u0026#34;manufacturer._id\u0026#34; :selected=\u0026#34;manufacturer._id == (model.manufacturer \u0026amp;\u0026amp; model.manufacturer._id)\u0026#34; \u0026gt;{{manufacturer.name}}\u0026lt;/option\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-lg-4 col-md-4 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Image\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; lass=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Image\u0026#34; v-model=\u0026#34;model.image\u0026#34; name=\u0026#34;image\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Description\u0026lt;/label\u0026gt; \u0026lt;textarea class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Description\u0026#34; rows=\u0026#34;5\u0026#34; v-model=\u0026#34;model.description\u0026#34; name=\u0026#34;description\u0026#34; \u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group new-button\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-pencil\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;!-- Conditional rendering for input text --\u0026gt; \u0026lt;span v-if=\u0026#34;isEditing\u0026#34;\u0026gt;Update Product\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;Add Product\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;model\u0026#34;, \u0026#34;manufacturers\u0026#34;, \u0026#34;isEditing\u0026#34;], methods: { saveProduct() { this.$emit(\u0026#34;save-product\u0026#34;, this.model); } } }; \u0026lt;/script\u0026gt; 程式說明 於是我們來看看這段看起來很長很嚇人的東西在做什麼？\n分為兩部分來理解\nscript 部分 props 主要接收父組件傳來的三個參數 model、manufacturers、isEditing\n然後在 methods 定義了一個方法 saveProduct，當使用者填完送出後按下送出會觸發這個方法\n而在 saveProduct 內部調用了一個 save-product 方法，這個方法稍後會在父組件建立\n除了調用父組件方法，在送出的同事還會把 this.model 內容傳遞給父組件\ntemplate 部分 淺而易見的 template 就是一個表單，其中的 submit 事件使用 @submit.prevent 禁用預設的送出行為\n並使用 saveProduct 替換\n接著寫了好幾個 class=\u0026quot;form-group\u0026quot; 的區塊，代表要填寫的商品資料\n其中前兩個區塊使用了 v-model 綁定 model 的 name、price 兩個屬性\n第三個區塊先對 select 標籤雙向綁定了 model.manufacturer 屬性\n代表在內部做的行為都會影響對應的 model.manufacturer\n接著使用迴圈把 script 中接收到的父組件 manufacturers 資料一個一個設為 option 標籤內容\n並且把個別設定 manufacturer 的屬性\n以及如果 model.manufacturer._id 和當前的 manufacturer._id 一致\n就把 selected 屬性設為 true\n接著第四個 form-group 開始，依然是使用 v-model 綁定 model.image 和 model.description 屬性\n最後一個 form-group 使用 v-if 判斷式來判斷 isEditing 來渲染不同的按鈕文字\n 完成了子組件之後，就要引入父組件內。所以重新打開 New.vue 這個檔案，引入剛剛建立的表單組件\n\u0026lt;template\u0026gt; \u0026lt;product-form @save-product=\u0026#34;addProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; \u0026gt; \u0026lt;/product-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#39;@/components/products/ProductForm.vue\u0026#39;; export default { data() { return { model: {}, manufacturers: [ { _id: \u0026#39;sam\u0026#39;, name: \u0026#39;Samsung\u0026#39;, }, { _id: \u0026#39;apple\u0026#39;, name: \u0026#39;Apple\u0026#39;, }, ], }; }, methods: { addProduct(model) { console.log(\u0026#39;model\u0026#39;, model); }, }, components: { \u0026#39;product-form\u0026#39;: ProductForm } } \u0026lt;/script\u0026gt; 當要在一個組件中使用另一個組件時，需要在父組件的 components 中註冊\n在我們的 New.vue 中就將 ProductForm 註冊為 product-form\n於是我們就可以在 \u0026lt;template\u0026gt; 區塊中使用 \u0026lt;product-form /\u0026gt; 來使用組件。\n同時在 data 中定義了 model 和 manufacturers；methods 中定義了 addProduct 方法\n並且綁定成 @save-product=\u0026quot;saveProduct\u0026quot; 事件傳遞給子組件使用\n儲存之後，重新開啟前端網頁，進入新建商品的頁面就可以看到子組件已經被加入 New.vue 的畫面上\n目前為止我們學會了\n 使用 vue-router 進行多頁面的跳轉與路由 使用嵌套路由有組織的管理前端路由 基礎的 Vue 使用 學會建立 Vue 的組件並在父組件中使用   專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202009-express-vue-build-ecommerce-10-new-product-page/"
  },{
    "title": "[Express+Vue 搭建電商網站] 09 API 測試",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 測試",
    "body": "在上一篇中完成了第一個 API，這一篇要來測試 API 是不是正常工作\n測試 API 經過上一篇的流程，我們的 API 應該已經建好了，現在透過常用的 API 測試軟體：Postman  來測試\nmanufacturers   POST /api/v1/manufacturers\n首先先建立供應商的資料，測試新建一個供應商「Google」\n  GET /api/v1/manufacturers\n查看供應商，因為我原本就有寫入了一個供應商「Apple」所以會有兩筆資料\n  PUT /api/v1/manufacturers/:id\n接著更新「APPLE」為「Apple」\n  DELETE /api/v1/manufacturers/:id\n最後我特別建立了一個叫做「samsung」的供應商用來測試刪除功能\n  products 最後來測試新建產品資料\n  POST /api/v1/products\n建立一個產品「iPhone 11」並且把他的供應商（manufacturer）指定給剛剛看過的「Apple」\n  GET /api/v1/products 新增完之後，使用 GET 方法取得資料查看會發現，iPhone 11 這筆資料的外部鍵值 manufacturer\n屬性的確是對應到當初在 model 設定中指定的 manufacturer Model 的 ObjectId 資料內容\n在這個範例中就是「Apple」。如此我們就建立了一款 Apple 出的手機：iPhone 11\n  結論 到這邊我們就已經建立好了 API 的服務\n在這幾個章節中我們學到了\n 了解 Express 路由以及如何使用 mongoose 連接 monogoDB 資料庫 編寫路由、Controller 和 Model 使用 Postman 測試 API  目前我們對於 Node 和 Express 搭建後端 API 有了基本的了解，就繼續前進吧！\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-09-test-api/"
  },{
    "title": "[Express+Vue 搭建電商網站] 08 API 建立",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 建立",
    "body": "在上一篇中建立了 Router，這一篇要做的就是將 Controller 完成，如此就完成了第一個 API\n建立 API 建立 Controller 接著就來建立兩個 Controller productController 和 manufacturerController\ncontrollers/manufacturer.js 這個 Controller 管理製造商（manufacturers）資料的操作，回頭看看上面路由中的方法是不是都找到了呢？\n開頭導入了之前在 Model 中定義過的 ManufacturerModel，這是 mongoose 提供給我們操作資料庫的介面\n通過 Model 上定義的一系列指令來對 Manufacturer 做資料操作\nconst Model = require(\u0026#39;../model\u0026#39;); const { Manufacturer } = Model; const manufacturerController = { all(req, res) { Manufacturer.find({}) .exec((err, manfacturers) =\u0026gt; res.json(manfacturers)) }, byId(req, res) { const idParams = req.params.id; Manufacturer .findOne({ _id: idParams }) .exec((err, manufacturer) =\u0026gt; res.json(manufacturer)); }, create(req, res) { const requestBody = req.body; const newManufacturer = new Manufacturer(requestBody); newManufacturer.save((err, saved) =\u0026gt; { Manufacturer .findOne({ _id: newManufacturer._id }) .exec((err, manfacturer) =\u0026gt; res.json(manfacturer)) }) }, update(req, res) { const idParams = req.params.id; let manufacturer = req.body; Manufacturer.updateOne({ _id: idParams }, { ...manufacturer }, (err, updated) =\u0026gt; { res.json(updated); }) }, remove(req, res) { const idParams = req.params.id; Manufacturer.findOne({ _id: idParams }).remove( (err, removed) =\u0026gt; res.json(idParams) ) } } module.exports = manufacturerController; controllers/product.js 而在 productController 中基本上與上方 manufacturerController 概念一致\nconst Model = require(\u0026#39;../model\u0026#39;); const { Product } = Model; const productController = { all(req, res) { Product.find({}) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, products) =\u0026gt; res.json(products)) }, byId(req, res) { const idParams = req.params.id; Product .findOne({ _id: idParams }) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, product) =\u0026gt; res.json(product)); }, create(req, res) { const requestBody = req.body; const newProduct = new Product(requestBody); newProduct.save((err, saved) =\u0026gt; { Product .findOne({ _id: newProduct._id }) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, product) =\u0026gt; res.json(product)) }) }, update(req, res) { const idParams = req.params.id; const product = req.body; console.log(\u0026#39;idParams\u0026#39;, idParams); console.log(\u0026#39;product\u0026#39;, product); Product.updateOne({ _id: idParams }, { ...product }, (err, updated) =\u0026gt; { res.json(updated); }) }, remove(req, res) { const idParams = req.params.id; Product.findOne({ _id: idParams }).remove( (err, removed) =\u0026gt; res.json(idParams) ) } } module.exports = productController; 完成後存擋，在終端機執行 npm start\n要先先確定是你的 mongoDB 要是開著的，可以使用指令\nmongo 看能不能進入 mongo 的指令列中，如果忘記怎麼開啟可以回到前面：連接 MongoDB  章節複習\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-08-build-api/"
  },{
    "title": "[Express+Vue 搭建電商網站] 07 API 路由建立",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 路由建立",
    "body": "在上一篇中建立了 Model，這一篇要做的就是將路由完成，讓請求可以送到指定的 Controller\nAPI 路由建立 新增路由並設定路由群組 打開 app.js 引入我們要使用的 api 路由\nconst api = require(\u0026#39;./routes/api\u0026#39;); 路徑就設定成 /api/v1 吧\napp.use(\u0026#39;/api/v1\u0026#39;, api); 這下子所有進入 /api/v1/ 以及底下路徑的所有請求都會進入 /routes/api 這個路由內\n建立新路由 我們建立一個檔案 /routes/api/index.js\nconst express = require(\u0026#39;express\u0026#39;); const router = express.Router(); const productController = require(\u0026#39;../../controllers/product\u0026#39;); const manufacturerController = require(\u0026#39;../../controllers/manufacturer\u0026#39;); router.get(\u0026#39;/manufacturers\u0026#39;, manufacturerController.all); router.get(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.byId); router.post(\u0026#39;/manufacturers\u0026#39;, manufacturerController.create); router.put(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.update); router.delete(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.remove); router.get(\u0026#39;/products\u0026#39;, productController.all); router.get(\u0026#39;/products/:id\u0026#39;, productController.byId); router.post(\u0026#39;/products\u0026#39;, productController.create); router.put(\u0026#39;/products/:id\u0026#39;, productController.update); router.delete(\u0026#39;/products/:id\u0026#39;, productController.remove); module.exports = router; 我們在上一步建立了路由群組，而這個步驟中我們照著經典的 RESTful API 規則來撰寫路由規則\n get：取得資源 post：建立新資源 put：更新資源 delete：刪除資源  在這個路由群組中不難發現，我們引用了 productController、manufacturerController\n這兩個尚未建立的檔案，而這兩個檔案就是我們 MVC 中的 Controller\n而 router 物件接了各種路徑的請求方法，並指定給所屬的 Controller 方法\n下個章節會建立 Controller 並且測試 API 是否成功運行\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-07-api-routes/"
  },{
    "title": "[Express+Vue 搭建電商網站] 06 - 資料庫設計",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 資料庫設計",
    "body": "先前我們安裝好了 mongoDB 以及開啟了 CORS，這一篇要來建立資料庫架構以及 MVC 架構中的 Model 部分\n資料庫設計 Schema 在 Express 中，資料庫的 Schema 是建立在 model/index.js 中的，如果沒有 model 資料夾就自己建一個\nconst mongoose = require(\u0026#39;mongoose\u0026#39;); const Schema = mongoose.Schema; const model = mongoose.model.bind(mongoose); const ObjectId = mongoose.Schema.Types.ObjectId; const productSchema = Schema({ id: ObjectId, name: String, image: String, price: Number, description: String, manufacturer: { type: ObjectId, ref: \u0026#39;Manufacturer\u0026#39; } }); const manufacturerSchema = Schema({ id: ObjectId, name: String, }); const Product = model(\u0026#39;Product\u0026#39;, productSchema); const Manufacturer = model(\u0026#39;Manufacturer\u0026#39;, manufacturerSchema); module.exports = { Product, Manufacturer }; 在下方兩個 model 的常數定義中 Schema 接收一個物件來定義資料結構以及對應的類型\n除了常見的 String, Number 外，比較特別的是：ObjectId 代表 MongoDB 中資料的主鍵，具有唯一性\n並且在 productSchema 中具有一個特別的屬性：manufacturer\n這個物件定義了一個 ref 屬性，對應到 Manufacturer 這個 model\n這是 MongoDB 的外部鍵值，與之對應的是 Manufacturer 中的 ObjectId 屬性的資料\n這就是我們習慣的 MVC 架構中的「Model」部分\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-06-db-schemas-and-models/"
  },{
    "title": "[Express+Vue 搭建電商網站] 05 - 連接 MongoDB 與 CORS",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 連接 MongoDB 與 CORS",
    "body": "資料庫使用 MongoDB，這篇中我們會簡單介紹基本連線方式，以及跨來源資源共(CORS)\n連接 MongoDB 接著我們要安裝 mongoose 套件：Mongoose  Mongoose 是一個 MongoDB  對象建模工具，用於在異步環境中工作\n是時下最流行的 ODM(Object Document Mapping)，要比直接操作底層 MongoDB Node 更方便\nnpm install mongoose 接著回到 app.js 中導入剛剛安裝的 mongoose\nconst mongoose = require(\u0026#39;mongoose\u0026#39;) 並透過套件提供的方法連上我們的 MongoDB 資料庫\nmongoose.connect(`mongodb://localhost:27017/test`); 雖然現在看不出效果，但我們等等會嘗試操作資料庫來測試連線的有效性\n但現在我們先做點額外的事情，儘管目前看來沒什麼用處但卻是必要的一環\n那就是開啟跨來源資源共用 CORS\n跨來源資源共用 CORS CORS 是基於 同源政策  的限制\n當關閉時限制了程式碼和不同網域資源間的互動，來自不同網域的資源請求會被無情拒絕！\n讓我們回到 app.js，在剛剛的資料庫連線下一行加入以下程式碼\n// CORS config here app.all(\u0026#39;/*\u0026#39;, function(req, res, next) { // CORS headers  res.header(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); // restrict it to the required domain  res.header(\u0026#39;Access-Control-Allow-Methods\u0026#39;, \u0026#39;GET,PUT,POST,DELETE,OPTIONS\u0026#39;); // Set custom headers for CORS  res.header(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;Content-type,Accept,X-Access-Token,X-Key\u0026#39;); if (req.method == \u0026#39;OPTIONS\u0026#39;) { res.status(200).end(); } else { next(); } }); 通常來說會使用 npm 套件 cors  解決，但這邊先用簡單暴力的方式解決\n未來如果有進行優化會再回頭安裝\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202007-express-vue-build-ecommerce-05-mongodb-connect-and-cors/"
  },{
    "title": "[Express+Vue 搭建電商網站] 04 - 進入 MongoDB 的世界",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 進入 MongoDB 的世界",
    "body": "資料庫使用 MongoDB，這篇中我們會簡單介紹基本指令及安裝。\n安裝 MongoDB 因為使用的是 mac 筆電，所以最愛用 Homebrew 安裝東西\n除了 node.js！這東西用 brew 裝會把你搞到懷疑人生，並且連官網都不建議這麼做\n但是 MongoDB 官方有釋出：使用 Homebrew 的安裝方法  ，我們就這個做看看吧\n至於不會使用 Homebrew 或是使用其他作業系統的人，可以使用：官方的下載中心  進行安裝\n安裝好之後有兩種啟動的方法\n 作為背景執行：mongod --config /usr/local/etc/mongod.conf --fork 使用 brew 管理  這邊推薦使用 brew 來操作的原因是容易操作，簡單幾個指令就可以\n 啟動服務：brew services start mongodb-community 重新啟動：brew services restart mongodb-community 停止服務：brew services stop mongodb-community  執行之後繼續輸入 mongo 指令，應該會進到 mongoDB 的指令列中\n到這邊就代表已經 mongoDB 服務就安裝並且啟動了\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202007-express-vue-build-ecommerce-04-hello-mongodb/"
  },{
    "title": "[Express+Vue 搭建電商網站] 03 - 認識 Express",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 認識 Express",
    "body": "後端使用的是 node.js 的後端框架 - express，這篇中我們會建立新專案。\n建立 Express 專案 使用 express-generator  來建立專案\nnpm install -g express-generator 安裝完成後可以使用以下指令查看版本是否有安裝成功\nexpress --version 接著初始化建立新專案\nexpress backend 建立之後運行看看初始樣貌\ncd backend npm install npm start 打開瀏覽器 http://localhost:3000/ 應該會看到以下畫面\n打開看看 Express 專案的資料夾架構\n app.js：Express Web Application 原型 routes/index.js：路由設定主要檔案 views/：放 View 的檔案 public/：放靜態檔案  和其它文章不同的是，這次使用 express-generator 建立的專案中並沒有把所有路由給寫在 app.js 中\n而是根據不同的應用做拆分，這和前端使用 vue-router 的嵌套路由是相同的概念\napp.js 在 app.js 中一開始先對於會用到的資源進行導入，例如 routes/index 和 routes/users 兩個路由\n也定義了專案使用的前端模板類型。但因為我們後端是作為 API 使用，所以沒什麼差\nroutes/index.js 而在 routes/index.js 中定義了進入這個路由之後對於不同請求可以做的回應方式\n這就是主要我們需要先了解的部分\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202007-express-vue-build-ecommerce-03-hello-express/"
  },{
    "title": "[Express+Vue 搭建電商網站] 02 - vue-router 的使用",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - vue-router 的使用",
    "body": "在接下來的內容中會學習 vue-router 的使用方法與學習路由基礎知識\n並使用 vue-router 來進行多個頁面的跳轉\n建立新組件 首先我們要先建立新的頁面組件，新建一個 src/components/Home.vue 檔案\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;home\u0026#39;, data () { return { msg: \u0026#39;Welcome to Your Vue.js App\u0026#39; }; }, } \u0026lt;/script\u0026gt; 看起來跟一開始預設的 HelloWorld.vue 有 87% 像，但是這邊先不對樣式做糾結，之後再去找 UI 庫套用\n設定 vue-router 在安裝了 vue-router 之後，會發現專案中多了一個資料夾 /src/router/index.js\n這就是 vue-router 的設定檔\n藉由以下這段我們發現，路徑 '/' 使用的是 Home 這個組件\nconst routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;About\u0026#39;, // route level code-splitting  // this generates a separate chunk (about.[hash].js) for this route  // which is lazy-loaded when the route is visited.  component: () =\u0026gt; import(/* webpackChunkName: \u0026#34;about\u0026#34; */ \u0026#39;../views/About.vue\u0026#39;) } ] 順著邏輯往上找會發現 Home 這個組件的引用來源\nimport Home from \u0026#39;../views/Home.vue\u0026#39; 接著打開 /views/Home.vue，原來這引入了 HelloWorld 組件\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;../assets/logo.png\u0026#34;\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // @ is an alias to /src import HelloWorld from \u0026#39;@/components/HelloWorld.vue\u0026#39; export default { name: \u0026#39;Home\u0026#39;, components: { HelloWorld } } \u0026lt;/script\u0026gt; 知道原理之後呢，就把 /views/Home.vue 內部目前沒有用到的部分刪除，並且換成我們上面建立的 Home 組件\n\u0026lt;script\u0026gt; // @ is an alias to /src import Home from \u0026#39;@/components/Home.vue\u0026#39; export default { name: \u0026#39;Home\u0026#39;, components: { Home } } \u0026lt;/script\u0026gt; 這時候使用瀏覽器開啟專案首頁，應該就會看到首頁已經變成 Home.vue 的內容\n加入頁面上方導航超連結 打開 App.vue 檔案，在 id=\u0026quot;app\u0026quot; 中加入三個 router-link 標籤的超連結，這是 Vue Router 的 API  根據官網說明 \u0026lt;router-link\u0026gt; 比起寫死的 \u0026lt;a href=\u0026quot;...\u0026quot;\u0026gt; 會好一些\n 無論是 HTML5 history 模式還是 hash 模式，它的表現行為一致，所以，當你要切換路由模式，或者在 IE9 降級使用 hash 模式，無須作任何變動。 在 HTML5 history 模式下，router-link 會守衛點擊事件，讓瀏覽器不再重新加載頁面。 當你在 HTML5 history 模式下使用 base 選項之後，所有的 to 屬性都不需要寫 (基路徑) 了。  \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;nav__left\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;Admin\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/cart\u0026#34;\u0026gt;Cart\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 看到上面的程式碼內容，聰明的你一定知道接著我們要建立三個頁面\n admin 後台管理 購物車頁面  剛剛示範了怎麼在 /views/Home.vue 中引入 src/components/Home.vue\n但在這邊先簡單一點，直接在 /views/ 目錄下建立如同 src/components/Home.vue 內容的檔案\n這時候 /views/ 資料夾應該會長得像這樣\n這時候其實可以把剛剛的 Home.vue 搬移進 /views/ 中，我們原本的引用在這邊有點多此一舉了\n但是在搬移過後會發現瀏覽器提示我們發生了一些問題，原來是 Home.vue 找不到檔案，但是為什麼呢？\n我們不是在 vue-router 裡面指定路徑 \u0026lsquo;/‘ 要到 Home.vue 嗎？\n首先復原程式碼，來看看在哪裡使用到了 src/components/Home.vue？\n哈！原來是一開始我們創建新組建時候把 App.vue 裡面的初始頁面 import 設定成 Home\n這也就說明了為什麼在 admin 以及 Cart 頁面中 Home.vue 的內容還是陰魂不散\n在刪除 import 的內容之後一切就正常了\n新建立的頁面加入路由 接著把剛剛新建的頁面加入路由設定檔案 /src/router/index.js 中\nimport Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import Home from \u0026#39;@/views/Home.vue\u0026#39; import Admin from \u0026#39;@/views/Admin\u0026#39;; import Cart from \u0026#39;@/views/Cart\u0026#39;; Vue.use(Router) const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: Home }, { path: \u0026#39;/admin\u0026#39;, name: \u0026#39;Admin\u0026#39;, component: Admin }, { path: \u0026#39;/cart\u0026#39;, name: \u0026#39;Cart\u0026#39;, component: Cart, }, ] const router = new Router({ routes }) export default router 好像有些什麼東西怪怪的？為什麼可以用 @ 引用東西呢？代表什麼意思？\n在我深入研究後發這是一個 webpack 的設定\n存在於 \\node_modules\\@vue\\cli-service\\lib\\config\\base.js\n進入檔案之後可以發現有設定了一個 alias set('@', api.resolve('src')) 這代表告訴了 vue\n 看到路徑用 @ 開頭的，就從 src 這個目錄開始操作\n 這樣做可以大幅度的減少我們使用 ../ 這種作法造成目錄結構變換就專案大爆炸，或是為了存取深層的檔案，畫面被一堆點點斜線佔滿\n在完成了以上動作之後，打開瀏覽器預覽一下\n看來我們剛剛完成了一個簡單的基於 Vue 的多頁面網站了！\n嵌套路由 有點經驗的工程師就知道，路由絕對不是這麼簡單的\n當頁面少的時候可以全塞在一支檔案裡面，但當頁面開始多這樣就會顯得很亂，並且無法一眼看出彼此之間的階層關聯\n還好 vue-router 提供了嵌套路由的功能，讓我們可以組織化的管理相關聯的頁面\n在後台頁面中會使用到很多操作的頁面，例如新增、修改商品，下面就藉由嵌套路由的方法來管理這些路由\n在引入的地方加入我們之後要增加的頁面，這邊只是先聲明，之後會一步一步的完成頁面\n// Admin Components import Index from \u0026#39;@/views/admin/Index\u0026#39; import New from \u0026#39;@/views/admin/New\u0026#39; import Products from \u0026#39;@/views/admin/Products\u0026#39; import Edit from \u0026#39;@/views/admin/Edit\u0026#39; 路由常數中加入嵌套路由，會發現 Admin 下有四個組件（component）\n而嵌套路由會為相關連的子路由設置一個入口頁面\n然後把這些頁面都放到 children 定義中的陣列中\n{ path: \u0026#39;/admin\u0026#39;, name: \u0026#39;Admin\u0026#39;, component: Index, children: [ { path: \u0026#39;\u0026#39;, name: \u0026#39;Products\u0026#39;, component: Products, }, { path: \u0026#39;new\u0026#39;, name: \u0026#39;New\u0026#39;, component: New, }, { path: \u0026#39;edit/:id\u0026#39;, name: \u0026#39;Edit\u0026#39;, component: Edit, }, ] }, 接著回到 /src/views/admin 建立\n Index.vue Edit.vue New.vue Products.vue  Index.vue Index 是我們上面提到的入口組件，也就是渲染 path = /admin 的基礎組件\n其餘的組件藉由 children 陣列宣告為嵌套的子路由。在子路由內的路由，前端都必須加上父層的路徑\n而在上方的定義中，我們把 /admin/ 的渲染子組件定義給了 Products\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;admin-new\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-3 col-md-3 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;admin-menu\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;View Products\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/new\u0026#34;\u0026gt;New Products\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 是用來渲染子路由的組件，比如說我們進入了 admin/new\n那麼 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 內部會被替換成 New.vue 組件的內容\n因為我們在上面路由定義中定義 \u0026lsquo;/new\u0026rsquo; 的路由渲染組件是 New.vue\nEdit.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit/{{$route.params.id}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Edit 這個路由在剛剛路由定義的時候有點不一樣，他的路徑是 edit/:id 這種寫法被稱作動態路由\n:id 會接收任意的內容作為一個參數傳入。例如我們進入 /admin/edit/banana 頁面\n那麼就可以在 Edit.vue 這個組件上使用\n{{$route.params.id}} 來呼叫到 :id 接收到的值，在上面的例子中就是「banana」\nNew.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/New\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Products.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 建立完成之後就完成了嵌套路由的應用\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202007-express-vue-build-ecommerce-02-vue-router/"
  },{
    "title": "[Express+Vue 搭建電商網站] 01- 初始設定",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 初始設定",
    "body": "本篇將使用 vue-ui 建立專案，並且安裝 vue-router\n安裝所需要的環境 在這個練習中我們首先需要的是安裝 npm 以及node\n這部分教學太多了，總之就先去裝起來吧！裝好後使用\nnpm -v # 確定安裝結果 node -v 接著要安裝我們前端所要使用的 vue\nnpm install -g vue-cli 安裝完成後在 terminal 確認安裝結果\nvue --version 新建 vue 專案 這次嘗試使用 Vue-cli 新出的 vue ui  來建立專案，在終端機輸入\nvue ui 就可以起動，根據提示我們開啟 vue-ui 的畫面 按下新增之後選擇指定的位置，根據畫面上提示來建立新專案\n接著就是等待他執行完成，在終端機進到剛剛建立專案的資料夾下會發現一個 vue 專案已經被建立\n根據 README 的說明執行以下指令後，可以打開 http://localhost:8080/ 來預覽執行結果\nnpm install npm run serve 安裝 vue-router 接著還要安裝一個我們會用上的東西：vue-router  可以選擇下指令，或是同樣的使用 vue-ui 來完成，既然剛剛使用 vue-ui 建立專案，這邊繼續使用 vue-ui 安裝 vue-router\n打開 vue-ui 頁面，最上方搜尋欄的左邊看「新增 vue-router」給他按下去就會開始安裝了 安裝好之後可以進入 main.js 查看，友善的自動安裝已經幫我們引入了呢！\n如此就完成了我們前端 vue 專案的初始設定\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce  ",
    "ref": "/blog/202006-express-vue-build-ecommerce-01-basic-settings/"
  },{
    "title": "About",
    "date": "",
    "description": "關於我",
    "body": "主要開發語言為 PHP 的後端工程師，入行用到現在\n喜歡嘗試沒碰過的技術，沒事喜歡想一些有的沒的，但是不喜歡寫前端\n持續精進自己的技術，目標是前往國外發展\n更精確地來說是去澳洲，目前也持續在加強英文能力\n對我來說程式是一種具名的創作，同時也是一個工程師態度的表現\n你寫出怎麼樣的程式碼，別人就怎麼評價你\n Your name shall speak for yourself.\n 喜歡進行技術交流，對社群充滿熱情，積極地參與相關聚會吸收他人的經驗\n同時也樂於分享自身故事，在這條路上接受過太多幫助，也樂於伸出援手成為別人的英雄\n相信透過分享可以讓自己成為更好的人\n",
    "ref": "/about/"
  }]
