[{
    "title": "設定 ssh 金鑰登入遠端主機",
    "date": "",
    "description": "使用 ssh key 登入遠端主機而不使用密碼登入",
    "body": "一般登入伺服器是使用帳號與密碼進行登入，但是密碼可能會因為抄錄或是傳遞給人而外洩\n安全性的程度會比較沒有像SSH key 那麼安全，而且使用SSH key 登入可以就不用每次手動輸入密碼\n建立登入端的 ssh key 使用者端建立 ssh key，使用指令 ssh-keygen  注意：ssh key 要是 RSA 的格式，如果是 OPENSSH 會不斷的報錯\n參考資料：mac majave 10.14.1 ssh-keygen 金鑰格式問題\n 預設會產生在 .ssh/ 路徑下\n如果是用複製別人的 id_rsa 和 id_rsa.pub 的話需要重新設定權限，否則會報錯\nchmod 600 id_rsa chmod 644 id_rsa.pub 權限說明 -rw------- (600) -- 只有屬主有讀寫權限。 -rw-r--r-- (644) -- 只有屬主有讀寫權限；而屬組用戶和其他用戶只有讀權限。 -rwx------ (700) -- 只有屬主有讀、寫、執行權限。 -rwxr-xr-x (755) -- 屬主有讀、寫、執行權限；而屬組用戶和其他用戶只有讀、執行權限。 -rwx--x--x (711) -- 屬主有讀、寫、執行權限；而屬組用戶和其他用戶只有執行權限。 -rw-rw-rw- (666) -- 所有用戶都有文件讀、寫權限。這種做法不可取。 -rwxrwxrwx (777) -- 所有用戶都有讀、寫、執行權限。更不可取的做法。 以下是對目錄的兩個普通設定： drwx------ (700) - 只有擁有者可在目錄中讀、寫。 drwxr-xr-x (755) - 所有用戶可讀該目錄，但只有擁有者才能改變目錄中的內容 遠端主機設定 登入遠端主機之後，檢查使用者家目錄是否存在 ./ssh/authorized_keys 檔案\n若沒有則自行建立，並設定權限 chmod 600 authorized_keys\n檔案內容為剛剛產生的 id_res.pub 的內容\n範例：\nssh-rsa AABAB3NzaC1yc2Gmy80/{...中略...}/UD9CBSzNAya7r6w== 補充 讓雲端主機可以存取版本庫  建立 GCP 使用者後，依照上面做法產生 ssh key 把 public key 加到版本庫的 ssh key 列表中 ",
    "ref": "/blog/202104-use-ssh-key-login-remote-server/"
  },{
    "title": "雲端主機啟動 Docker 服務",
    "date": "",
    "description": "介紹如何在雲端主機啟用 docker 服務",
    "body": "新開主機啟用 docker 與 docker-compose 服務的操作步驟\n安裝 Docker sudo apt-get install docker.io sudo apt install docker.io 將使用者加入群組 此操作可以讓使用者不需要 sudo 就執行 docker 指令，為非必要步驟\nsudo usermod -a -G docker {ec2-user} ref: Ubuntu Linux 安裝 Docker 步驟與使用教學\n也有人直接將使用者加入 sudoer 群組中，有一樣的結果\n安裝 docker-compose sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose ref: Install Docker Compose\n 如此就可以在新開的雲端主機進行 Docker 容器的操作\n",
    "ref": "/blog/202103-enable-docker-service-in-remote-server/"
  },{
    "title": "PostgreSQL 資料庫建置 - 使用 Docker",
    "date": "",
    "description": "介紹如何使用 Docker 建置 PostgreSQL 資料庫",
    "body": "使用 Docker 來建置一個 PostgreSQL 資料庫\n包含 資料庫建置、資料持久化、使用 GUI 操作資料庫\nPostgreSQL 基礎教學：後端前進PostgreSQL 系列\n環境建置 - 使用 Docker-compose 使用的映像檔：postgres: alpine\n參考文章：Getting Started with PostgreSQL using Docker-Compose\ndocker-compose.yml version: \u0026#39;3\u0026#39; services: postgres: container_name: postgres ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:alpine\u0026#34; volumes: - database-data:/var/lib/postgresql/data # persist data even if container shuts down restart: always environment: POSTGRES_USER: superuser POSTGRES_PASSWORD: superpassword POSTGRES_DB: demo_db volumes: database-data: # named volumes can be managed easier using docker-compose 啟動容器：\ndocker-compose up  GUI 安裝 因為 sequel ace 不支援 PostgreSQL 所以另外裝一個 GUI 來用\n安裝 DBeaver\n會需要安裝 JAVA 包\nbrew install --cask dbeaver-community 存取在遠端的 PostgreSQL container 取得該遠端的對外 ip 作為 host 之後連線到指定的 port (5432)\n就可以在其他機器上存取 PostgreSQL container\n 資料持久化 (persist data) 官方文件說明\n使用docker-compose啟動服務時，初始化資料庫和資料(以Mysql為例)\nDifferent Types of Volumes\nnamed volume：  docker-compose up 啟動容器 docker volume ls 確認有建立 volume docker-compose stop 停止容器 docker-compose up，使用 GUI 連線容器確認資料有被重新掛載 docker-compose down，移除容器 docker ps -a 確認容器確實被移除 docker-compose up，volume 成功掛載回去  host volume 調整容器內 volume 目標資料夾位置到本機特定資料夾下\n如果有多台容器需要一起掛載同一份資料：官方文件\n這個做法使用 docker volume ls 就不會有結果，要自己去看指定的路徑。因為管理 volume 已經不是透過 docker\nversion: \u0026#39;3\u0026#39; services: postgres: container_name: postgres ports: - \u0026#34;5432:5432\u0026#34; image: \u0026#34;postgres:alpine\u0026#34; volumes: - ./database_data:/var/lib/postgresql/data # persist data even if container shuts down restart: always environment: POSTGRES_USER: superuser POSTGRES_PASSWORD: superpassword POSTGRES_DB: trp  調整 yml 檔 service 內 volumes，改為指定路徑 docker-compose up 啟動容器 使用路徑管理 volume 後 docker volume ls 不會有反應 查看指定路徑 ./database_data，volume 檔案成功寫入 docker-compose up，使用 GUI 連線容器確認資料有被重新掛載 docker-compose down，用 docker ps -a 確認 container 確實被移除 docker-compose up，volume 成功掛載回去  補充 如果在同一台機器上想要啟用多個 PostgreSQL 容器\n則 5432 port 會被佔用，當然可以將外部 port 改為不衝突的 port\n但是內部 port 使用的依然是 5432 如果在容器網路內直接溝通，例如 Laravel 的 .env 設定的 port\n當透過容器外部網路線連線時使用調整後錯開的 port 連線正常\n但是當執行 php artisan migrate 之類指令，執行者是容器時\n要使用的卻是內部的 5432 port，如此在管理上會十分麻煩\n此情境下可以透啟動容器時指定內部運行的 port 來解決\npostgre: container_name: trp_stage_postgre ports: - \u0026#34;5430:5430\u0026#34; image: \u0026#34;postgres:12.6\u0026#34; volumes: - /trp/database/stage/database_data:/var/lib/postgresql/data # persist data even if container shuts down command: -p 5430 environment: POSTGRES_USER: ${TRP_DB_USER} POSTGRES_PASSWORD: ${TRP_DB_PASSWORD} POSTGRES_DB: ${TRP_DB_NAME} restart: always 如上面的設定中 command: -p 5430 指定了內部 postgres 使用的 port\n所以在 ports: 設定中就直接將外部 port 5430 指定給內部的 port 5430\n這樣不管在容器內或外部都可以使用一樣的 port 來進行連線\n",
    "ref": "/blog/202103-build-postgresql-database-useing-docker/"
  },{
    "title": "反向代理 - 在 Docker 環境建置",
    "date": "",
    "description": "介紹基本反向代理以及在 Docker 環境中建置",
    "body": "反向代理的基本說明，以及在 Docker 容器中如何建立反向代理\n反向代理 系統設計 - 正向代理跟反向代理\n不同實體主機 使用 nginx proxy-pass 目標  使用者造訪指定網頁路徑 /new_path 或是整個跳轉 / 設定測試機 nginx proxy_pass 使其跳轉到其他主機專案相同路徑下 確認使用者 IP 沒有被變成為代理伺服器的 IP 確認在代理目標的專案可以讀取 Cookie 確認 Post 請求的 payload 也會被轉送過去  設定 nginx config 第一台主機的 nginx 設定 # 把所有前往 domain/new_path 的請求反向代理到另一台主機上 location /new_path { # 要代理到哪個網址 proxy_pass http://laravel55.test.com; # 傳送使用者真實 IP 到目標主機 proxy_set_header X-Real-IP $remote_addr; # 設定伺服器為代理前的伺服器，否則 HTTP_HOST 會變成 proxy 那台代理伺服器的位址 proxy_set_header Host $host; # 設定 cookie 轉發 proxy_set_header Cookie $http_cookie; # 用來確認最初的用戶端原始 ip 位置 proxy_set_header X-Forwarded-Host $host; # 記錄從使用者端出來經過的每個代理 X-Forwarded-For: \u0026lt;client\u0026gt;, \u0026lt;proxy1\u0026gt;, \u0026lt;proxy2\u0026gt; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 識別網路連線協定 proxy_set_header X-Forwarded-Proto $scheme; # 隱藏伺服器資訊 proxy_hide_header Server; proxy_hide_header X-Powered-By; # 因為自行加大 header 所以把空間也加大 proxy_headers_hash_bucket_size 128; proxy_headers_hash_max_size 512; } 第二台主機的 nginx 設定 server { listen 80; server_name ray200; root /home/toc/www/laravel55/public; access_log /var/log/nginx/www/laravel55.access.log; error_log /var/log/nginx/www/laravel55.error.log; index index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~* \\.(jpg|jpeg|gif|css|png|js|ico|html|svg|ttf|woff|woff2|eotD)$ { access_log off; expires max; } location ~ \\.php$ { include snippets/fastcgi-php.conf; # php-fpm 的位置 fastcgi_pass 127.0.0.1:9000; } } 注意事項  server_name 必須要是 proxy_pass 過來那台的 domain，如果不這樣設定，proxy_pass 過來會進到預設的 server_name 下 在程式中判斷真實 IP 的方法要改成讀讀取 header 中的 x-real-ip 才是真實使用者 ip 位置  確認 cookie 可以讀取 如果設定 nginx 有設定 proxy_set_header Cookie $http_cookie;\n那 dump($_COOKIE); 可以取得 cookie，但是 Laravel 內建的 request()-\u0026gt;cookie(); 卻沒有取到值\n解決方案 Laravel 預設的 web middleware \\App\\Http\\Middleware\\EncryptCookies::class, 會要求 cookie 是加密過後的，如果沒有加密當然就讀不到。\n解決方案一個是在 EncryptCookies 這個 class 中的 $except 加入要排除的 cookie 名稱，另一個就是直接把 middleware 註解掉。\n 使用 Docker 架構示意圖 參考資料：How to set up NGINX Docker Reverse Proxy?\n步驟 1. 手動建立 network  反向代理會根據載入的設定檔把請求導向到指定的容器名稱內\n故代理的目標容器必須在同一網路內，才能直接使用容器名稱做代理目標\n 因為不想讓 network 前面帶上 prefix，還有避免依賴，所以手動建立 network\ndocker network create nginx-network 這個情境屬於來自外部的 nginx-proxy，要多給一個 external network 有需要連接到這個 network 裡面的服務都要設定\nnetworks: default: external: name: nginx-network 如此就可以讓不同 docker-compose.yml 中的服務互相溝通：官方說明\n2. 建立測試用的服務 因為懶得建太複雜的服務，所以抓現成的 portainer 服務來做為 proxy 的目標\n只是為了要有一個只要 docker-compose up 就可以運行的服務，也可以換成自己比較熟的映像檔\n為了測試從 80 port poxy 到其他 port，所以這邊開在 8080 port\n服務啟動之後可以先去 localhost:8080 查看 portainer 服務有沒有啟動\nversion: '3' networks: default: external: name: nginx-network services: portainer: container_name: nginx_test_portainer image: portainer/portainer-ce command: -H unix:///var/run/docker.sock restart: always ports: - 8080:9000 volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data volumes: portainer_data: 3. Nginx 的 proxy 設定 3.1 設定 docker-compose.yml version: '3' networks: default: external: name: nginx-network services: nginx: container_name: test_nginx image: nginx:1.18 ports: - \u0026quot;80:80\u0026quot; - \u0026quot;443:443\u0026quot; volumes: - ./conf.d/:/etc/nginx/conf.d/ - ./ssl/:/ssl/ 3.2 設定 mount 進去給反向代理伺服器使用的 nginx config 可以看到底下設定中，我們把所有發往 test.example 網址的請求都轉到\nhttp://nginx_test_portainer:9000 在容器中使用的模式是\n http://{container_name}:{port}\n 可以看到 container_name 對應了上面建立測試服務時候使用的容器名稱\n而 port 對應到了容器的內部 port！\n這邊特別把上面的容器內外使用的 port 區隔開來顯示差別，我們代理的目標是內部的 9000 port\n而不是對外的 8080 port\nserver { listen 80; listen [::]:80; server_name test.example; return 301 https://$host$request_uri; } server { listen 443 ssl; listen [::]:443 ssl; server_name test.example; ssl_certificate /ssl/ssl.crt; ssl_certificate_key /ssl/ssl.key; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { proxy_set_header Host $host; proxy_set_header Cookie $http_cookie; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $host; proxy_pass http://trp_portainer:9000; } } 要特別注意的是，這邊 proxy_pass 的目標網址中，http:// 不可以省略\n如果轉址過去的網址有自己的 https 證書驗證(例如另一個 nginx 環境)，則必須改成 https:// 開頭\n參考資料：What value should I use for Nginx proxy_pass running in Docker?\n3.3 編輯 etc/hosts 127.0.0.1 test.example 接著啟動 nginx 服務，用瀏覽器開啟剛剛設定的 test.example\n正確設定的話，監聽 80 port 的 nginx 服務應該會把所有目標是 test.example 的請求利用 proxy_pass 送到 portainer 容器的指定 port\n所以畫面上會顯示 portainer 服務的畫面\n 要在所有服務都啟動之後再啟動反向代理服務，否則會報錯指出被代理的容器目標不存在\n 注意事項 如果要把全部沒有匹配到的 server_name 請求統一處理\n可以在指定的 nginx config 加上 default_server 定義\n如果沒有定義 default_server，則第一個 server 會被預設成 default server \nserver { listen 8080 ssl default_server; listen [::]:8080 ssl default_server; ssl_certificate /ssl/ssl.crt; ssl_certificate_key /ssl/ssl.key; # Virtual Host Domain server_name _; # where code is root /var/trp/dev/www/trp_backend/public; index index.php index.html index.htm; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { try_files $uri /index.php =404; fastcgi_pass trp_dev_php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ /\\.ht { deny all; } } 因為要處理沒有被其他 server_name 捕獲的請求\n所以 server_name 就不是什麼重點，可以用 _, __, ___ 都可以\n這個情境會發生在當前端的 API 設定檔使用的路徑網址是指定後端容器名稱的時候 因為不是使用網址經過反向代理轉發，而是直接將請求發至容器\n而這個 nginx 容器中又有多個 server config 設定\n所以 nginx 沒有 server_name 可以判斷要使用哪個 config 設定\n案例說明 同一個 nginx 容器(dev_nginx) 裡面有多個 server config\n alex_backend john_backend dev_backend  如果現在有一個在同樣 docker network 的前端容器要打 API 到 dev_backend\n他會在設定檔指定網址是 dev_nginx\n這時候問題就來了，當 dev_nginx 收到這個請求會不知道是發給誰的\n如果沒有設定 default_server，就會把請求派發給第一個 server，也就是 alex_backend\n這不是我們要的結果\n所以會把 dev_backend 設定為 default_server\n如此之後，只要是送進這個容器的請求\n若沒有被其他設定檔捕獲，就會被送進 dev_backend 處理\n",
    "ref": "/blog/202102-reverse-proxy-in-docker-service/"
  },{
    "title": "Laravel 執行環境建置",
    "date": "",
    "description": "介紹 Laravel 執行環境所需要的環境設定，包含 composer 安裝",
    "body": "開發 Laravel 專案所需要做的設定與套件安裝，不論是在遠端主機或是本機都適用\n更新套件包 sudo apt-get update 安裝 composer php -r \u0026#34;copy(\u0026#39;https://getcomposer.org/installer\u0026#39;, \u0026#39;composer-setup.php\u0026#39;);\u0026#34; php -r \u0026#34;if (hash_file(\u0026#39;sha384\u0026#39;, \u0026#39;composer-setup.php\u0026#39;) === \u0026#39;756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3\u0026#39;) { echo \u0026#39;Installer verified\u0026#39;; } else { echo \u0026#39;Installer corrupt\u0026#39;; unlink(\u0026#39;composer-setup.php\u0026#39;); } echo PHP_EOL;\u0026#34; php composer-setup.php php -r \u0026#34;unlink(\u0026#39;composer-setup.php\u0026#39;);\u0026#34; 執行結果 Composer (version 2.0.12) successfully installed to: //composer.phar Use it: php composer.phar 將指令改成全域 執行後可以直接使用 composer 指令操作\n很方便，建議要執行這個步驟\nmv composer.phar /usr/local/bin/composer 安裝 PHP extension 以 PHP 版本 7.4 的主機為例\n要在容器外運行 composer install，需要安裝以下 extension\n php7.4-mbstring php7.4-cli php7.4-gd ext-dom(php-xml) zip unzip php7.4-zip  apt install php7.4-cli apt-get install mbstring ext-dom zip unzip php7.4-zip php7.4-mbstring php-xml php7.4-gd 安裝資料庫對應的 extension 依照專案使用的資料庫自行安裝\n例如：\n php7.4-pgsql php7.4-mysql  php artisan 必要套件 php artisan 要在 php 指令介面(php Command Line Interface) 下執行\n所以必須依照自身 php 版本安裝 cli 套件\napt install php7.4-cli  以上就是建置 Laravel 環境所需要的最基本設定\n若是容器化的使用者，在打包 php 映像檔的時候一併執行即可\n",
    "ref": "/blog/202102-laravel-environment-basic-settings/"
  },{
    "title": "Ngrok 讓 localhost 可以被外部連線",
    "date": "",
    "description": "Ngrok 開發測試 webhook 的利器",
    "body": "ngrok 做為一個轉發的伺服器，他可以把外界的請求轉發到你指定的 Port\n使用的背景原理是連接到 ngrok 雲端伺服器將你本機指定的地址公開\n再將由 ngrok 一串公開的網址來存取內容\n他的優點是快速而且還提供了 https 的服務讓你使用上更安全，甚至你還可以設置密碼保護\n官方文件與載點：https://ngrok.com/download\n安裝 Mac brew install ngrok Linux 確認自己的主機硬體架構\ncat /proc/cpuinfo 再去官網下載指定檔案依照官網安裝 或是直接使用 snap 安裝\nsudo apt update sudo apt install snapd sudo snap install ngrok 使用 啟動並監聽 8080 Port\nngrok http 8080 就可以看到對外開放的網址\n註冊 ngrok 不註冊的話過一段時間就會被斷線，開發階段使用免費版本就足夠了\nNgrok authtoken 頁面 複製 Authtoken 之後到 terminal 輸入\nngrok authtoken {Your Authtoken} 看到以下訊息代表認證完成\nAuthtoken saved to configuration file: /Users/user_name/.ngrok2/ngrok.yml ",
    "ref": "/blog/202102-ngrok-share-your-local-development-site/"
  },{
    "title": "Portainer - 視覺化管理 Docker 的工具",
    "date": "",
    "description": "介紹如何使用 Portainer 視覺化管理 Docker 服務",
    "body": "本機開發大部分使用指令操作，或是使用 Docker 本身的 GUI 介面管理服務\nPortainer 是一個 open-source 的 UI tool\n可以查看 docker image, container，並執行 start, stop, restart, remove 等動作\n也可查看每個 container 的 log 及 error\n在雲端主機上啟動服務的話，即使沒有 Docker 執行權限的人也可以透過帳號密碼登入\n使用視覺化的介面進行 Docker 服務的各種管理\nDockerhub image: portainer/portainer-ce\ndocker-compose.yml version: \u0026#39;3\u0026#39; services: portainer: image: portainer/portainer-ce command: -H unix:///var/run/docker.sock restart: always ports: - 9000:9000 - 8000:8000 volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data volumes: portainer_data: 為了 edge agent 而開啟 8000 port：文件說明\n 補充 如果遠端主機不想開放 port 造成任意使用者都有機會開啟後台畫面\n可以使用超外道的連線方式：How to Create SSH Tunneling or Port Forwarding in Linux\nssh -i ~/.ssh/id_rsa -L 8081:localhost:9000 ray@{你的遠端主機 IP} 在容器啟動後可以在本機終端機執行\n接著就可以在本機 localhost:8081 看到我們在遠端主機的 9000 port\n原理是透過 ssh 連線將本機 8081 port 的請求轉發到遠端主機的 9000 port\n這個方法不論遠端防火牆有沒有開放該 port 都可以執行，十分不講武德\n也不限於 Portainer 服務才能使用\n",
    "ref": "/blog/202101-portainer-open-source-container-management-gui/"
  },{
    "title": "Docker 筆記 3 - docker-compose",
    "date": "",
    "description": "介紹如何使用 docker-compose 管理多個容器",
    "body": "如果同時要管理彼此是有關連的多個 docker 容器，單純使用 docker 指令必須要自行記得容器之間的關聯\n而使用 docker-compose，則可以輕鬆定義多容器服務\n簡介  Docker for Mac 預設 python 所寫成的工具 由yaml定義 設定檔為 docker-compose.yml 依賴 docker 版本  官方文件：docker-compose\n設定檔構成 docker-compose.yml 由兩個部分所構成\n version（版本要字串） services  key -\u0026gt; DNS name(hostname)    docker-compose 範例\n其他工具 docker-swarm  看成 kubernetes 的分身 落地方便（kubernetes 準備工作很多） 高可用性 HA 價格便宜  組成（Node）\n 分兩個節點。  Manager：  分派任務給 worker node 同時也是 worker node 控制整個 Docker Swarm 的部署 主控制節點 如果死掉，整個 docker swarm 就死掉了 可以有多台 manager，但只有一台 \u0026amp;*$%^^#???   Worker：  被分派任務 不會主動分派任務 不知道其他 worker node     可以隨時 rolling update。 在所有 node 底下：  Service：  一個Service包含一種container Service啟動不代表container啟動 可以對container進行health check Service可以啟動複數個container(replicas)   Task  主要是由Service帶起來的 代表在docker container內執行的指令 task會在node上到執行結束為止     ",
    "ref": "/blog/202101-docker-note-3-introduce-docker-compose/"
  },{
    "title": "Docker 筆記 2 - 基本使用",
    "date": "",
    "description": "Docker 的基本使用方法",
    "body": "容器化可以隔離不同環境，將環境打包後工程師可以專注開發，不用花過多心力在開發環境安裝上\n而 Docker 是目前非常成熟且流行的一個容器化技術\n玩轉docker指令 查看容器資訊 docker ps 列出所有運行中的容器 docker ps -a 列出所有存在的容器 看 log docker logs [CONTAINER] 印出 log docker logs -f [CONTAINER] 持續印出最新 log 執行容器 從本地環境的 image 建立 container\n如果不存在從 repository 訪問，private repo 必須要有「登入」行為\nimage的格式可以為[IMAGE NAME]:[TAG]\ndocker run 範例： # 執行nginxdocker run -idt nginx# 執行nginx並且暴露port為8080docker run -idt -p 8080:80 nginx# 執行nginx在8080，在失敗的時候會自動重啟動docker run -idt -p 8080:80 --restart on-failure nginx# 執行nginx，結束後移除docker run --rm -idt nginx常用到的 flag  -d detach 將 container 置於背景執行 -i interactive 維持 STDIN，可互動 -t 提供 tty 允許 container 使用 tty -p expose socket 對外:對內 port (ex -p 8080:80) -p Host Port:Docker Port --restart 失敗重啟(always-default, none, on-failure) --rm 關閉後 container 自動消滅，若不刪可能會不斷累積，即使已經死掉了  常用指令 進入運行中的容器，並開啟終端機指令介面\ndocker exec -ti [CONTAINER] bash 取得 container 或是 image 的 Metadata\ndocker inspect [CONTAINER] 刪除 docker container\ndocker rm [CONTAINER] 刪除 docker image\ndocker rmi [IMAGE] 查看容器運行 process\ndocker top [CONTAINER] 其他指令 使用 Dockerfile 建立 docker image\n-f 手動指定 Dockerfile 名稱\n# 在目前的資料夾建立image，來源是Dockerfile docker build . -t image-name # 在目前的資料夾建立image，來源是Dockerfile-alt docker build . -t image-name -f Dockerfile-alt 將 docker image 從 repository 上拉/推上去\n要先登入 docker login\ndocker push / pull 登入 docker repository\ndocker login 怎麼寫自己的dockerfile  先註冊 Docker Hub Alpine Linux  體積非常的小 (5MB) 有完整的Linux架構 豐富的元件支援    常見 Dockerfile 命令 基本  FROM：指定基底 image，不指定版本的話預設都是 latest RUN：  docker build 時候執行命令，裝一些相依套件。 每一個 RUN 都是獨立事件   ARG：  container docker build 時的建置參數 無法在 container 中被使用   ENV：  printenv 容器內使用的環境變數 格式：ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; 或是 ENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt;    檔案複製  COPY：  複製「來源文件\\目錄」到的容器中的「文件\\目錄」中 COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;source path\u0026gt;... \u0026lt;dist path\u0026gt; dist path 可以是 Container 內的絕對路徑，也可以是相對於 WORKDIR 的相對路徑 會保留來源數據的各種屬性   ADD：  強化版的 COPY ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;source path\u0026gt;... \u0026lt;dist path\u0026gt; 允許 source path 是一個 URL 文件權限自動設置為 600    執行指令  ENTRYPOINT：  Container 起來預設會執行的指令 最後指令，啟動時要保持在前景的指令   CMD：  container起來預設會執行的指令（或參數） ENTRYPOINT, CMD 同時存在 CMD 當參數使用   WORKDIR(cd + mkdir):  初始容器內工作目錄    指令差異 ARG vs ENV ARG 由建立 image 的時候帶入\ndocker build . --build-arg FOO=bar ENV是在docker container內作為環境變數使用\nCMD vs ENTRYPOINT ENTRYPOINT 在 container 啟動時預設執行 CMD 在 ENTRYPOINT 存在時作為參數使用\nFROM ubuntu ENTRYPOINY [\u0026#34;ping\u0026#34;] CMD [\u0026#34;localhost\u0026#34;] COPY vs ADD COPY 適用在將本地端的檔案複製到container內\nADD 適用將遠端的檔案複製到container內\n除錯  docker: Got permission denied\n 這個錯誤是因為當前使用者的權限不足\n可以將使用者提升至 root 保證權限\n但是比較安全且正確的做法應該是\n 建立 docker 執行群組 將使用者加入 docker 群組  指令如下，需要退出重新登錄後才會生效！\nsudo groupadd docker sudo usermod -aG docker user_name ",
    "ref": "/blog/202101-docker-note-2-basic-usage/"
  },{
    "title": "Docker 筆記 1 - 認識 Docker",
    "date": "",
    "description": "介紹什麼是 Docker，以及容器化技術",
    "body": "容器化可以隔離不同環境，將環境打包後工程師可以專注開發，不用花過多心力在開發環境安裝上\n而 Docker 是目前非常成熟且流行的一個容器化技術\n將OS做為 Application 化\n所有 container 只能允許一個指令執行\n預設權限都會是 root\n商業來說\n 方便部署 可攜性  容器進化史 What is a Container?\n名詞介紹  Stateful Stateless：在未設的前提之下，每次建立時會消除舊的資料 Repository  就像是 apt、brew 或是 yum 的來源一樣 存了很多 image (Package)   Image  相當於 Package 產生特殊的 cache，本地有 cache 的話，就不需再從 Respository (如 Docker hub) 抓   Container  由 image 建立而成 相當於一個一個的程式，可以持續執行 必須要有一個 foreground 在跑的程式   Network  none：沒有網路 bridge：區網 overlay：不同網段 container：Docker 預設的網路連線, 無法由外部直接進來 host：與本機共用網路介面   Volume  Docker 內的持久化(Stateful)空間，可以 stateful 的秘密(空間) 等同本機空間    架構 生命週期  client 呼叫 docker daemon docker daemon 與 host network / host cgroups 溝通 判斷 docker container 是否存在 從 local image 將 layer 解開 如果 local image 不存在的話從 repository 拿 建立 docker container  學習資源 線上練習環境：Play with Docker\nDocker 基本觀念與使用教學：自行建立 Docker 影像檔 - G. T. Wang\n鸟瞰Docker\n30 天與鯨魚先生做好朋友\n",
    "ref": "/blog/202101-docker-note-1-what-is-docker/"
  },{
    "title": "[Express+Vue 搭建電商網站] 22 使用 Docker 將專案容器化",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用 Docker 將專案容器化",
    "body": "接著我們會把整個專案使用 Docker 來將服務容器化，也會在 MongoDB 設定身份驗證機制\n如果對 Docker 不熟的話必須先去了解，才有辦法進行\n或是直接跳過這個章節 交給熱心的攤主處理\n在這邊我們會用到三個容器\n nginx 伺服器：處理 Vue 框架實現的前端靜態頁面 api：運行我們使用 Express 建立的 API 服務 db：就是一個運行 MongoDB 資料庫的容器  流程會變成\n 資料進來由 nginx 分派，如果是前端或是靜態資源就直接從 nginx 回傳\n若是 API 類型的請求則轉交給 API 容器處理後再回傳資料。\n 這種架構有以下優勢\n 透過 nginx 過濾非法請求 解決前後端跨域問題，因為兩者間都透過相同端點訪問 可以輕鬆擴增伺服器大小，並且使用 Nginx 做負載平衡  前端容器化 首先容器化的是先前用 Vue 寫的前端專案，將專案打包成靜態頁面\nnpm run build 接著增加 nginx 設定檔 client/config/nginx.conf\nserver { listen 80; root /www; index index.html; sendfile on; sendfile_max_chunk 1M; tcp_nopush on; gzip_static on; location /api/v1 { proxy_pass http://api:3000; } location / { try_files $uri $uri/ /index.html; } } 其中要特別注意的是 location 規則\n 請求目標如果是 /api/v1，那就把請求傳到 api 容器裡 請求目標 /，則直接回傳靜態頁面 index.html  然後要回頭稍微修改一下前端訪問後端的網址，打開 client/src/store/actions.js 修改 API_BASE 成\nconst API_BASE = \u0026#39;/api/v1\u0026#39;; 這樣改了之後前端在對 API 發起請求時就是取決於當前頁面的網址，而不是固定的 http://localhost:3000/api/v1\n接著就是要撰寫 Docker 相關設定\n首先建立 client/src/Dockerfile\nFROMnginx:1.13# 刪除預設的 Nginc 設定RUN rm /etc/nginx/conf.d/default.conf# 加入自己定義的 Nginx 設定檔COPY config/nginx.conf /etc/nginx/conf.d/# 將前端靜態檔案映射到容器的 /www 目錄下COPY dist /www接著建立 client/.dockerignore，裡面只有短短一行\nnode_modules 代表不 mount 進 docker 的資料夾\n後端容器化 前端容器化之後，接著準備進行後端的容器化。首先把寫死的 MongoDB 連線字串透過環境變數注入，修改 server/app.js 連線資料庫的部分成\nmongoose.connect(process.env.MONGO_URI || `mongodb://localhost:27017/test`); 接著一樣新建 server/Dockerfile\nFROMnode:10# 指定工作目錄為 /usr/src/app，接下来的指令全部在這個路徑下操作WORKDIR/usr/src/app# 將 package.json 複製到根目錄COPY package*.json ./# 安裝 npm 依賴RUN npm install# 複製全部程式內容COPY . .# 設定環境變數ENV NODE_ENV=production ENV MONGO_URI=mongodb://db:27017/testENV HOST=0.0.0.0ENV PORT=3000 # 曝露出 3000 portEXPOSE3000# 設定映像檔內執行的指令CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;]和前端一樣建立 server/.dockerignore 確定不會把 node_modules 給映射進容器裡\n裡面也只有一行：\nnode_modules Docker Compose Docker Compose 可以讓我們很好的管理 docker 容器，只需要透過一個 YAML 檔就可以修改設定。\n在專案的根目錄下建立（跟 client 和 server 兩個資料夾同層）docker-compose.yml\nversion: \u0026#39;3\u0026#39; services: db: image: mongo restart: always api: build: server restart: always ports: - 3000:3000 nginx: build: client restart: always ports: - 8080:80 可以看到我們建立了三個 service，對應到前面說的 db、api、nginx\n db：指定使用 mongo 映像檔，然後當服務意外停止則總是重啟 api：映像檔透過 server 資料夾內來建立，對外 port 為 3000:3000 nginx：映像檔透過 client 資料夾內來建立，對外 port 為 8080:80，外部的 8080 port 會指向到內部 80 port   如果 docker-compose.yml 中的 service 使用 image 指定映像檔，則會去Docker Hub 上拉回指定的映像檔\n若是使用 build 則會根據指定目錄下的 Dockerfile 來建立映像檔。\n 接著就是測試的時間！打開 Docker 之後，在終端機輸入\ndocker-compose up --build 第一次執行會多花一些時間，因為先前提過的要從Docker Hub 上拉回指定的映像檔，如下圖\n可以藉由\ndocker ps 來觀察目前所有的容器狀態，看起來沒問題的話就可以開啟 localhost:8080 來看看專案是不是跟原本一樣\nMongoDB 身份驗證 在之前的設定中我們的 MongoDB 資料庫並沒定任何身份驗證\n所以任何人只要能夠發送請求到資料庫都可以對資料庫做修改，這是一個可怕的資安問題！\n接著我們要來搞定 MongoDB 的身份驗證，增加系統的安全性\n修改 MongoDB 連線設定 打開 server/app.js，修改連線資料庫的部分成以下\nongoose.connect(process.env.MONGO_URI || `mongodb://localhost:27017/test`, { useNewUrlParser: true, useUnifiedTopology: true, user: process.env.MONGO_USER, pass: process.env.MONGO_PASSWORD, }); 這代表\n useNewUrlParser：使用新的 MongoDB 驅動 URL 解析器 useUnifiedTopology：使用新的連線管理引擎，支持重新連線，這樣可以大大提升連線穩定性 user：連線的使用者名稱，通過環境變數注入 pass：連線使用的密碼，通過環境變數注入  Dockerfile 中注入環境變數 在 server/Dockerfile 中加入下面的環境變數：\nENV NODE_ENV=production ENV MONGO_URI=mongodb://db:27017/adminENV MONGO_USER=mongoadmin ENV MONGO_PASSWORD=secret ENV HOST=0.0.0.0ENV PORT=3000 可以發現一些不同的地方，調整了 MONGO_URI，把預設的 test 換成 admin\n這是為了啟用驗證功能並且使用 admin 作為 Authentication Database 的使用者\n設定 Docker Compose 預設密碼 接著在 docker-compose.yml 裡面幫 db 服務加入預設密碼的環境變數\ndb: image: mongo restart: always environment: MONGO_INITDB_ROOT_USERNAME: mongoadmin MONGO_INITDB_ROOT_PASSWORD: secret測試 首先使用\ndocker-compose down --volumes 不只關閉了原本運行中的 docker 容器，還透過 --volumes 把原本的建立 MongoDB 的容器徹底刪除\n若不這麼做，之後重啟容器會跳過初始化使用者的過程，這樣我們的驗證資料庫就沒辦法被建立，而會載入之前的資料\n接著重新啟動容器\ndocker-compose up --build 應該會看到網頁一切正常，不過資料庫已經有了驗證，不是「裸奔」的狀態了\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202012-express-vue-build-ecommerce-22-docker-containerized/"
  },{
    "title": "[Express+Vue 搭建電商網站] 21 使用 Element UI 加入載入過動畫",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 套用 Element UI 加入載入動畫",
    "body": "等待的時候很無聊，所以我們加點動畫\n基本的動畫是用來告訴使用者動作執行結果，做到這樣使用者才知道自己剛剛做的事情有沒有完成\nManufactureForm 組件 在這個組件中，會在使用者新建或是修改製造商資訊後，當後端完成處理前出現 Loading 的動態效果\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;manufacturerInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; label-width=\u0026#34;180px\u0026#34; v-loading=\u0026#34;loading\u0026#34; element-loading-text=\u0026#34;Loading...\u0026#34; element-loading-spinner=\u0026#34;el-icon-loading\u0026#34; element-loading-background=\u0026#34;rgba(0, 0, 0, 0.8)\u0026#34; \u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;manufacturerData.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; native-type=\u0026#34;submit\u0026#34; @click=\u0026#34;onSubmit\u0026#34; \u0026gt;Update Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;model\u0026#34;, \u0026#34;isEditing\u0026#34;], data() { return { manufacturerData: { name: \u0026#34;\u0026#34; } }; }, created() { this.manufacturerData = this.model; }, watch: { model(val) { this.manufacturerData = val; } }, computed: { loading() { return this.$store.state.showLoader; } }, methods: { onSubmit() { this.$emit(\u0026#34;save-manufacturer\u0026#34;, this.manufacturerData); } } }; \u0026lt;/script\u0026gt; 使用 element-ui 组件庫提供的指令 v-loading 來判斷 loading 是否為真來決定是否要顯示載入動畫\n而 loading 這個 computed 屬性使用 store.state.showLoader 的資料\n同時也把當初在 ProductForm 中解決過「無法修改標單內容」的問題用同樣方法解決了\nProductForm 組件 當然啦，製造商表單的效果在 ProductForm 中應該也要有\n接著就打開 ProductForm 組件進行編輯\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;productInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; label-width=\u0026#34;180px\u0026#34; v-loading=\u0026#34;loading\u0026#34; element-loading-text=\u0026#34;Loading...\u0026#34; element-loading-spinner=\u0026#34;el-icon-loading\u0026#34; element-loading-background=\u0026#34;rgba(0, 0, 0, 0.8)\u0026#34; \u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Price\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.price\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Manufacturer \u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;modelData.manufacturer.name\u0026#34; clearable placeholder=\u0026#34;請選擇製造商\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34; :label=\u0026#34;manufacturer.name\u0026#34; :value=\u0026#34;manufacturer.name\u0026#34; \u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Image \u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.image\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Description \u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;modelData.description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; native-type=\u0026#34;submit\u0026#34; @click=\u0026#34;onSubmit\u0026#34; \u0026gt;Update Product\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Product\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { modelData: { manufacturer: { name: \u0026#34;\u0026#34; } } }; }, props: [\u0026#34;model\u0026#34;, \u0026#34;manufacturers\u0026#34;, \u0026#34;isEditing\u0026#34;], created() { const product = this.model; this.modelData = { ...product, manufacturer: { ...product.manufacturer } }; }, watch: { model(val) { this.modelData = val; } }, computed: { loading() { return this.$store.state.showLoader; } }, methods: { onSubmit() { // 表單中只有 modelData.manufacturer.name，但後端需要整個製造商物件，所以要找出對應的製造商物件寫入到 modelData 中  const manufacturer = this.manufacturers.find( item =\u0026gt; item.name === this.modelData.manufacturer.name ); this.modelData.manufacturer = manufacturer; this.$emit(\u0026#34;save-product\u0026#34;, this.modelData); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .productInfo { padding-top: 10px; } .form { margin: 0 auto; width: 500px; } .el-input__inner { height: 60px; } \u0026lt;/style\u0026gt; 在這個組件中我們也加入了 loading() 這個 computed 屬性\n實現提示功能 在組件中加入功能後，我們要實際把提示功能完成\n首先打開 src/store/actions.js 加入提示訊息的功能\nimport axios from \u0026#39;axios\u0026#39;; import { Message } from \u0026#39;element-ui\u0026#39;; import { ADD_PRODUCT, ADD_PRODUCT_SUCCESS, PRODUCT_BY_ID, PRODUCT_BY_ID_SUCCESS, UPDATE_PRODUCT, UPDATE_PRODUCT_SUCCESS, REMOVE_PRODUCT, REMOVE_PRODUCT_SUCCESS, ALL_PRODUCTS, ALL_PRODUCTS_SUCCESS, ALL_MANUFACTURERS, ALL_MANUFACTURERS_SUCCESS, MANUFACTURER_BY_ID, MANUFACTURER_BY_ID_SUCCESS, ADD_MANUFACTURER, ADD_MANUFACTURER_SUCCESS, UPDATE_MANUFACTURER, UPDATE_MANUFACTURER_SUCCESS, REMOVE_MANUFACTURER, REMOVE_MANUFACTURER_SUCCESS, } from \u0026#39;./mutation-types\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; export const productActions = { allProducts({ commit }) { commit(ALL_PRODUCTS) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { commit(ALL_PRODUCTS_SUCCESS, { products: response.data, }); }) }, productById({ commit }, payload) { commit(PRODUCT_BY_ID); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(PRODUCT_BY_ID_SUCCESS, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(REMOVE_PRODUCT); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`) .then(() =\u0026gt; { // 回傳 productId，用來刪除對應商品  commit(REMOVE_PRODUCT_SUCCESS, { productId, }); Message({ message: \u0026#39;產品刪除完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;產品刪除失敗\u0026#39;); }) }, updateProduct({ commit }, payload) { commit(UPDATE_PRODUCT); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product) .then(response =\u0026gt; { commit(UPDATE_PRODUCT_SUCCESS, { product: response.data, }); Message({ message: \u0026#39;商品更新成功\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;商品更新失敗\u0026#39;); }) }, addProduct({ commit }, payload) { commit(ADD_PRODUCT); const { product } = payload; axios.post(`${API_BASE}/products`, product) .then(response =\u0026gt; { commit(ADD_PRODUCT_SUCCESS, { product: response.data, }) Message({ message: \u0026#39;已新建商品\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;商品建立失敗\u0026#39;); }) } }; export const manufacturerActions = { allManufacturers({ commit }) { commit(ALL_MANUFACTURERS); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(ALL_MANUFACTURERS_SUCCESS, { manufacturers: response.data, }); }) }, manufacturerById({ commit }, payload) { commit(MANUFACTURER_BY_ID); const { manufacturerId } = payload; axios.get(`${API_BASE}/manufacturers/${manufacturerId}`).then(response =\u0026gt; { commit(MANUFACTURER_BY_ID_SUCCESS, { manufacturer: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(REMOVE_MANUFACTURER); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`) .then(() =\u0026gt; { // 回傳 manufacturerId，用來刪除對應的製造商  commit(REMOVE_MANUFACTURER_SUCCESS, { manufacturerId, }); Message({ message: \u0026#39;製造商刪除完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商刪除完成失敗\u0026#39;); }) }, updateManufacturer({ commit }, payload) { commit(UPDATE_MANUFACTURER); const { manufacturer } = payload; axios.put(`${API_BASE}/manufacturers/${manufacturer._id}`, manufacturer) .then(response =\u0026gt; { commit(UPDATE_MANUFACTURER_SUCCESS, { manufacturer: response.data, }); Message({ message: \u0026#39;製造商更新完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商更新失敗\u0026#39;); }) }, addManufacturer({ commit }, payload) { commit(ADD_MANUFACTURER); const { manufacturer } = payload; axios.post(`${API_BASE}/manufacturers`, manufacturer) .then(response =\u0026gt; { commit(ADD_MANUFACTURER_SUCCESS, { manufacturer: response.data, }); Message({ message: \u0026#39;製造商建立完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商建立失敗\u0026#39;); }) } } 首先導入了 element-ui 组件庫提供的 Message 提示訊息組件\n接著在各個操作中加入提示訊息的物件，成功或失敗都會回傳對應的訊息\n接著開啟 src/store/mutations.js 做部分內容修改，為的是修改購物車的提示訊息\nexport const cartMutations = { [ADD_TO_CART](state, payload) { const { product } = payload; state.cart.push(product); Message({ message: \u0026#39;成功加入購物車\u0026#39;, type: \u0026#39;success\u0026#39; }) }, [REMOVE_FROM_CART](state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) Message({ message: \u0026#39;已從購物車移除商品\u0026#39;, type: \u0026#39;success\u0026#39; }) }, } 同樣導入了 element-ui 组件庫提供的 Message 提示訊息組件\n當使用者加入或移除購物車商品時就會收到提示了！\n結果看起來像這樣，十分酷炫有型\n重構到這邊，測試起來似乎又有點什麼問題\n那就是在表單按下更新後，看到了更新成功的訊息，但畫面上的資料似乎沒有同步成最新的\n當資料出現問題，應該依據 Vue 的單向資料流原則來修正\n使用者更新資料後，應該從後端同步更新資料到狀態池中進行渲染\n因此我們要修改的就是 src/store/actions.js 的內容\n可以大膽的猜測，是因為後端請求結束後 action 提交到 mutations.js 中的不是修改後的最新資料\n所以才沒有改變狀態池中的物件\n修改 src/store/actions.js 檔案中更新數據的部分\n兩個方法在不同的常數中，但為了節省版面就只展示其中關鍵的方法\nupdateProduct({ commit }, payload) { commit(UPDATE_PRODUCT); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product) .then(() =\u0026gt; { commit(UPDATE_PRODUCT_SUCCESS, { product: product, }); Message({ message: \u0026#39;商品更新成功\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;商品更新失敗\u0026#39;); }) }, updateManufacturer({ commit }, payload) { commit(UPDATE_MANUFACTURER); const { manufacturer } = payload; axios.put(`${API_BASE}/manufacturers/${manufacturer._id}`, manufacturer) .then(() =\u0026gt; { commit(UPDATE_MANUFACTURER_SUCCESS, { manufacturer: manufacturer, }); Message({ message: \u0026#39;製造商更新完成\u0026#39;, type: \u0026#39;success\u0026#39; }) }) .catch(() =\u0026gt; { Message.error(\u0026#39;製造商更新失敗\u0026#39;); }) }, 可以看到我們不理會 axios 返回的結果\n直接使用原本作為 payload 去執行 API 的資料回傳到 mutations 來修改狀態\n所以接著就要修改 mutations.js，將新的資料同步到狀態池中\n也是針對更新的部分做局部修改，將最新的資料同步到狀態池中\n[UPDATE_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { product: newProduct } = payload; state.products = state.products.map(product =\u0026gt; { if (product._id === newProduct._id) { return newProduct; } return product; }); state.product = newProduct; }, [UPDATE_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer: newManufacturer } = payload; state.manufacturers = state.manufacturers.map(manufacturer =\u0026gt; { if (manufacturer._id === newManufacturer._id) { return newManufacturer; } return manufacturer; }); state.manufacturer = newManufacturer; }, 於是我們就修好了表單的修改功能並直接顯示最新資料！\n這就是在實際開發中使用 element-ui 組件庫套用在前端樣板中的流程，並且一步一步的進行了重構\n到了這邊整個專案基本上已經可以正常運行了，使用者的體驗也得到的明顯的改善！\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202011-express-vue-build-ecommerce-21-elemen-ui-loading-animation/"
  },{
    "title": "[Express+Vue 搭建電商網站] 20 重構後的頁面功能恢復",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 重構後的頁面功能恢復",
    "body": "要是你跟老闆說：現在我們專案的畫面好看了，但是功能全壞了\n老闆應該會一臉問號問你在講什麼？\n廢話不多說，趕快來修好上一篇中被我們弄壞的功能！\n修復雙向綁定的問題 上一篇中有提過 element-ui 的輸入組件不接受 v-model 的功能\n所以為了雙向綁定資料，我們需要利用其他方法\nEdit 組件 首先打開 Edit 組件進行修復\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-form @save-product=\u0026#34;updateProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; :isEditing=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { created() { const { name = \u0026#34;\u0026#34; } = this.modelData || {}; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, model() { const product = this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); const res = { ...product, manufacturer: { ...product.manufacturer } }; return res; } }, methods: { updateProduct(product) { this.$store.dispatch(\u0026#34;updateProduct\u0026#34;, { product }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 這一步中我們又將 data 屬性中的 model 給恢復到了 computed 中，用來暫存 model 物件的資料提高效能\n而雙向綁定的問題會在其中的 ProductForm 解決\nProductForm 組件 我們來嘗試另一種方式修復雙向綁定，先看程式碼\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;productInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; label-width=\u0026#34;180px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Price\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.price\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Manufacturer \u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;modelData.manufacturer.name\u0026#34; clearable placeholder=\u0026#34;請選擇製造商\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34; :label=\u0026#34;manufacturer.name\u0026#34; :value=\u0026#34;manufacturer.name\u0026#34; \u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Image \u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;modelData.image\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Description \u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;modelData.description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Update Product\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Product\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { modelData: { manufacturer: { name: \u0026#34;\u0026#34; } } }; }, props: [\u0026#34;model\u0026#34;, \u0026#34;manufacturers\u0026#34;, \u0026#34;isEditing\u0026#34;], created() { const product = this.model; this.modelData = { ...product, manufacturer: { ...product.manufacturer } }; }, watch: { model(val) { this.modelData = val; } }, methods: { onSubmit() { const manufacturer = this.manufacturers.find( item =\u0026gt; item.name === this.modelData.manufacturer.name ); this.modelData.manufacturer = manufacturer; this.$emit(\u0026#34;save-product\u0026#34;, this.modelData); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .productInfo { padding-top: 10px; } .form { margin: 0 auto; width: 500px; } .el-input__inner { height: 60px; } \u0026lt;/style\u0026gt; 在上面的程式中，不直接使用父組件的 model 作為表單的資料物件\n而是在目前的組件中自訂一個新的 modelData 物件\n並且在組件剛被建立時就先從父組件取得 modle 物件，暫定為 product\n然後將 product 需要用到的屬性解構給 modelData 物件\n這樣就避免了表單物件操作 computed，但這只解決了一半問題，說好的雙向綁定呢？\n所以我們要透過監測組件的變化，利用 watch 方法監測使用者輸入\n並且將新的資料儲存到 modelData 物件中，這樣就完成雙向綁定啦！而且表單也可以隨意編輯\n商品資訊表單錯誤問題 當修改或是新建表單時，會看到錯誤的提示訊息：id 屬性未定義\n因為錯誤訊息說是在 ProductForm 中，就來看看發生什麼事情了吧\n應該都還記得，商品的物件的製造商包含了 id 和 name 屬性\n但是我們的下拉選單的 value 只有傳回 name\n而後端資料庫要求製造商物件必須也要有 id 屬性\n所以在送出時使用了 find 方法找到了對應 name 的製造商物件\n並且將 modelData 中的製造商物件覆蓋掉，這樣就符合後端資料庫的要求了！\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202011-express-vue-build-ecommerce-20-element-ui-fix-function/"
  },{
    "title": "[Express+Vue 搭建電商網站] 19 使用 Element UI 重構畫面",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 套用 Element UI 到頁面上",
    "body": "重構可能會造成一些功能癱瘓，本章先著重在畫面，讓畫面變美美噠\n後續的文章會把功能修復，莫急莫慌莫害怕\n管理後台畫面重構 由於我們之前在 App 組件中已經有了共用的工具列，所以打開 src/views/admin/Index.vue 修改成\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;admin-new\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;In Admin\u0026lt;/h1\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 後台商品列表頁面重構 接著打開後台的商品組件 src/views/admin/Products.vue，將 \u0026lt;template\u0026gt; 修改成\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;el-table class=\u0026#34;table\u0026#34; :data=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;名稱\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;price\u0026#34; label=\u0026#34;售價\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;manufacturer.name\u0026#34; label=\u0026#34;製造商\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;管理\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-button class=\u0026#34;modify\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;\u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/edit/\u0026#39; + scope.row._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt;\u0026lt;/el-button\u0026gt; \u0026lt;el-button class=\u0026#34;remove\u0026#34; @click=\u0026#34;removeProduct(scope.row._id), deleteRow(scope.$index, products)\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 看起來和前台的 ProductItem 組件中表格非常相似，差在對商品物件的操作\n一個是將商品加入或移出購物車，一個是刪除或修改商品\n後台編輯商品頁面重構 打開 ProductForm 組件，在 \u0026lt;template\u0026gt; 內使用組件庫提供的 el-form 表單組件代替原本簡陋的 form 表單\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;productInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; :model=\u0026#34;model\u0026#34; label-width=\u0026#34;180px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Price\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.price\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Manufacturer \u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;model.manufacturer.name\u0026#34; clearable placeholder=\u0026#34;请选择制造商\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34; :label=\u0026#34;manufacturer.name\u0026#34; :value=\u0026#34;manufacturer.name\u0026#34; \u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Image \u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.image\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;Description \u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;model.description\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Update Product\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Product\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 接著要解決 src/views/admin/Edit.vue 組件內傳入的 computed model 無法被編輯的問題\n理由是 input 作為受控的組件，會一直顯示 Vue 的綁定資料\n輸入框內容將無法進行編輯：Input 输入框\n結果送出之後還是沒反應，這很正常先繼續把畫面調好，等等我們會來修復它\n打開 Edit 組件，將原本在 computed 中的 model 屬性放到 data 屬性中，並移除原本在 computed 中的屬性\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-form @save-product=\u0026#34;updateProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; :isEditing=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { data() { const product = this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); return { // 回傳 product 的備份，是為了在修改 product 的備份之後，在保存之前不修改本地 Vuex store 的 product 屬性  model: { ...product, manufacturer: { ...product.manufacturer } } }; }, created() { const { name } = this.model; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, }, methods: { updateProduct(product) { this.$store.dispatch(\u0026#34;updateProduct\u0026#34;, { product }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 接著，長得跟 Edit 組件很像的 New 組件也一起重構\n\u0026lt;template\u0026gt; \u0026lt;product-form @save-product=\u0026#34;addProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34;\u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { data() { return { model: { manufacturer: { name: \u0026#34;\u0026#34; } } }; }, created() { if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; } }, methods: { addProduct(model) { this.$store.dispatch(\u0026#34;addProduct\u0026#34;, { product: model }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 後台編輯製造商頁面重構 和 Products 組件類似，開啟 Manufacturers 使用 el-table 替換掉原本的表單的 \u0026lt;template\u0026gt; 部分\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;manufacturers\u0026#34;\u0026gt; \u0026lt;el-table class=\u0026#34;table\u0026#34; :data=\u0026#34;manufacturers\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;製造商\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;管理\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-button class=\u0026#34;modify\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/manufacturers/edit/\u0026#39; + scope.row._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt; \u0026lt;/el-button\u0026gt; \u0026lt;el-button class=\u0026#34;remove\u0026#34; @click=\u0026#34;removeManufacturer(scope.row._id), deleteRow(scope.$index, products)\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34; \u0026gt;刪除\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 接著重構 NewManufacturers 組件，一樣將 computed 的 model 換到 data 屬性中\n\u0026lt;template\u0026gt; \u0026lt;manufacturer-form @save-manufacturer=\u0026#34;addManufacturer\u0026#34; :model=\u0026#34;model\u0026#34;\u0026gt;\u0026lt;/manufacturer-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ManufacturerForm from \u0026#34;@/components/ManufacturerForm.vue\u0026#34;; export default { data() { return { model: {} }; }, methods: { addManufacturer(model) { this.$store.dispatch(\u0026#34;addManufacturer\u0026#34;, { manufacturer: model }); } }, components: { \u0026#34;manufacturer-form\u0026#34;: ManufacturerForm } }; \u0026lt;/script\u0026gt; 接著重構 ManufacturerForm\n程式結構和 ProductForm 組件很類似，將 \u0026lt;template\u0026gt; 區塊替換成組件庫樣式\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;manufacturerInfo\u0026#34;\u0026gt; \u0026lt;el-form class=\u0026#34;form\u0026#34; ref=\u0026#34;form\u0026#34; :model=\u0026#34;model\u0026#34; label-width=\u0026#34;180px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;Name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;model.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button v-if=\u0026#34;isEditing\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Update Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;onSubmit\u0026#34;\u0026gt;Add Manufacturer\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 重構前台購物車 最後！重構 Cart 組件，和 ProductList 類似，兩者都用了 ProductItem 組件\n一樣那句話：將 \u0026lt;template\u0026gt; 區塊替換成組件庫樣式\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-item :products=\u0026#34;cart\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在這篇文章中主要就是使用 element-ui 組件庫將畫面做得比較酷炫\n但也造成一些功能癱瘓，當下一定很緊張，但不要緊！我們馬上就要來修復功能了！\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202011-express-vue-build-ecommerce-19-elemen-ui-refactor-page/"
  },{
    "title": "[Express+Vue 搭建電商網站] 18 套用 Element UI 到頁面上",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 套用 Element UI 到頁面上",
    "body": "先前我們已經把電商的基本功能完成了，只是畫面有點差強人意。\n在這一節中我們使用 Element UI 來讓畫面更加美觀\n安裝 Element UI Element UI 是一套 Vue 2.0 的組件庫\n提供了許多模板。在很多時候可以減少我們重造輪子的麻煩\n現在也有 Vue 3.x 的版本了\n有三方法可以進行\n  使用 npm 套件管理安裝，這也是官方推薦的作法\nnpm i element-ui -S   使用 CDN 安裝\n在 index.html 中加入 CDN 連結\n\u0026lt;!-- 引入样式 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/element-ui/lib/theme-chalk/index.css\u0026#34;\u0026gt; \u0026lt;!-- 引入组件库 --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/element-ui/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 若是使用 CDN 版本作法，建議加入版本號避免因為 Element UI 升級而受到影響\n  使用 vue-ui 鑑於 vue/cli 3.0 的釋出，也提供了從 vue-cli 中安裝的套件 官方說明\n  導入套件 打開主目錄中的 src/main.js 我們要把剛剛安裝的套件導入到專案中註冊依賴\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.config.productionTip = false Vue.use(ElementUI); new Vue({ router, store, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 除了導入 element-ui 組件庫外，還需要單獨把 CSS 樣式也導入\n並且聲明 Vue.use(ElementUI); 來註冊組件庫，接著就是快樂的開始使用組件庫了\n重構選單列 打開 src/App.vue 愉快的使用 element-ui 改成酷炫的樣子\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-menu class=\u0026#34;menu\u0026#34; :default-active=\u0026#34;activeIndex2\u0026#34; mode=\u0026#34;horizontal\u0026#34; @select=\u0026#34;handleSelect\u0026#34; background-color=\u0026#34;#545c64\u0026#34; text-color=\u0026#34;#fff\u0026#34; active-text-color=\u0026#34;#ffd04b\u0026#34;\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;首頁\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-submenu index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;控制台\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-1\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;產品列表\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-2\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin/new\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;新增商品\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-3\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin/manufacturers\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;製造商列表\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-4\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/admin/manufacturers/new\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;新增製造商\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt;  \u0026lt;el-menu-item index=\u0026#34;3\u0026#34;\u0026gt;\u0026lt;router-link to=\u0026#34;/cart\u0026#34; tag=\u0026#34;div\u0026#34;\u0026gt;購物車\u0026lt;/router-link\u0026gt;\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39;, data() { return { activeIndex: \u0026#39;1\u0026#39;, activeIndex2: \u0026#39;1\u0026#39; }; }, methods: { handleSelect(key, keyPath) { console.log(key, keyPath); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u0026lt;/style\u0026gt; 先不要在意 data 屬性以及 handleSelect 方法，暫時不會碰到\n首先看到 \u0026lt;el-menu\u0026gt; 這個標籤，其中的 el-menu-item 帶有幾個屬性\n其中 tag 屬性代表將這個內容用 \u0026lt;div\u0026gt; 這個標籤渲染，如果沒設定則預設是 \u0026lt;a\u0026gt; 連結並帶有底線\n所以這邊設定為 div 就是為了避免出現底線\n重構商品列表 接著要重構 ProductItem 同時因為子組件被修改，所以 ProductList 也需要修改\nProductList 打開 src/components/products/ProductList.vue 將 \u0026lt;template\u0026gt; 部分修改為\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;This is ProductList\u0026lt;/div\u0026gt; \u0026lt;!-- \u0026lt;template v-for=\u0026#34;product in products\u0026#34;\u0026gt; --\u0026gt; \u0026lt;product-item :products=\u0026#34;products\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;!-- \u0026lt;/template\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以藉由註解了解到，原本是分別將產品傳入子組件再進行渲染。但現在變成了傳入全部商品\n至於為什麼？就讓我們看下去\nProductItem 打開 src/components/products/ProductItem.vue 修改成以下內容\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;el-table class=\u0026#34;table\u0026#34; :data=\u0026#34;products\u0026#34; max-height=\u0026#34;250\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;產品名稱\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;description\u0026#34; label=\u0026#34;介紹\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;price\u0026#34; label=\u0026#34;售價\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;manufacturer.name\u0026#34; label=\u0026#34;製造商\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;!-- \u0026lt;el-table-column label=\u0026#34;圖片\u0026#34;\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;image\u0026#34; alt=\u0026#34;\u0026#34; class=\u0026#34;product__image\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt;--\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;product-button :id=\u0026#34;scope.row._id\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductButton from \u0026#34;./ProductButton\u0026#34;; export default { name: \u0026#34;product-item\u0026#34;, props: [\u0026#34;products\u0026#34;], components: { \u0026#34;product-button\u0026#34;: ProductButton } }; \u0026lt;/script\u0026gt; 第一，針對傳入值改成 props: [\u0026quot;products\u0026quot;], 因為在父組件做了改變，但是為什麼呢？\n再往回看 \u0026lt;template\u0026gt; 中，原來是因為 \u0026lt;el-table\u0026gt; 這個表格組件要傳入一個陣列作為 data 屬性\n而最後一個 el-table-column 作為按鈕，所以沒有定義 prop 屬性\n為了作為按鈕操作，使用了 scope.row 取得指定物件的 id 作為值傳給了子組件 ProductButton 來操作\n 透過 slot-scope 可以取得 row, column, $index 和 store（table 内部的狀態管理）資料\n ProductButton 接著就是修改 src/components/products/ProductButton.vue 組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-button v-if=\u0026#34;isAdding\u0026#34; @click=\u0026#34;addToCart\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;加入購物車\u0026lt;/el-button\u0026gt; \u0026lt;el-button v-else @click=\u0026#34;removeFromCart(id)\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;small\u0026#34;\u0026gt;從購物車移除\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;id\u0026#34;], computed: { product() { let product = this.$store.getters.allProducts.find( product =\u0026gt; product._id === this.id ); return product; }, isAdding() { let isAdding = true; this.cart.map(product =\u0026gt; { if (product._id === this.product._id) { isAdding = false; } }); return isAdding; }, cart() { return this.$store.state.cart; } }, methods: { addToCart() { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product: this.product }); }, removeFromCart(productId) { this.$store.commit(\u0026#34;REMOVE_FROM_CART\u0026#34;, { productId }); } } }; \u0026lt;/script\u0026gt; 使用 element-ui 組件庫提供的按鈕組件 el-button 替換先前普通的按鈕，並且改變了對應的按鈕方法 將父組件傳來的 product 物件換成了單純的 id\n因為在 ProductItem 組件中傳入的是指定物件的 id\n所以定義了一個 computed product，來取得指定 id 的產品物件\n到這邊我們先看看運行的結果\n上方的功能列已經變成比較好看的樣式了產品列表也用表單的形式，看起來整齊多了\n基本的 Element UI 套用就到這邊，接著我們會把畫面一步步變得更好看！\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202011-express-vue-build-ecommerce-18-element-ui-product-list/"
  },{
    "title": "[Express+Vue 搭建電商網站] 17 使用常數管理變數",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用常數管理變數",
    "body": "很多時候我們會把功能封裝到組件內，以便重複使用組件，而在組件內我們會定義很多方法名稱去呼叫不同的事件\n這中間只要有一個字打錯，整個流程就會錯誤，並且非常難除錯，因此我們會使用常數維持一致\n打錯字的時候就會報錯，方便除錯\n建立 ManufacturerForm 組件 和商品資訊一樣，我們也要將製造商資訊封裝到另一個單獨的組件 ManufacturerForm\n新增 src/components/ManufacturerForm.vue 檔案\n\u0026lt;template\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;saveManufacturer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Name\u0026#34; v-model=\u0026#34;model.name\u0026#34; name=\u0026#34;name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group new-button\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-pencil\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;!-- Conditional rendering for input text --\u0026gt; \u0026lt;span v-if=\u0026#34;isEditing\u0026#34;\u0026gt;Update Manufacturer\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;Add Manufacturer\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;model\u0026#34;, \u0026#34;isEditing\u0026#34;], methods: { saveManufacturer() { this.$emit(\u0026#34;save-manufacturer\u0026#34;, this.model); } } }; \u0026lt;/script\u0026gt; 重構 getters 檔案 在建立編輯生產商的組件前，需先加入對應的 getter 屬性\n打開 src/store/getters.js 檔案，對 manufacturerGetters 增加一個屬性\n用來取得狀態庫中的指定生產商\nmanufacturerById: (state, getters) =\u0026gt; id =\u0026gt; { if (getters.allManufacturers.length \u0026gt; 0) { return getters.allManufacturers.filter(manufacturer =\u0026gt; manufacturer._id === id)[0] } else { return state.manufacturer; } } 建立 EditManufacturers 頁面 在建立好顯示製造商資訊的表單組件 ManufacturerForm 以及設定好取得資料的 getter 之後\n我們要來建立編輯製造商的頁面 src/views/admin/EditManufacturers.vue\n\u0026lt;template\u0026gt; \u0026lt;manufacturer-form @save-manufacturer=\u0026#34;addManufacturer\u0026#34; :model=\u0026#34;model\u0026#34; :isEditing=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/manufacturer-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ManufacturerForm from \u0026#34;@/components/ManufacturerForm.vue\u0026#34;; export default { created() { this.$store.dispatch(\u0026#34;manufacturerById\u0026#34;, { manufacturerId: this.$route.params[\u0026#34;id\u0026#34;] }); }, computed: { model() { const manufacturer = this.$store.getters.manufacturerById( this.$route.params[\u0026#34;id\u0026#34;] ); return { ...manufacturer }; } }, methods: { addManufacturer(model) { this.$store.dispatch(\u0026#34;updateManufacturer\u0026#34;, { manufacturer: model }); } }, components: { \u0026#34;manufacturer-form\u0026#34;: ManufacturerForm } }; \u0026lt;/script\u0026gt; 組件在創建時會使用 action 去異步取得製造商資訊，並透過 mutation 修改狀態池 之所以在 model 這個 computed 中回傳製造商資料的備份資料\n是為了在修改資料被送出前不對當前 store 的生產商屬性做操作\n而組件內如果對生產商有操作，會透過 action 修改商品資訊，然後呼叫 mutation 變更狀態池\n建立 NewManufacturers 頁面 跟剛剛的編輯頁面邏輯差不多，這邊要建立新增頁面 src/views/admin/NewManufacturers.vue\n\u0026lt;template\u0026gt; \u0026lt;manufacturer-form @save-manufacturer=\u0026#34;addManufacturer\u0026#34; :model=\u0026#34;model\u0026#34;\u0026gt;\u0026lt;/manufacturer-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ManufacturerForm from \u0026#34;@/components/ManufacturerForm.vue\u0026#34;; export default { computed: { model() { return {}; } }, methods: { addManufacturer(model) { this.$store.dispatch(\u0026#34;addManufacturer\u0026#34;, { manufacturer: model }); } }, components: { \u0026#34;manufacturer-form\u0026#34;: ManufacturerForm } }; \u0026lt;/script\u0026gt; 重構 Admin menu 在 src/views/admin/Index.vue 加入新的頁面用來增加製造商，沒什麼多解釋的\n\u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/manufacturers/new\u0026#34;\u0026gt;新增製造商\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; 增加路由邏輯 頁面跟連結都做好了，打開 src/router/index.js 引入路由設定\nimport NewManufacturers from \u0026#39;@/views/admin/NewManufacturers\u0026#39;; import EditManufacturers from \u0026#39;@/views/admin/EditManufacturers\u0026#39;; 增加 admin 頁面下路由 children 屬性\n{ path: \u0026#39;manufacturers/new\u0026#39;, name: \u0026#39;NewManufacturers\u0026#39;, component: NewManufacturers, }, { path: \u0026#39;manufacturers/edit/:id\u0026#39;, name: \u0026#39;EditManufacturers\u0026#39;, component: EditManufacturers, }, 用常數管理通用名稱 很多時候我們會把功能封裝到組件內，以便重複使用組件\n而在組件內我們會定義很多方法名稱去呼叫不同的事件，例如當使用者按下了送出，觸發了 ADD_PRODUCT 事件\n那在 action 中就要有相應的事件\n並且 action 在後端處理完請求後，也會呼叫指定的 mutations 來處理狀態的變更\n這中間只要有一個字打錯，整個流程就會錯誤，並且非常難除錯\n因此我們會使用常數的方式定義 actions 和 mutations 中的事件\n只要我們都使用同一組常數就可以維持一致。關鍵的是如果這麼做打錯字的時候就會報錯，方便除錯\n接著就來實作建立 src/store/mutation-types.js 檔案作為 mapping 表\nexport const ALL_PRODUCTS = \u0026#39;ALL_PRODUCTS\u0026#39;; export const ALL_PRODUCTS_SUCCESS = \u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;; export const PRODUCT_BY_ID = \u0026#39;PRODUCT_BY_ID\u0026#39;; export const PRODUCT_BY_ID_SUCCESS = \u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;; export const ADD_PRODUCT = \u0026#39;ADD_PRODUCT\u0026#39;; export const ADD_PRODUCT_SUCCESS = \u0026#39;ADD_PRODUCT_SUCCESS\u0026#39;; export const UPDATE_PRODUCT = \u0026#39;UPDATE_PRODUCT\u0026#39;; export const UPDATE_PRODUCT_SUCCESS = \u0026#39;UPDATE_PRODUCT_SUCCESS\u0026#39;; export const REMOVE_PRODUCT = \u0026#39;REMOVE_PRODUCT\u0026#39;; export const REMOVE_PRODUCT_SUCCESS = \u0026#39;REMOVE_PRODUCT_SUCCESS\u0026#39;; export const ADD_TO_CART = \u0026#39;ADD_TO_CART\u0026#39;; export const REMOVE_FROM_CART = \u0026#39;REMOVE_FROM_CART\u0026#39;; export const ALL_MANUFACTURERS = \u0026#39;ALL_MANUFACTURER\u0026#39;; export const ALL_MANUFACTURERS_SUCCESS = \u0026#39;ALL_MANUFACTURER_S\u0026#39;; export const MANUFACTURER_BY_ID = \u0026#39;MANUFACTURER_BY_ID\u0026#39;; export const MANUFACTURER_BY_ID_SUCCESS = \u0026#39;MANUFACTURER_BY_ID_SUCCESS\u0026#39;; export const ADD_MANUFACTURER = \u0026#39;ADD_MANUFACTURER\u0026#39;; export const ADD_MANUFACTURER_SUCCESS = \u0026#39;ADD_MANUFACTURER_SUCCESS\u0026#39;; export const UPDATE_MANUFACTURER = \u0026#39;UPDATE_MANUFACTURER\u0026#39;; export const UPDATE_MANUFACTURER_SUCCESS = \u0026#39;UPDATE_MANUFACTURER_SUCCESS\u0026#39;; export const REMOVE_MANUFACTURER = \u0026#39;REMOVE_MANUFACTURER\u0026#39;; export const REMOVE_MANUFACTURER_SUCCESS = \u0026#39;REMOVE_MANUFACTURER_SUCCESS\u0026#39;; 重構 actions 檔案 打開 src/store/actions.js 檔案，引入剛剛的常數表文件後，把其中的方法名稱通通改成使用常數表內的常數\nimport axios from \u0026#39;axios\u0026#39;; import { ADD_PRODUCT, ADD_PRODUCT_SUCCESS, PRODUCT_BY_ID, PRODUCT_BY_ID_SUCCESS, UPDATE_PRODUCT, UPDATE_PRODUCT_SUCCESS, REMOVE_PRODUCT, REMOVE_PRODUCT_SUCCESS, ALL_PRODUCTS, ALL_PRODUCTS_SUCCESS, ALL_MANUFACTURERS, ALL_MANUFACTURERS_SUCCESS, MANUFACTURER_BY_ID, MANUFACTURER_BY_ID_SUCCESS, ADD_MANUFACTURER, ADD_MANUFACTURER_SUCCESS, UPDATE_MANUFACTURER, UPDATE_MANUFACTURER_SUCCESS, REMOVE_MANUFACTURER, REMOVE_MANUFACTURER_SUCCESS, } from \u0026#39;./mutation-types\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; export const productActions = { allProducts({ commit }) { commit(ALL_PRODUCTS) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { commit(ALL_PRODUCTS_SUCCESS, { products: response.data, }); }) }, productById({ commit }, payload) { commit(PRODUCT_BY_ID); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(PRODUCT_BY_ID_SUCCESS, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(REMOVE_PRODUCT); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`).then(() =\u0026gt; { // 回傳 productId，用來刪除對應商品  commit(REMOVE_PRODUCT_SUCCESS, { productId, }); }) }, updateProduct({ commit }, payload) { commit(UPDATE_PRODUCT); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product).then(() =\u0026gt; { commit(UPDATE_PRODUCT_SUCCESS, { product, }); }) }, addProduct({ commit }, payload) { commit(ADD_PRODUCT); const { product } = payload; axios.post(`${API_BASE}/products`, product).then(response =\u0026gt; { commit(ADD_PRODUCT_SUCCESS, { product: response.data, }) }) } }; export const manufacturerActions = { allManufacturers({ commit }) { commit(ALL_MANUFACTURERS); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(ALL_MANUFACTURERS_SUCCESS, { manufacturers: response.data, }); }) }, manufacturerById({ commit }, payload) { commit(MANUFACTURER_BY_ID); const { manufacturerId } = payload; axios.get(`${API_BASE}/manufacturers/${manufacturerId}`).then(response =\u0026gt; { commit(MANUFACTURER_BY_ID_SUCCESS, { manufacturer: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(REMOVE_MANUFACTURER); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() =\u0026gt; { // 回傳 manufacturerId，用來刪除對應的製造商  commit(REMOVE_MANUFACTURER_SUCCESS, { manufacturerId, }); }) }, updateManufacturer({ commit }, payload) { commit(UPDATE_MANUFACTURER); const { manufacturer } = payload; axios.put(`${API_BASE}/manufacturers/${manufacturer._id}`, manufacturer).then(() =\u0026gt; { commit(UPDATE_MANUFACTURER_SUCCESS, { manufacturer, }); }) }, addManufacturer({ commit }, payload) { commit(ADD_MANUFACTURER); const { manufacturer } = payload; axios.post(`${API_BASE}/manufacturers`, manufacturer).then(response =\u0026gt; { commit(ADD_MANUFACTURER_SUCCESS, { manufacturer: response.data, }) }) } } 重構 manufacturer 檔案 在 src/store/mutations.js 也做跟上一步一樣的事情\nimport { ADD_PRODUCT, ADD_PRODUCT_SUCCESS, PRODUCT_BY_ID, PRODUCT_BY_ID_SUCCESS, UPDATE_PRODUCT, UPDATE_PRODUCT_SUCCESS, REMOVE_PRODUCT, REMOVE_PRODUCT_SUCCESS, ADD_TO_CART, REMOVE_FROM_CART, ALL_PRODUCTS, ALL_PRODUCTS_SUCCESS, ALL_MANUFACTURERS, ALL_MANUFACTURERS_SUCCESS, MANUFACTURER_BY_ID, MANUFACTURER_BY_ID_SUCCESS, ADD_MANUFACTURER, ADD_MANUFACTURER_SUCCESS, UPDATE_MANUFACTURER, UPDATE_MANUFACTURER_SUCCESS, REMOVE_MANUFACTURER, REMOVE_MANUFACTURER_SUCCESS, } from \u0026#39;./mutation-types\u0026#39;; export const productMutations = { [ALL_PRODUCTS](state) { state.showLoader = true; }, [ALL_PRODUCTS_SUCCESS](state, payload) { const { products } = payload; state.showLoader = false; state.products = products; }, [PRODUCT_BY_ID](state) { state.showLoader = true; }, [PRODUCT_BY_ID_SUCCESS](state, payload) { state.showLoader = false; const { product } = payload; state.product = product; }, [REMOVE_PRODUCT](state) { state.showLoader = true; }, [REMOVE_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { productId } = payload; state.products = state.products.filter(product =\u0026gt; product._id !== productId); }, [UPDATE_PRODUCT](state) { state.showLoader = true; }, [UPDATE_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { product: newProduct } = payload; state.product = newProduct; state.products = state.products.map(product =\u0026gt; { if (product._id === newProduct._id) { return newProduct; } return product; }) }, [ADD_PRODUCT](state) { state.showLoader = true; }, [ADD_PRODUCT_SUCCESS](state, payload) { state.showLoader = false; const { product } = payload; state.products = state.products.concat(product); }, }; export const cartMutations = { [ADD_TO_CART](state, payload) { const { product } = payload; state.cart.push(product) }, [REMOVE_FROM_CART](state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, } export const manufacturerMutations = { [ALL_MANUFACTURERS](state) { state.showLoader = true; }, [ALL_MANUFACTURERS_SUCCESS](state, payload) { const { manufacturers } = payload; state.showLoader = false; state.manufacturers = manufacturers; }, [MANUFACTURER_BY_ID](state) { state.showLoader = true; }, [MANUFACTURER_BY_ID_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer } = payload; state.manufacturer = manufacturer; }, [REMOVE_MANUFACTURER](state) { state.showLoader = true; }, [REMOVE_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturerId } = payload; state.manufacturers = state.manufacturers.filter(manufacturer =\u0026gt; manufacturer._id !== manufacturerId); }, [UPDATE_MANUFACTURER](state) { state.showLoader = true; }, [UPDATE_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer: newManufacturer } = payload; state.manufacturers = state.manufacturers.map(manufacturer =\u0026gt; { if (manufacturer._id === newManufacturer._id) { return newManufacturer; } return manufacturer; }) }, [ADD_MANUFACTURER](state) { state.showLoader = true; }, [ADD_MANUFACTURER_SUCCESS](state, payload) { state.showLoader = false; const { manufacturer } = payload; state.manufacturers = state.manufacturers.concat(manufacturer); } } 如此就完成了用常數替換 actions 和 mutations 兩隻檔案中的事件類型\n後續要維護就不會東一塊西一塊的過於分散，還要用全域搜尋人工替換，增加了維護的可行性\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202010-express-vue-build-ecommerce-17-use-const-instead-of-variable/"
  },{
    "title": "[Express+Vue 搭建電商網站] 16 抽離 Vuex store 中的邏輯",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 抽離 Vuex store 中的邏輯",
    "body": "隨著我們的迷你電商網站越來越完整，在 Vuex store 中的程式也越來越龐大\n不只有 getters、mutation 還有 actions\n在章節中先試著將這些複雜的邏輯拆分成個別的檔案，抽出 Getters、Mutations 和 Actions 邏輯\n重構 Admin 首頁 打開 src/views/admin/Index.vue 頁面，將選單換成中文。並且加上查看查看製造商的選項\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;admin-new\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-3 col-md-3 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;admin-menu\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;查看商品\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/new\u0026#34;\u0026gt;新建商品\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/manufacturers\u0026#34;\u0026gt;查看製造商\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以預期到的接下來我們會做一個關於製造商的頁面，然後透過後端 API 取得製造商資料\n建立 Manufacturers 頁面 新建 src/views/admin/Manufacturers.vue 檔案\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;製造商\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;manufacturer in manufacturers\u0026#34; :key=\u0026#34;manufacturer._id\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{manufacturer.name}}\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;modify\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/manufacturers/edit/\u0026#39; + manufacturer._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;remove\u0026#34;\u0026gt; \u0026lt;a @click=\u0026#34;removeManufacturer(manufacturer._id)\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt;刪除\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; table { margin: 0 auto; } .modify { color: blue; } .remove a { color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { created() { if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; } }, methods: { removeManufacturer(manufacturerId) { const res = confirm(\u0026#34;是否刪除此製造商？\u0026#34;); if (res) { this.$store.dispatch(\u0026#34;removeManufacturer\u0026#34;, { manufacturerId }); } } } }; \u0026lt;/script\u0026gt; 可以看到這邊我們用了一些先前沒用過的方法\n例如 computed 中的 manufacturers、生命週期 created() 時候會使用到的 allManufacturers\n還有製造商刪除用的 method 中 removeManufacturer，這些會在之後實作出來\n重構 Products 組件 接著要動手重構的就是 src/views/admin/Products.vue 組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;名稱\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;價錢\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;製造商\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;product in products\u0026#34; :key=\u0026#34;product._id\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{product.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{product.price}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{product.manufacturer.name}}\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;modify\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/admin/edit/\u0026#39; + product._id\u0026#34;\u0026gt;修改\u0026lt;/router-link\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;remove\u0026#34;\u0026gt; \u0026lt;a @click=\u0026#34;removeProduct(product._id)\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt;刪除\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; table { margin: 0 auto; } .modify { color: blue; } .remove a { color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { created() { if (this.products.length === 0) { this.$store.dispatch(\u0026#34;allProducts\u0026#34;); } }, computed: { products() { return this.$store.getters.allProducts; } }, methods: { removeProduct(productId) { const res = confirm(\u0026#34;是否刪除此商品？\u0026#34;); if (res) { this.$store.dispatch(\u0026#34;removeProduct\u0026#34;, { productId }); } } } }; \u0026lt;/script\u0026gt; 基本上和使用者畫面中的商品頁差不多，就是將加入購物車換成了修改與刪除商品\n也和剛剛操作過的 Manufacturers 組件相似，相關的東西講了許多次了，就交給你來思考\n加入路由設定 頁面跟組件都完成了，接著就要讓頁面可以被訪問\n打開 vue-router 的設定 src/router/index.js，加入製造商相關的路由參數\n引入頁面檔案\nimport Manufacturers from \u0026#39;@/views/admin/Manufacturers\u0026#39; 在 admin 路由的 children 屬性中加入頁面\n{ path: \u0026#39;manufacturers\u0026#39;, name: \u0026#39;Manufacturers\u0026#39;, component: Manufacturers, }, 接著開啟專案，可以看到製造商連結已經生效，可以把我們帶到製造商頁面，但是資料還是沒有取得\n記得嗎？之前說要從後端 API 取得資料的方法還沒寫，接下來就一邊重構一邊把這個功能完成吧！\n分離 Getter 邏輯 首先建立 src/store/getters.js 檔案，用來存放各種不同的 getter\nexport const productGetters = { allProducts(state) { return state.products }, productById: (state, getters) =\u0026gt; id =\u0026gt; { if (getters.allProducts.length \u0026gt; 0) { return getters.allProducts.filter(product =\u0026gt; product._id === id)[0] } else { return state.product; } } } export const manufacturerGetters = { allManufacturers(state) { return state.manufacturers; } } 可以看到我們導出了 productGetters 和 manufacturerGetters 兩個方法\n前者包含商品的 getters，後者則是負責製造商的 getter，如此就補上了前面幾段缺少的 manufacturer getters\n分離 Mutations 邏輯 就像剛剛分離 Getter 邏輯，接著新建 src/store/mutations.js 檔案作為 store 中 mutation 的程式管理\nexport const productMutations = { ALL_PRODUCTS(state) { state.showLoader = true; }, ALL_PRODUCTS_SUCCESS(state, payload) { const { products } = payload; state.showLoader = false; state.products = products; }, PRODUCT_BY_ID(state) { state.showLoader = true; }, PRODUCT_BY_ID_SUCCESS(state, payload) { state.showLoader = false; const { product } = payload; state.product = product; }, REMOVE_PRODUCT(state) { state.showLoader = true; }, REMOVE_PRODUCT_SUCCESS(state, payload) { state.showLoader = false; const { productId } = payload; state.products = state.products.filter(product =\u0026gt; product._id !== productId); } }; export const cartMutations = { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, } export const manufacturerMutations = { ALL_MANUFACTURERS(state) { state.showLoader = true; }, ALL_MANUFACTURERS_SUCCESS(state, payload) { const { manufacturers } = payload; state.showLoader = false; state.manufacturers = manufacturers; }, REMOVE_MANUFACTURER(state) { state.showLoader = true; }, REMOVE_MANUFACTURER_SUCCESS(state, payload) { state.showLoader = false; const { manufacturerId } = payload; state.manufacturers = state.manufacturers.filter(manufacturer =\u0026gt; manufacturer._id !== manufacturerId); } } 分別導出了\n productMutations cartMutations manufacturerMutations  來操作 vuex store 中的不同狀態，這邊也加入了生產商相關的狀態管理 mutations，讓之後的 actions 可以呼叫\n重構 Store 物件 既然剛剛都把 Getter 和 Mutations 抽離文件完成了，這邊就要重構 Store 檔案。\n要做的事情有兩件：\n 移除原有的 getters 和 mutations 引入新建的 getters 和 mutations  下面就是新的 src/store/index.js\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import axios from \u0026#39;axios\u0026#39;; import { productGetters, manufacturerGetters } from \u0026#39;./getters\u0026#39;; import { productMutations, cartMutations, manufacturerMutations } from \u0026#39;./mutations\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [], // all manufacturers  manufacturers: [], }, mutations: { ...productMutations, ...cartMutations, ...manufacturerMutations, }, getters: { ...productGetters, ...manufacturerGetters, }, actions: { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { console.log(\u0026#39;response\u0026#39;, response); commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) }, productById({ commit }, payload) { commit(\u0026#39;PRODUCT_BY_ID\u0026#39;); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(\u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(\u0026#39;REMOVE_PRODUCT\u0026#39;); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`).then(() =\u0026gt; { // 傳入 manufacturerId，用來刪除指定商品  commit(\u0026#39;REMOVE_PRODUCT_SUCCESS\u0026#39;, { productId, }); }) }, allManufacturers({ commit }) { commit(\u0026#39;ALL_MANUFACTURERS\u0026#39;); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(\u0026#39;ALL_MANUFACTURERS_SUCCESS\u0026#39;, { manufacturers: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(\u0026#39;REMOVE_MANUFACTURER\u0026#39;); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() =\u0026gt; { // 傳入 manufacturerId，用來刪除指定製造商  commit(\u0026#39;REMOVE_MANUFACTURER_SUCCESS\u0026#39;, { manufacturerId, }); }) }, } }); 移除原有 getters 和 mutations 不難理解，而引入新建的 getters 和 mutations 就值得說明了！\n首先藉由\nimport { productGetters, manufacturerGetters } from \u0026#39;./getters\u0026#39;; import { productMutations, cartMutations, manufacturerMutations } from \u0026#39;./mutations\u0026#39;; 引入剛剛分離出去的檔案\n接著使用 ES6 中的：擴展運算符（spread operator） 將剛剛引入的屬性以及包含的方法導入到 store 物件中。\n除此之外我們還偷偷在 actions 加入一些 action 屬性，稍後我們也會把它抽離出去\n這樣整個 store 看起來就會更簡潔了\n分離 Actions 邏輯 上面抽出了 Getters、Mutations 終於輪到 Actions 了\n重構 Edit 頁面 打開 src/views/admin/Edit.vue 替換成\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-form @save-product=\u0026#34;updateProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; :isEditing=\u0026#34;true\u0026#34; \u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { created() { const { name } = this.model; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, model() { const product = this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); // 回傳 product 的備份，是為了在修改 product 的備份之後，在保存之前不修改本地 Vuex store 的 product 屬性  return { ...product, manufacturer: { ...product.manufacturer } }; } }, methods: { updateProduct(product) { this.$store.dispatch(\u0026#34;updateProduct\u0026#34;, { product }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 可以看到我們有兩個 computed：manufacturers 和 model，分別回傳製造商和當前商品\n之所以要回傳當前的 product 是為了在編輯了 product 的副本之後\n在存入資料庫之前先不變更使用者端 Vuex store 中的 product 屬性\n當組件被建立時，判斷 model 是否有值，如果沒有代表本機狀態庫中沒有資料\n必須透異步 API 取得商品資料，並且使用對應的 mutation 修改狀態庫中的資料\n在 \u0026lt;template\u0026gt; 中使用了子組件 ProductForm 來顯示商品資料\n按下表單送出時則會對送出 updateProduct 的異步 action，通知指定 mutation 來更新狀態\n重構 New 頁面 src/views/admin/New.vue 負責建立新的商品，邏輯與 Edit 類似\n只是一個負責新增商品，一個修改\n在這邊我們將組件中原本寫死的資料改為從後端動態取得，並將資料傳入給子組件 ProductForm\n\u0026lt;template\u0026gt; \u0026lt;product-form @save-product=\u0026#34;addProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34;\u0026gt;\u0026lt;/product-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#34;@/components/products/ProductForm.vue\u0026#34;; export default { created() { if (this.manufacturers.length === 0) { this.$store.dispatch(\u0026#34;allManufacturers\u0026#34;); } }, computed: { manufacturers() { return this.$store.getters.allManufacturers; }, model() { return {}; } }, methods: { addProduct(model) { this.$store.dispatch(\u0026#34;addProduct\u0026#34;, { product: model }); } }, components: { \u0026#34;product-form\u0026#34;: ProductForm } }; \u0026lt;/script\u0026gt; 跟 Edit 組件類似，只是這邊的 model 屬性回傳的是空物件，畢竟當前是不存在商品的\n拆分 Actions 邏輯 就像之前一樣建立 src/store/actions.js 檔案，用來管理 store 物件中 actions 屬性的內部屬性\n就跟上面處理 Getters 和 Manufacturers 時類似做法\nimport axios from \u0026#39;axios\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; export const productActions = { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) }, productById({ commit }, payload) { commit(\u0026#39;PRODUCT_BY_ID\u0026#39;); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(\u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;, { product: response.data, }); }) }, removeProduct({ commit }, payload) { commit(\u0026#39;REMOVE_PRODUCT\u0026#39;); const { productId } = payload; axios.delete(`${API_BASE}/products/${productId}`).then(() =\u0026gt; { // 回傳 productId，用來刪除對應商品  commit(\u0026#39;REMOVE_PRODUCT_SUCCESS\u0026#39;, { productId, }); }) }, updateProduct({ commit }, payload) { commit(\u0026#39;UPDATE_PRODUCT\u0026#39;); const { product } = payload; axios.put(`${API_BASE}/products/${product._id}`, product).then(() =\u0026gt; { commit(\u0026#39;UPDATE_PRODUCT_SUCCESS\u0026#39;, { product, }); }) }, addProduct({ commit }, payload) { commit(\u0026#39;ADD_PRODUCT\u0026#39;); const { product } = payload; axios.post(`${API_BASE}/products`, product).then(response =\u0026gt; { commit(\u0026#39;ADD_PRODUCT_SUCCESS\u0026#39;, { product: response.data, }) }) } }; export const manufacturerActions = { allManufacturers({ commit }) { commit(\u0026#39;ALL_MANUFACTURERS\u0026#39;); axios.get(`${API_BASE}/manufacturers`).then(response =\u0026gt; { commit(\u0026#39;ALL_MANUFACTURERS_SUCCESS\u0026#39;, { manufacturers: response.data, }); }) }, removeManufacturer({ commit }, payload) { commit(\u0026#39;REMOVE_MANUFACTURER\u0026#39;); const { manufacturerId } = payload; axios.delete(`${API_BASE}/manufacturers/${manufacturerId}`).then(() =\u0026gt; { // 回傳 manufacturerId，用來刪除對應的製造商  commit(\u0026#39;REMOVE_MANUFACTURER_SUCCESS\u0026#39;, { manufacturerId, }); }) }, } 可以發現我們把 API 的設定與使用都搬到這邊了，所以可以猜到下一步我們要做的就是「重構 Store」\n重構 Store 再次回到 src/store/index.js 檔案中，導入 Actions 邏輯相關的設定\n並且移除 API 相關的設定，包含引入 axios 和 API 網址的參數設定\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import { productGetters, manufacturerGetters } from \u0026#39;./getters\u0026#39;; import { productMutations, cartMutations, manufacturerMutations } from \u0026#39;./mutations\u0026#39;; import { productActions, manufacturerActions } from \u0026#39;./actions\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [], // all manufacturers  manufacturers: [], }, mutations: { ...productMutations, ...cartMutations, ...manufacturerMutations, }, getters: { ...productGetters, ...manufacturerGetters, }, actions: { ...productActions, ...manufacturerActions, } }); 於是我們就完成了 Actions 邏輯的抽換，來賓請掌聲鼓勵！\n新增 mutations 屬性 接著我們要在 src/store/mutations.js 的 productMutations 下新增一些 mutation 屬性\n用來處理使用者不同的操作時更新狀態庫中的內容同步\nUPDATE_PRODUCT(state) { state.showLoader = true; }, UPDATE_PRODUCT_SUCCESS(state, payload) { state.showLoader = false; const { product: newProduct } = payload; state.product = newProduct; state.products = state.products.map(product =\u0026gt; { if (product._id === newProduct._id) { return newProduct; } return product; }) }, ADD_PRODUCT(state) { state.showLoader = true; }, ADD_PRODUCT_SUCCESS(state, payload) { state.showLoader = false; const { product } = payload; state.products = state.products.concat(product); } 上面幾個 mutation 屬性分別處理了更新商品以及加入商品的邏輯，如此就完成了第一階段的重構\n本來還想把更多的重構寫在一起，但由於此篇篇幅以及資訊量已經很龐大，就在下一篇繼續優化我們的程式吧！\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202010-express-vue-build-ecommerce-16-refactor-vue-store/"
  },{
    "title": "[Express+Vue 搭建電商網站] 15 使用 Vuex Getters 複用資料邏輯",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用 Vuex Getters 複用資料邏輯",
    "body": "有時候我們需要 computed store 中的 state，在每個組件中複製貼上同樣的 computed 似乎不是一個明智的作法\nVuex Getter 是 Vuex 提供讓我們可以對 Vuex store 中 state 資料做預處理的方法，就可以達成這個目的\n建立 Getter 首先在原本的 src/store/index.js 檔案裡加入一些新的 action、mutation 屬性\n以及這次要使用的 getter\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import axios from \u0026#39;axios\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [], // all manufacturers  manufacturers: [], }, mutations: { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, ALL_PRODUCTS(state) { state.showLoader = true; }, ALL_PRODUCTS_SUCCESS(state, payload) { const { products } = payload; state.showLoader = false; state.products = products; }, PRODUCT_BY_ID(state) { state.showLoader = true; }, PRODUCT_BY_ID_SUCCESS(state, payload) { state.showLoader = false; const { product } = payload; state.product = product; } }, getters: { allProducts(state) { return state.products; }, productById: (state, getters) =\u0026gt; id =\u0026gt; { if (getters.allProducts.length \u0026gt; 0) { return getters.allProducts.filter(p =\u0026gt; p._id == id)[0]; } else { return state.product; } } }, actions: { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { console.log(\u0026#39;response\u0026#39;, response); commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) }, productById({ commit }, payload) { commit(\u0026#39;PRODUCT_BY_ID\u0026#39;); const { productId } = payload; axios.get(`${API_BASE}/products/${productId}`).then(response =\u0026gt; { commit(\u0026#39;PRODUCT_BY_ID_SUCCESS\u0026#39;, { product: response.data, }); }) } } }); 主要增加了三個部分\n mutations：增加了 PRODUCT_BY_ID、PRODUCT_BY_ID_SUCCESS 用來管理單一商品的資訊狀態 actions：增加了 productById 來呼叫 mutations中的方法取得商品資訊 getters：建立 getters，並且加入 allProducts 和 productById 方法\nallProducts 取得所有商品；productById 則會回傳指定 id 的商品資料，如果商品不存在則回傳空的物件  在後台 Products 組件中使用 Getters 先使用一個簡單的範例說明 Getters 是怎麼運作的，打開 src/views/admin/Products.vue 組件\n並且把以下內容\nreturn this.$store.state.products[0]; 替換成\nreturn this.$store.getters.allProducts[0]; 在這個範例中，我們通過 this.$store.getters.allProducts 來調用 getter 中的 allProducts 屬性\n並且顯示出第一個商品的名稱\n建立 ProductDetail 組件 在簡單的了解 Getter 是怎麼運作之後，要來實現單一商品詳細內容的組件\n新建 src/components/products/ProductDetail.vue\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;product-details\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product-details__image\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;image\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;product-details__info\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product-details__description\u0026#34;\u0026gt; \u0026lt;small\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/small\u0026gt; \u0026lt;h3\u0026gt;產品名稱：{{product.name}}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;product-details__price-cart\u0026#34;\u0026gt; \u0026lt;p\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;product-button :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product-details__image .image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductButton from \u0026#34;./ProductButton\u0026#34;; export default { props: [\u0026#34;product\u0026#34;], components: { \u0026#34;product-button\u0026#34;: ProductButton } }; \u0026lt;/script\u0026gt; 可以看到這個組件將會利用父組件傳入的 product 物件來顯示內容\n並且複用了先前建立的 ProductButton 組件\n在 ProductItem 組件中為商品加入連結 有了詳細頁面，我們還需要設定怎麼進入商品詳細頁面的連結\n打開 src/components/products/ProductItem.vue 組件，將 \u0026lt;template\u0026gt; 區塊編輯成以下樣式\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;\u0026#39;/detail/\u0026#39; + product._id\u0026#34; class=\u0026#34;product-link\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;商品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;售價：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;/router-link\u0026gt; \u0026lt;product-button :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; 可以發現我們使用了之前學過的 vue-router 中的 router-link 方法跳轉到指定編號的商品頁面\n在 ProductList 中使用 Getters 而原先商品列表組件（src/components/products/ProductList.vue）「取得所有商品」功能\n也是直接操作 Vuex store 中的 state\ncomputed: { products() { return this.$store.state.products; } }, 在這邊我們也改用剛剛學到的 Getter 改寫成以下內容，使用指定的 getter：allProducts 取得所有商品資料\ncomputed: { products() { return this.$store.getters.allProducts; } }, 建立 Detail 頁面組件 現在子組件都完成了，只缺一個詳細商品頁面將組件拿來使用\n建立 src/views/Detail.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;product-detail :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-detail\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductDetail from \u0026#34;@/components/products/ProductDetail.vue\u0026#34;; export default { created() { // 如果使用者儲存的狀態中不存在此商品，則從後端取得商品資訊  const { name } = this.product; if (!name) { this.$store.dispatch(\u0026#34;productById\u0026#34;, { productId: this.$route.params[\u0026#34;id\u0026#34;] }); } }, computed: { product() { return this.$store.getters.productById(this.$route.params[\u0026#34;id\u0026#34;]); } }, components: { \u0026#34;product-detail\u0026#34;: ProductDetail } }; \u0026lt;/script\u0026gt; 引入了 ProductDetail 組件，並且在生命週期中頁面建立「created()」時檢查使用者端是否有指定商品的資料\n沒有則使用異步方法呼叫 Vuex action 取得資訊，並透過 mutation 修改狀態\n其中的 computed 屬性用於取得狀態管理中的指定商品\n而其中的 id 參數透過 this.$route.params['id'] 取得路由中的產品編號，傳入指定的 getter 取得指定商品資料\n設定 Detail 頁面路由 剛剛提到會使用路由傳入的產品編號來查詢產品資料，有沒有想起什麼事情？\n打開 vue-router 的設定檔 src/router/index.js 引入 Detail 頁面\nimport Detail from \u0026#39;@/views/Detail\u0026#39;; 在路由規則中加入 Detail 頁面設定值\n{ path: \u0026#39;/detail/:id\u0026#39;, name: \u0026#39;Detail\u0026#39;, component: Detail, }, 成果 打開專案頁面，可以在商品列表發現所有商品現在都有了超連結\n點擊超連結之後會進入商品詳細頁面，而顯示的就是該商品的詳細資料\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202010-express-vue-build-ecommerce-15-use-vuex-getters/"
  },{
    "title": "[Express+Vue 搭建電商網站] 14 使用組件思維重構頁面邏輯",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用組件思維重構頁面邏輯",
    "body": "在先前我們學會怎麼使用 Vuex 進行狀態管理、如何使用 Action 取得 API 資料，以及使用 Mutation 更改狀態\n而這一篇中將透過 Vue 的組件化思維簡化原本複雜且分散於各個頁面的邏輯\n建立 ProductButton 組件 新建一個 src/components/products/ProductButton.vue 檔案\n準備用這個組件替換掉操作購物車中狀態按鈕的組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button v-if=\u0026#34;isAdding\u0026#34; class=\u0026#34;button\u0026#34; @click=\u0026#34;addToCart\u0026#34;\u0026gt;加入購物車\u0026lt;/button\u0026gt; \u0026lt;button v-else class=\u0026#34;button\u0026#34; @click=\u0026#34;removeFromCart(product._id)\u0026#34;\u0026gt;從購物車移除\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;product\u0026#34;], computed: { isAdding() { let isAdding = true; this.cart.map(product =\u0026gt; { if (product._id === this.product._id) { isAdding = false; } }); return isAdding; }, cart() { return this.$store.state.cart; } }, methods: { addToCart() { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product: this.product }); }, removeFromCart(productId) { this.$store.commit(\u0026#34;REMOVE_FROM_CART\u0026#34;, { productId }); } } }; \u0026lt;/script\u0026gt; 在這個組件中，透過了 v-if 來判斷 isAdding 這個 computed 是否為真\n而 isAdding 使用了來自 Vuex store 中 state 的 cart 參數\n藉由遍歷整個 cart 判斷當前的商品是否在購物車內，進而顯示對應的按鈕，並綁定不同的行為\naddToCart 和 removeFromCart 這兩個方法會調用 mutation 而改變 Vuex store 中的狀態\n建立 ProductItem 組件 建立好了按鈕後，要建立個別商品在渲染時使用的組件\n建立 src/components/products/ProductItem.vue 顯示商品相關資訊\n並引入上一步建立的 ProductButton 組件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;商品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;售價：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;product-button :product=\u0026#34;product\u0026#34;\u0026gt;\u0026lt;/product-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductButton from \u0026#34;./ProductButton\u0026#34;; export default { name: \u0026#34;product-item\u0026#34;, props: [\u0026#34;product\u0026#34;], components: { \u0026#34;product-button\u0026#34;: ProductButton } }; \u0026lt;/script\u0026gt; 透過 import ProductButton from \u0026quot;./ProductButton\u0026quot; 引入剛剛建立的 ProductButton 組件\n並註冊在 components 物件中，最後在模板中使用組件\n重構 ProductList 組件 接著就可以把 src/components/products/ProductList.vue 這個組件重構\n把跟商品相關的模板部分移除，methods 中的加入購物車方法也一併移除\n因為單一商品的資料以及按鈕都已經加入到剛剛的 ProductItem 組件中\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;This is ProductList\u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in products\u0026#34;\u0026gt; \u0026lt;product-item :product=\u0026#34;product\u0026#34; :key=\u0026#34;product._id\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductItem from \u0026#39;./ProductItem.vue\u0026#39;; export default { name: \u0026#34;product-list\u0026#34;, created() { if (this.products.length === 0) { this.$store.dispatch(\u0026#34;allProducts\u0026#34;); } }, computed: { // a computed getter  products() { return this.$store.state.products; } }, components: { \u0026#39;product-item\u0026#39;: ProductItem }, }; \u0026lt;/script\u0026gt; 我們在引用了 ProductItem 組件後，利用 v-for 把每個商品都傳入組件用來建立商品列表\n重構 Cart 頁面 就跟在 ProductItem 組件中一樣，我們也將 src/views/Cart.vue 頁面中的商品列表組件化\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in cart\u0026#34;\u0026gt; \u0026lt;product-item :product=\u0026#34;product\u0026#34; :key=\u0026#34;product._id\u0026#34;\u0026gt;\u0026lt;/product-item\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import ProductItem from \u0026#34;@/components/products/ProductItem.vue\u0026#34;; export default { name: \u0026#34;home\u0026#34;, data() { return { msg: \u0026#34;Welcome to the Cart Page\u0026#34; }; }, computed: { cart() { return this.$store.state.cart; } }, components: { \u0026#34;product-item\u0026#34;: ProductItem } }; \u0026lt;/script\u0026gt; 一樣引入 ProductItem 組件，並且在 components 中註冊\n接著就可以在模板中把購物車內的商品傳入給組件使用\n而頁面的功能不會有所改變，只是把重複的部分整合成組件來共用，增加維護性\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202010-express-vue-build-ecommerce-14-refactor-component/"
  },{
    "title": "[Express+Vue 搭建電商網站] 13 使用 Axios 取得 API 資料",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 使用 Axios 取得 API 資料",
    "body": "使用 Axios 取得後端 API 的資料\n使用 Axios 取得 API 資料 首先先安裝 axios\nnpm i axios 在 Vuex store 中可以使用 action 屬性\n乍看之下跟 mutation 類似，不同的地方在於\n Action 提交的是 mutation，而不是直接變更狀態 Action 可以包含任意異步操作，用於響應 Vue 組件中分派的事件或動作  一個 action 是類似於 (context, payload) =\u0026gt; response.data 的函數：\nproductById(context, payload) { // 異步操作，從後端取得資料  return response.data; } 其中 productById 是從組件分派的事件或動作名稱，接收兩個參數 context、payload\ncontext 具有跟 store 相同的方法與屬性，可以透過 context.commit 來提交一個 mutation\n或是透過 context.state 和 context.getters 來取得 state 和 getters\npayload 就是攜帶的參數，可以透過他來執行異步操作，從而取得後端資料並回傳\n所以我們可以在 Action 中異步執行 axios 來抓取後端 API 的資料\n取得回傳結果後將結果提交給 mutation，並更新使用者端的資料\n實現 Action 再次修改 src/store/index.js\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; import axios from \u0026#39;axios\u0026#39;; const API_BASE = \u0026#39;http://localhost:3000/api/v1\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [], // all manufacturers  manufacturers: [], }, mutations: { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) }, ALL_PRODUCTS(state) { state.showLoader = true; }, ALL_PRODUCTS_SUCCESS(state, payload) { const { products } = payload; state.showLoader = false; state.products = products; } }, actions: { allProducts({ commit }) { commit(\u0026#39;ALL_PRODUCTS\u0026#39;) axios.get(`${API_BASE}/products`).then(response =\u0026gt; { console.log(\u0026#39;response\u0026#39;, response); commit(\u0026#39;ALL_PRODUCTS_SUCCESS\u0026#39;, { products: response.data, }); }) } } }); 我們總共做了幾件事情\n 導入 axios，定義了後端 API 的網址到 API_BASE 刪除 store 中的假資料，清空 products 陣列 mutations 增加了 ALL_PRODUCTS 和 ALL_PRODUCTS_SUCCESS 方法\u0026lt; 用來處理撈取後端資料的載入狀態以及資料 最後加入了 actions 屬性，定義了 allProducts 函數，用來響應組件的對應事件\n首先提交了 ALL_PRODUCTS mutation，接著在 axios 取得後端資料後提交了 ALL_PRODUCTS_SUCCESS\n並且把取得的資料命名為 products 一併作為 payload 傳入   提示：\n可以看到在 allProducts 中我們傳入了 { commit } 參數\n這地方使用了解構賦值 const { commit } = context\n代替比較長的 context.commit\n因為目前我們沒用到其他 context 屬性，所以這麼做是可以的\n 更新組件 ProductList 將 src/components/products/ProductList.vue 的 \u0026lt;script\u0026gt; 區塊改成以下\n\u0026lt;script\u0026gt; export default { name: \u0026#34;product-list\u0026#34;, created() { if (this.products.length === 0) { this.$store.dispatch(\u0026#34;allProducts\u0026#34;); } }, computed: { // a computed getter  products() { return this.$store.state.products; } }, methods: { addToCart(product) { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product }); } } }; \u0026lt;/script\u0026gt; 增加了一個 created() 生命週期方法，在這個組件被建立時判斷使用者端是否有商品資料\n若是沒有，則需要跟後端 API 要資料\n於是通過 this.$store.dispatch 方法觸發名叫 allProducts 的 action\n為什麼我們這邊不使用 commit 操作 mutation 而是使用 dispatch 呢？\n是因為 mutation 必須是一個同步執行的程式，而這邊是一個異步請求\n需要使用 dispatch 來操作 Action 進行異步請求\n再來是 \u0026lt;template\u0026gt;，我們做部分修改，讓畫面渲染時的資料符合當初後端 API 定義的格式\n\u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer.name}}\u0026lt;/p\u0026gt; Cart 接著打開 src/views/Cart.vue 頁面，因為上面也有顯示生產商的名稱\n同樣把 {{product.manufacturer}} 改成 {{product.manufacturer.name}}\n測試結果 首先確認先前的後端 API 專案已經啟動，並且 MongoDB 也在運行中\n如果先前在撰寫 API 時你沒有進行測試，則資料庫應該為空。先去加一些資料吧！\n完成之後進入前端測試，應該就可以發現商品的資料就是後端 API 傳來的資料\n如果不確定的話，可以照著先前的教學，使用 Postman 取得 API 中的商品列表和前端的資料比對\n取得的資料和先前一樣，可以加入與移出購物車\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202009-express-vue-build-ecommerce-13-how-to-use-axios/"
  },{
    "title": "[Express+Vue 搭建電商網站] 12 在 Vuex 使用 Mutation 管理狀態",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 在 Vuex 使用 Mutation 管理狀態",
    "body": "透過 Mutation 管理 Vuex中的狀態\n使用 Mutation 在 Vuex 中 Mutation 是修改 Vuex store 內容的唯一方法\nMutation 是定義在 Vuex store 物件中 mutations 屬性的一系列函數\n長得會像\nACTION_NAME(state, payload) { return state++; } 其中 ACTION_NAME 就是組件發出的事件或動作的名稱\n這個函數接收兩個參數 state 和 payload。state 就是在 Vuex store 裡面儲存的 state\npayload 則是跟著呼叫的事件或是動作一起傳來的參數\n然後就可以對現有的 state 做操作而回傳新的 state，透過這種方式我們可以輕鬆的管理所有狀態\n初始化 mutations 狀態 打開 src/store/index.js 檔案，修改其中的 state\n並加入 mutations，這邊我們先把資料寫死，未來會接上先前寫的後端 API\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [ { _id: \u0026#39;1\u0026#39;, name: \u0026#39;iPhone 11\u0026#39;, description: \u0026#39;全新雙相機系統，捕捉所見所愛，範圍更多更廣。智慧型手機歷來最快速的晶片，加上滿足一天的電池續航力，讓你完成更多事，充電更少次。而智慧型手機中最高的影片畫質，讓你的點滴回憶，看起來比過去更加動人精彩。\u0026#39;, image: \u0026#39;https://i.gadgets360cdn.com/large/iPhone11_leak_1567592422045.jpg\u0026#39;, price: 44000, manufacturer: \u0026#39;Apple Inc\u0026#39; }, { _id: \u0026#39;2\u0026#39;, name: \u0026#39;Pixel 4\u0026#39;, description: \u0026#39;只要用Pixel 4 拍照，不用進工作室後製編輯，也能拍出相同品質的相片！Pixel 4 是第一支能夠拍下銀河的手機，只要輕輕一點，就能拍下美麗星空。\u0026#39;, image: \u0026#39;https://pgw.udn.com.tw/gw/photo.php?u=https://uc.udn.com.tw/photo/2019/10/16/realtime/6946830.jpg\u0026#39;, price: 24990, manufacturer: \u0026#39;Google\u0026#39; }, { _id: \u0026#39;3\u0026#39;, name: \u0026#39;Xperia 1 II\u0026#39;, description: \u0026#39;由於 Sony 先前整合了 Mobile 手機部門到 Sony 本家消費性電子產品部門的緣故，所以這次以這樣的命名方式出現也不讓人意外。\u0026#39;, image: \u0026#39;https://timgm.eprice.com.tw/tw/mobile/img/2020-02/24/5484360/innocences_1_a8c4b844f3c0c83646b79e366c3d8111.jpg\u0026#39;, price: 29000, manufacturer: \u0026#39;SONY\u0026#39; }, { _id: \u0026#39;4\u0026#39;, name: \u0026#39;V30S\u0026#39;, description: \u0026#39;LG V30 S ThinQ 最大的改變是 Vision AI 功能的加入，拍照的同時相機會自動識別畫面中的場景，準確的設定場景模式。\u0026#39;, image: \u0026#39;https://img.eprice.com.tw/img/mobile/5858/large.png\u0026#39;, price: 12500, manufacturer: \u0026#39;LG\u0026#39; }, { _id: \u0026#39;5\u0026#39;, name: \u0026#39;Galaxy Note 9\u0026#39;, description: \u0026#39;做為三星每年下半年度的旗艦手機，Note 系列從 2011 年的第一代 Galaxy Note 起，就以 S Pen 做為最大賣點，並且帶動大螢幕智慧手機的風潮直到今日。\u0026#39;, image: \u0026#39;https://timgm.eprice.com.tw/tw/mobile/img/2018-08/09/5115231/hat7029_1_77763a4f06a1fba43ab32e66d90bcba1.jpg\u0026#39;, price: 18900, manufacturer: \u0026#39;Samsung\u0026#39; } ], // all manufacturers  manufacturers: [], }, mutations: { ADD_TO_CART(state, payload) { const { product } = payload; state.cart.push(product) }, REMOVE_FROM_CART(state, payload) { const { productId } = payload state.cart = state.cart.filter(product =\u0026gt; product._id !== productId) } } }); 除了 state 中暫時寫死的商品內容外，我們加了兩個 mutations 屬性下的方法\n分別代表組件中「將商品加入購物車」以及「從購物車移除移出商品」的動作\nProductList 組件 接著要新建「商品列表」的組件，用來展示商品詳細資訊\n新建 /src/components/products/ProductList.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;products\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;This is ProductList\u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in products\u0026#34;\u0026gt; \u0026lt;div :key=\u0026#34;product._id\u0026#34; class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;產品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;addToCart(product)\u0026#34;\u0026gt;加入購物車\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;product-list\u0026#34;, computed: { // a computed getter  products() { return this.$store.state.products; } }, methods: { addToCart(product) { this.$store.commit(\u0026#34;ADD_TO_CART\u0026#34;, { product }); } } }; \u0026lt;/script\u0026gt; 在 \u0026lt;script\u0026gt; 中定義了一個 computed 作為商品資料的預處理\n這樣在模板渲染時就只需要使用 {products} 就可以取得在 Vuex store 中的 products 資料\n然後定義了一個點擊事件 addToCart 來處理加入購物車按鈕的點擊\n會通過 this.$store.commit 方法\n將目前商品物件 {product} 當作 payload 來操作 Vux store 中 mutation 所定義的 ADD_TO_CART 方法做狀態修改\n組件建立完之後要在畫面引入才能使用\n修改首頁 src/pages/Home.vue 把剛剛建立的 ProductList.vue 組件加入畫面\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;In Stock\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;product-list\u0026gt;\u0026lt;/product-list\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductList from \u0026#39;@/components/products/ProductList.vue\u0026#39;; export default { name: \u0026#39;home\u0026#39;, data () { return { msg: \u0026#39;Welcome to Your Vue.js App\u0026#39; }; }, components: { \u0026#39;product-list\u0026#39;: ProductList } } \u0026lt;/script\u0026gt; 購物車 接著要修改購物車頁面 /src/views/Cart.vue 將商品資訊顯示出來。\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template v-for=\u0026#34;product in cart\u0026#34;\u0026gt; \u0026lt;div :key=\u0026#34;product._id\u0026#34; class=\u0026#34;product\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;product__name\u0026#34;\u0026gt;產品名稱：{{product.name}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__description\u0026#34;\u0026gt;簡介：{{product.description}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product__price\u0026#34;\u0026gt;價錢：{{product.price}}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;product.manufacturer\u0026#34;\u0026gt;生產商：{{product.manufacturer}}\u0026lt;/p\u0026gt; \u0026lt;img :src=\u0026#34;product.image\u0026#34; alt class=\u0026#34;product__image\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;removeFromCart(product._id)\u0026#34;\u0026gt;從購物車中移除\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .product { border-bottom: 1px solid black; } .product__image { width: 100px; height: 100px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;home\u0026#34;, data() { return { msg: \u0026#34;Welcome to the Cart Page\u0026#34; }; }, computed: { cart() { return this.$store.state.cart; } }, methods: { removeFromCart(productId) { this.$store.commit(\u0026#34;REMOVE_FROM_CART\u0026#34;, { productId }); } } }; \u0026lt;/script\u0026gt; 同樣的加入 computed 對商品做預處理\n這邊接收的是 this.$store.state.cart 也就是購物車中的商品列表\n寫好觸發 Vuex mutation 中移出購物車的按鈕方法 removeFromCart\n接著就可以開啟瀏覽器預覽執行結果\n一開始購物車是空的，我們隨便加了幾款手機進購物車後，在購物車頁面可以看見剛剛有選中的商品！\n而在購物車頁面可以將商品從購物車移除。\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202009-express-vue-build-ecommerce-12-vuex-mutation/"
  },{
    "title": "[Express+Vue 搭建電商網站] 11 認識 vuex",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 認識 vuex",
    "body": "vuex 來協助我們集中管理組件狀態，就不用到處維護狀態\n使得組件只需要專注於渲染頁面，而前端狀態都保留在 vuex 中建立的狀態庫中\n所謂狀態庫，其實也就是一個 Javascript 物件\n安裝 vuex 可以使用指令\nnpm install vuex --save 或是依然使用 vue ui 來安裝\n如果是使用 vue ui 安裝，會發現專案下多了一個檔案：/src/store/index.js，先用以下內容取代原本的檔案\nimport Vue from \u0026#39;vue\u0026#39;; import Vuex from \u0026#39;vuex\u0026#39;; Vue.use(Vuex); export default new Vuex.Store({ strict: true, state: { // bought items  cart: [], // ajax loader  showLoader: false, // selected product  product: {}, // all products  products: [ { name: \u0026#39;產品 1\u0026#39;, } ], // all manufacturers  manufacturers: [], } }) 上面我們做了一些事情\n 導入了 Vue 和 Vuex 調用 Vue.use 方法宣告使用 Vuex，聽起來和 vue-router 的時候一樣 最後導出 Vuex.Store 物件，並傳入 strict 和 state 參數\nstrict 宣告我們必須使用 Vuex 的 Mutation 函數來改變 state，否則會報錯（這部分會在之後的章節說明）\n而 state 參數儲存全域的狀態，比如在這邊定義了 cart、showLoader 等屬性\n都是後面我們操作會使用到的資料  整合 Vuex 和 Vue 當我們建立了 Vuex 的 store 物件後就可以使用它了，打開 src/main.js\n在開頭導入之前建立的 store，並且將 store 添加到 Vue 初始化的參數列表裡\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; Vue.config.productionTip = false new Vue({ router, store, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 如果你是使用 Vue ui 安裝，打開檔案可以見到程式已經幫我們完成了以上的內容\n當我們將 store 導入到了 Vue 中進行初始化後，Vue 會將 store 裡面的 state 注入到所有的組件中\n這樣所有的 Vue 組件就共享了一個全域的 state\n而所有的狀態變化都是針對這個 javascript 物件進行操作，然後觸發組件的重新渲染\n同時也避免了組件嵌套層級過多時，組件之間傳遞屬性的複雜性，便於大型程式與團隊合作\n查看結果 在整合好 Vuex 和 Vue 之後，馬上來看看 Vuex 帶來的變化。打開 src/pages/admin/Products.vue 修改成以下內容\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt;{{ product.name }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { computed: { product() { return this.$store.state.products[0]; } } }; \u0026lt;/script\u0026gt; 可以在 \u0026lt;script\u0026gt; 中看到一個沒見過的東西 computed，先來了解一下這是什麼\nComputed 如果在前端模板內加入太多的邏輯運算，不但可讀性差也難以維護，這問題在後端套版時常常發生，很難一眼看出它到底要渲染什麼\n而 計算屬性 (computed) 有點類似於 method，但 method 需要括號來觸發\n而且 method 不管相依的資料有沒有改變，都會重新計算。computed 則是在相依的資料有改變時才做計算並渲染\n所以需要每次更新的行為用 method，在意效能的話使用 computed\n講完了 computed 屬性，回頭來看剛剛的改動，我們在 computed 定義了一個 product 屬性\n會去 Vuex 也就是 store 中的 state 中 products 的第一個元素\n然後在頁面上使用剛剛取到的內容中的 name 屬性渲染\n於是我們知道可以使用 this.$store.state 來取得 Vuex store 中保存的 state\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202009-express-vue-build-ecommerce-11-install_vuex/"
  },{
    "title": "[Express+Vue 搭建電商網站] 10 用 vue 建立一個表單",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 用 vue 建立一個表單",
    "body": "後端的 API 上次已經開了出來，接著來建立前端使用的表單\n這次的目標是建立新增商品時所用的表單，會使用到基本的 Vue 知識，如果沒看過文件的可以先了解一下官方文件\n架構規劃 之前我們建立了 /src/views/admin/New.vue 這個模板做為網址 /admin/new 的顯示頁面\n在這節中會建立一個表單，然後讓他作為頁面組件顯示在 New.vue 中\n程式實作 建立一個新的檔案 /src/components/products/ProductForm.vue 作為表單的組件\n可以看到我們在這邊的存放位置不再是 /src/views/ 因為他是組件\n好好的放在「components」內是比較好的架構方式\n\u0026lt;template\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;saveProduct\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-5 col-md-5 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Name\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Name\u0026#34; v-model=\u0026#34;model.name\u0026#34; name=\u0026#34;name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Price\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Price\u0026#34; v-model=\u0026#34;model.price\u0026#34; name=\u0026#34;price\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Manufacturer\u0026lt;/label\u0026gt; \u0026lt;select type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; v-model=\u0026#34;model.manufacturer\u0026#34; name=\u0026#34;manufacturer\u0026#34;\u0026gt; \u0026lt;template v-for=\u0026#34;manufacturer in manufacturers\u0026#34;\u0026gt; \u0026lt;option :key=\u0026#34;manufacturer._id\u0026#34; :value=\u0026#34;manufacturer._id\u0026#34; :selected=\u0026#34;manufacturer._id == (model.manufacturer \u0026amp;\u0026amp; model.manufacturer._id)\u0026#34; \u0026gt;{{manufacturer.name}}\u0026lt;/option\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-lg-4 col-md-4 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Image\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; lass=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Image\u0026#34; v-model=\u0026#34;model.image\u0026#34; name=\u0026#34;image\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Description\u0026lt;/label\u0026gt; \u0026lt;textarea class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Description\u0026#34; rows=\u0026#34;5\u0026#34; v-model=\u0026#34;model.description\u0026#34; name=\u0026#34;description\u0026#34; \u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group new-button\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-pencil\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;!-- Conditional rendering for input text --\u0026gt; \u0026lt;span v-if=\u0026#34;isEditing\u0026#34;\u0026gt;Update Product\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;Add Product\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#34;model\u0026#34;, \u0026#34;manufacturers\u0026#34;, \u0026#34;isEditing\u0026#34;], methods: { saveProduct() { this.$emit(\u0026#34;save-product\u0026#34;, this.model); } } }; \u0026lt;/script\u0026gt; 程式說明 於是我們來看看這段看起來很長很嚇人的東西在做什麼？\n分為兩部分來理解\nscript 部分 props 主要接收父組件傳來的三個參數 model、manufacturers、isEditing\n然後在 methods 定義了一個方法 saveProduct，當使用者填完送出後按下送出會觸發這個方法\n而在 saveProduct 內部調用了一個 save-product 方法，這個方法稍後會在父組件建立\n除了調用父組件方法，在送出的同事還會把 this.model 內容傳遞給父組件\ntemplate 部分 淺而易見的 template 就是一個表單，其中的 submit 事件使用 @submit.prevent 禁用預設的送出行為\n並使用 saveProduct 替換\n接著寫了好幾個 class=\u0026quot;form-group\u0026quot; 的區塊，代表要填寫的商品資料\n其中前兩個區塊使用了 v-model 綁定 model 的 name、price 兩個屬性\n第三個區塊先對 select 標籤雙向綁定了 model.manufacturer 屬性\n代表在內部做的行為都會影響對應的 model.manufacturer\n接著使用迴圈把 script 中接收到的父組件 manufacturers 資料一個一個設為 option 標籤內容\n並且把個別設定 manufacturer 的屬性\n以及如果 model.manufacturer._id 和當前的 manufacturer._id 一致\n就把 selected 屬性設為 true\n接著第四個 form-group 開始，依然是使用 v-model 綁定 model.image 和 model.description 屬性\n最後一個 form-group 使用 v-if 判斷式來判斷 isEditing 來渲染不同的按鈕文字\n 完成了子組件之後，就要引入父組件內。所以重新打開 New.vue 這個檔案，引入剛剛建立的表單組件\n\u0026lt;template\u0026gt; \u0026lt;product-form @save-product=\u0026#34;addProduct\u0026#34; :model=\u0026#34;model\u0026#34; :manufacturers=\u0026#34;manufacturers\u0026#34; \u0026gt; \u0026lt;/product-form\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ProductForm from \u0026#39;@/components/products/ProductForm.vue\u0026#39;; export default { data() { return { model: {}, manufacturers: [ { _id: \u0026#39;sam\u0026#39;, name: \u0026#39;Samsung\u0026#39;, }, { _id: \u0026#39;apple\u0026#39;, name: \u0026#39;Apple\u0026#39;, }, ], }; }, methods: { addProduct(model) { console.log(\u0026#39;model\u0026#39;, model); }, }, components: { \u0026#39;product-form\u0026#39;: ProductForm } } \u0026lt;/script\u0026gt; 當要在一個組件中使用另一個組件時，需要在父組件的 components 中註冊\n在我們的 New.vue 中就將 ProductForm 註冊為 product-form\n於是我們就可以在 \u0026lt;template\u0026gt; 區塊中使用 \u0026lt;product-form /\u0026gt; 來使用組件。\n同時在 data 中定義了 model 和 manufacturers；methods 中定義了 addProduct 方法\n並且綁定成 @save-product=\u0026quot;saveProduct\u0026quot; 事件傳遞給子組件使用\n儲存之後，重新開啟前端網頁，進入新建商品的頁面就可以看到子組件已經被加入 New.vue 的畫面上\n目前為止我們學會了\n 使用 vue-router 進行多頁面的跳轉與路由 使用嵌套路由有組織的管理前端路由 基礎的 Vue 使用 學會建立 Vue 的組件並在父組件中使用   專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202009-express-vue-build-ecommerce-10-new-product-page/"
  },{
    "title": "[Express+Vue 搭建電商網站] 09 API 測試",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 測試",
    "body": "在上一篇中完成了第一個 API，這一篇要來測試 API 是不是正常工作\n測試 API 經過上一篇的流程，我們的 API 應該已經建好了，現在透過常用的 API 測試軟體：Postman 來測試\nmanufacturers   POST /api/v1/manufacturers\n首先先建立供應商的資料，測試新建一個供應商「Google」\n  GET /api/v1/manufacturers\n查看供應商，因為我原本就有寫入了一個供應商「Apple」所以會有兩筆資料\n  PUT /api/v1/manufacturers/:id\n接著更新「APPLE」為「Apple」\n  DELETE /api/v1/manufacturers/:id\n最後我特別建立了一個叫做「samsung」的供應商用來測試刪除功能\n  products 最後來測試新建產品資料\n  POST /api/v1/products\n建立一個產品「iPhone 11」並且把他的供應商（manufacturer）指定給剛剛看過的「Apple」\n  GET /api/v1/products 新增完之後，使用 GET 方法取得資料查看會發現，iPhone 11 這筆資料的外部鍵值 manufacturer\n屬性的確是對應到當初在 model 設定中指定的 manufacturer Model 的 ObjectId 資料內容\n在這個範例中就是「Apple」。如此我們就建立了一款 Apple 出的手機：iPhone 11\n  結論 到這邊我們就已經建立好了 API 的服務\n在這幾個章節中我們學到了\n 了解 Express 路由以及如何使用 mongoose 連接 monogoDB 資料庫 編寫路由、Controller 和 Model 使用 Postman 測試 API  目前我們對於 Node 和 Express 搭建後端 API 有了基本的了解，就繼續前進吧！\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-09-test-api/"
  },{
    "title": "[Express+Vue 搭建電商網站] 08 API 建立",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 建立",
    "body": "在上一篇中建立了 Router，這一篇要做的就是將 Controller 完成，如此就完成了第一個 API\n建立 API 建立 Controller 接著就來建立兩個 Controller productController 和 manufacturerController\ncontrollers/manufacturer.js 這個 Controller 管理製造商（manufacturers）資料的操作，回頭看看上面路由中的方法是不是都找到了呢？\n開頭導入了之前在 Model 中定義過的 ManufacturerModel，這是 mongoose 提供給我們操作資料庫的介面\n通過 Model 上定義的一系列指令來對 Manufacturer 做資料操作\nconst Model = require(\u0026#39;../model\u0026#39;); const { Manufacturer } = Model; const manufacturerController = { all(req, res) { Manufacturer.find({}) .exec((err, manfacturers) =\u0026gt; res.json(manfacturers)) }, byId(req, res) { const idParams = req.params.id; Manufacturer .findOne({ _id: idParams }) .exec((err, manufacturer) =\u0026gt; res.json(manufacturer)); }, create(req, res) { const requestBody = req.body; const newManufacturer = new Manufacturer(requestBody); newManufacturer.save((err, saved) =\u0026gt; { Manufacturer .findOne({ _id: newManufacturer._id }) .exec((err, manfacturer) =\u0026gt; res.json(manfacturer)) }) }, update(req, res) { const idParams = req.params.id; let manufacturer = req.body; Manufacturer.updateOne({ _id: idParams }, { ...manufacturer }, (err, updated) =\u0026gt; { res.json(updated); }) }, remove(req, res) { const idParams = req.params.id; Manufacturer.findOne({ _id: idParams }).remove( (err, removed) =\u0026gt; res.json(idParams) ) } } module.exports = manufacturerController; controllers/product.js 而在 productController 中基本上與上方 manufacturerController 概念一致\nconst Model = require(\u0026#39;../model\u0026#39;); const { Product } = Model; const productController = { all(req, res) { Product.find({}) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, products) =\u0026gt; res.json(products)) }, byId(req, res) { const idParams = req.params.id; Product .findOne({ _id: idParams }) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, product) =\u0026gt; res.json(product)); }, create(req, res) { const requestBody = req.body; const newProduct = new Product(requestBody); newProduct.save((err, saved) =\u0026gt; { Product .findOne({ _id: newProduct._id }) .populate(\u0026#39;manufacturer\u0026#39;) .exec((err, product) =\u0026gt; res.json(product)) }) }, update(req, res) { const idParams = req.params.id; const product = req.body; console.log(\u0026#39;idParams\u0026#39;, idParams); console.log(\u0026#39;product\u0026#39;, product); Product.updateOne({ _id: idParams }, { ...product }, (err, updated) =\u0026gt; { res.json(updated); }) }, remove(req, res) { const idParams = req.params.id; Product.findOne({ _id: idParams }).remove( (err, removed) =\u0026gt; res.json(idParams) ) } } module.exports = productController; 完成後存擋，在終端機執行 npm start\n要先先確定是你的 mongoDB 要是開著的，可以使用指令\nmongo 看能不能進入 mongo 的指令列中，如果忘記怎麼開啟可以回到前面：連接 MongoDB 章節複習\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-08-build-api/"
  },{
    "title": "[Express+Vue 搭建電商網站] 07 API 路由建立",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - API 路由建立",
    "body": "在上一篇中建立了 Model，這一篇要做的就是將路由完成，讓請求可以送到指定的 Controller\nAPI 路由建立 新增路由並設定路由群組 打開 app.js 引入我們要使用的 api 路由\nconst api = require(\u0026#39;./routes/api\u0026#39;); 路徑就設定成 /api/v1 吧\napp.use(\u0026#39;/api/v1\u0026#39;, api); 這下子所有進入 /api/v1/ 以及底下路徑的所有請求都會進入 /routes/api 這個路由內\n建立新路由 我們建立一個檔案 /routes/api/index.js\nconst express = require(\u0026#39;express\u0026#39;); const router = express.Router(); const productController = require(\u0026#39;../../controllers/product\u0026#39;); const manufacturerController = require(\u0026#39;../../controllers/manufacturer\u0026#39;); router.get(\u0026#39;/manufacturers\u0026#39;, manufacturerController.all); router.get(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.byId); router.post(\u0026#39;/manufacturers\u0026#39;, manufacturerController.create); router.put(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.update); router.delete(\u0026#39;/manufacturers/:id\u0026#39;, manufacturerController.remove); router.get(\u0026#39;/products\u0026#39;, productController.all); router.get(\u0026#39;/products/:id\u0026#39;, productController.byId); router.post(\u0026#39;/products\u0026#39;, productController.create); router.put(\u0026#39;/products/:id\u0026#39;, productController.update); router.delete(\u0026#39;/products/:id\u0026#39;, productController.remove); module.exports = router; 我們在上一步建立了路由群組，而這個步驟中我們照著經典的 RESTful API 規則來撰寫路由規則\n get：取得資源 post：建立新資源 put：更新資源 delete：刪除資源  在這個路由群組中不難發現，我們引用了 productController、manufacturerController\n這兩個尚未建立的檔案，而這兩個檔案就是我們 MVC 中的 Controller\n而 router 物件接了各種路徑的請求方法，並指定給所屬的 Controller 方法\n下個章節會建立 Controller 並且測試 API 是否成功運行\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-07-api-routes/"
  },{
    "title": "[Express+Vue 搭建電商網站] 06 - 資料庫設計",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 資料庫設計",
    "body": "先前我們安裝好了 mongoDB 以及開啟了 CORS，這一篇要來建立資料庫架構以及 MVC 架構中的 Model 部分\n資料庫設計 Schema 在 Express 中，資料庫的 Schema 是建立在 model/index.js 中的，如果沒有 model 資料夾就自己建一個\nconst mongoose = require(\u0026#39;mongoose\u0026#39;); const Schema = mongoose.Schema; const model = mongoose.model.bind(mongoose); const ObjectId = mongoose.Schema.Types.ObjectId; const productSchema = Schema({ id: ObjectId, name: String, image: String, price: Number, description: String, manufacturer: { type: ObjectId, ref: \u0026#39;Manufacturer\u0026#39; } }); const manufacturerSchema = Schema({ id: ObjectId, name: String, }); const Product = model(\u0026#39;Product\u0026#39;, productSchema); const Manufacturer = model(\u0026#39;Manufacturer\u0026#39;, manufacturerSchema); module.exports = { Product, Manufacturer }; 在下方兩個 model 的常數定義中 Schema 接收一個物件來定義資料結構以及對應的類型\n除了常見的 String, Number 外，比較特別的是：ObjectId 代表 MongoDB 中資料的主鍵，具有唯一性\n並且在 productSchema 中具有一個特別的屬性：manufacturer\n這個物件定義了一個 ref 屬性，對應到 Manufacturer 這個 model\n這是 MongoDB 的外部鍵值，與之對應的是 Manufacturer 中的 ObjectId 屬性的資料\n這就是我們習慣的 MVC 架構中的「Model」部分\n",
    "ref": "/blog/202008-express-vue-build-ecommerce-06-db-schemas-and-models/"
  },{
    "title": "[Express+Vue 搭建電商網站] 05 - 連接 MongoDB 與 CORS",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 連接 MongoDB 與 CORS",
    "body": "資料庫使用 MongoDB，這篇中我們會簡單介紹基本連線方式，以及跨來源資源共(CORS)\n連接 MongoDB 接著我們要安裝 mongoose 套件：Mongoose\nMongoose 是一個 MongoDB 對象建模工具，用於在異步環境中工作\n是時下最流行的 ODM(Object Document Mapping)，要比直接操作底層 MongoDB Node 更方便\nnpm install mongoose 接著回到 app.js 中導入剛剛安裝的 mongoose\nconst mongoose = require(\u0026#39;mongoose\u0026#39;) 並透過套件提供的方法連上我們的 MongoDB 資料庫\nmongoose.connect(`mongodb://localhost:27017/test`); 雖然現在看不出效果，但我們等等會嘗試操作資料庫來測試連線的有效性\n但現在我們先做點額外的事情，儘管目前看來沒什麼用處但卻是必要的一環\n那就是開啟跨來源資源共用 CORS\n跨來源資源共用 CORS CORS 是基於 同源政策 的限制\n當關閉時限制了程式碼和不同網域資源間的互動，來自不同網域的資源請求會被無情拒絕！\n讓我們回到 app.js，在剛剛的資料庫連線下一行加入以下程式碼\n// CORS config here app.all(\u0026#39;/*\u0026#39;, function(req, res, next) { // CORS headers  res.header(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); // restrict it to the required domain  res.header(\u0026#39;Access-Control-Allow-Methods\u0026#39;, \u0026#39;GET,PUT,POST,DELETE,OPTIONS\u0026#39;); // Set custom headers for CORS  res.header(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;Content-type,Accept,X-Access-Token,X-Key\u0026#39;); if (req.method == \u0026#39;OPTIONS\u0026#39;) { res.status(200).end(); } else { next(); } }); 通常來說會使用 npm 套件 cors 解決，但這邊先用簡單暴力的方式解決\n未來如果有進行優化會再回頭安裝\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202007-express-vue-build-ecommerce-05-mongodb-connect-and-cors/"
  },{
    "title": "[Express+Vue 搭建電商網站] 04 - 進入 MongoDB 的世界",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 進入 MongoDB 的世界",
    "body": "資料庫使用 MongoDB，這篇中我們會簡單介紹基本指令及安裝。\n安裝 MongoDB 因為使用的是 mac 筆電，所以最愛用 Homebrew 安裝東西\n除了 node.js！這東西用 brew 裝會把你搞到懷疑人生，並且連官網都不建議這麼做\n但是 MongoDB 官方有釋出：使用 Homebrew 的安裝方法，我們就這個做看看吧\n至於不會使用 Homebrew 或是使用其他作業系統的人，可以使用：官方的下載中心進行安裝\n安裝好之後有兩種啟動的方法\n 作為背景執行：mongod --config /usr/local/etc/mongod.conf --fork 使用 brew 管理  這邊推薦使用 brew 來操作的原因是容易操作，簡單幾個指令就可以\n 啟動服務：brew services start mongodb-community 重新啟動：brew services restart mongodb-community 停止服務：brew services stop mongodb-community  執行之後繼續輸入 mongo 指令，應該會進到 mongoDB 的指令列中\n到這邊就代表已經 mongoDB 服務就安裝並且啟動了\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202007-express-vue-build-ecommerce-04-hello-mongodb/"
  },{
    "title": "[Express+Vue 搭建電商網站] 03 - 認識 Express",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 認識 Express",
    "body": "後端使用的是 node.js 的後端框架 - express，這篇中我們會建立新專案。\n建立 Express 專案 使用 express-generator 來建立專案\nnpm install -g express-generator 安裝完成後可以使用以下指令查看版本是否有安裝成功\nexpress --version 接著初始化建立新專案\nexpress backend 建立之後運行看看初始樣貌\ncd backend npm install npm start 打開瀏覽器 http://localhost:3000/ 應該會看到以下畫面\n打開看看 Express 專案的資料夾架構\n app.js：Express Web Application 原型 routes/index.js：路由設定主要檔案 views/：放 View 的檔案 public/：放靜態檔案  和其它文章不同的是，這次使用 express-generator 建立的專案中並沒有把所有路由給寫在 app.js 中\n而是根據不同的應用做拆分，這和前端使用 vue-router 的嵌套路由是相同的概念\napp.js 在 app.js 中一開始先對於會用到的資源進行導入，例如 routes/index 和 routes/users 兩個路由\n也定義了專案使用的前端模板類型。但因為我們後端是作為 API 使用，所以沒什麼差\nroutes/index.js 而在 routes/index.js 中定義了進入這個路由之後對於不同請求可以做的回應方式\n這就是主要我們需要先了解的部分\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202007-express-vue-build-ecommerce-03-hello-express/"
  },{
    "title": "[Express+Vue 搭建電商網站] 02 - vue-router 的使用",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - vue-router 的使用",
    "body": "在接下來的內容中會學習 vue-router 的使用方法與學習路由基礎知識\n並使用 vue-router 來進行多個頁面的跳轉\n建立新組件 首先我們要先建立新的頁面組件，新建一個 src/components/Home.vue 檔案\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;home\u0026#39;, data () { return { msg: \u0026#39;Welcome to Your Vue.js App\u0026#39; }; }, } \u0026lt;/script\u0026gt; 看起來跟一開始預設的 HelloWorld.vue 有 87% 像，但是這邊先不對樣式做糾結，之後再去找 UI 庫套用\n設定 vue-router 在安裝了 vue-router 之後，會發現專案中多了一個資料夾 /src/router/index.js\n這就是 vue-router 的設定檔\n藉由以下這段我們發現，路徑 '/' 使用的是 Home 這個組件\nconst routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;About\u0026#39;, // route level code-splitting  // this generates a separate chunk (about.[hash].js) for this route  // which is lazy-loaded when the route is visited.  component: () =\u0026gt; import(/* webpackChunkName: \u0026#34;about\u0026#34; */ \u0026#39;../views/About.vue\u0026#39;) } ] 順著邏輯往上找會發現 Home 這個組件的引用來源\nimport Home from \u0026#39;../views/Home.vue\u0026#39; 接著打開 /views/Home.vue，原來這引入了 HelloWorld 組件\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;home\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;../assets/logo.png\u0026#34;\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // @ is an alias to /src import HelloWorld from \u0026#39;@/components/HelloWorld.vue\u0026#39; export default { name: \u0026#39;Home\u0026#39;, components: { HelloWorld } } \u0026lt;/script\u0026gt; 知道原理之後呢，就把 /views/Home.vue 內部目前沒有用到的部分刪除，並且換成我們上面建立的 Home 組件\n\u0026lt;script\u0026gt; // @ is an alias to /src import Home from \u0026#39;@/components/Home.vue\u0026#39; export default { name: \u0026#39;Home\u0026#39;, components: { Home } } \u0026lt;/script\u0026gt; 這時候使用瀏覽器開啟專案首頁，應該就會看到首頁已經變成 Home.vue 的內容\n加入頁面上方導航超連結 打開 App.vue 檔案，在 id=\u0026quot;app\u0026quot; 中加入三個 router-link 標籤的超連結，這是 Vue Router 的 API\n根據官網說明 \u0026lt;router-link\u0026gt; 比起寫死的 \u0026lt;a href=\u0026quot;...\u0026quot;\u0026gt; 會好一些\n 無論是 HTML5 history 模式還是 hash 模式，它的表現行為一致，所以，當你要切換路由模式，或者在 IE9 降級使用 hash 模式，無須作任何變動。 在 HTML5 history 模式下，router-link 會守衛點擊事件，讓瀏覽器不再重新加載頁面。 當你在 HTML5 history 模式下使用 base 選項之後，所有的 to 屬性都不需要寫 (基路徑) 了。  \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;nav__left\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;Admin\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/cart\u0026#34;\u0026gt;Cart\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 看到上面的程式碼內容，聰明的你一定知道接著我們要建立三個頁面\n admin 後台管理 購物車頁面  剛剛示範了怎麼在 /views/Home.vue 中引入 src/components/Home.vue\n但在這邊先簡單一點，直接在 /views/ 目錄下建立如同 src/components/Home.vue 內容的檔案\n這時候 /views/ 資料夾應該會長得像這樣\n這時候其實可以把剛剛的 Home.vue 搬移進 /views/ 中，我們原本的引用在這邊有點多此一舉了\n但是在搬移過後會發現瀏覽器提示我們發生了一些問題，原來是 Home.vue 找不到檔案，但是為什麼呢？\n我們不是在 vue-router 裡面指定路徑 \u0026lsquo;/‘ 要到 Home.vue 嗎？\n首先復原程式碼，來看看在哪裡使用到了 src/components/Home.vue？\n哈！原來是一開始我們創建新組建時候把 App.vue 裡面的初始頁面 import 設定成 Home\n這也就說明了為什麼在 admin 以及 Cart 頁面中 Home.vue 的內容還是陰魂不散\n在刪除 import 的內容之後一切就正常了\n新建立的頁面加入路由 接著把剛剛新建的頁面加入路由設定檔案 /src/router/index.js 中\nimport Vue from \u0026#39;vue\u0026#39; import Router from \u0026#39;vue-router\u0026#39; import Home from \u0026#39;@/views/Home.vue\u0026#39; import Admin from \u0026#39;@/views/Admin\u0026#39;; import Cart from \u0026#39;@/views/Cart\u0026#39;; Vue.use(Router) const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: Home }, { path: \u0026#39;/admin\u0026#39;, name: \u0026#39;Admin\u0026#39;, component: Admin }, { path: \u0026#39;/cart\u0026#39;, name: \u0026#39;Cart\u0026#39;, component: Cart, }, ] const router = new Router({ routes }) export default router 好像有些什麼東西怪怪的？為什麼可以用 @ 引用東西呢？代表什麼意思？\n在我深入研究後發這是一個 webpack 的設定\n存在於 \\node_modules\\@vue\\cli-service\\lib\\config\\base.js\n進入檔案之後可以發現有設定了一個 alias set('@', api.resolve('src')) 這代表告訴了 vue\n 看到路徑用 @ 開頭的，就從 src 這個目錄開始操作\n 這樣做可以大幅度的減少我們使用 ../ 這種作法造成目錄結構變換就專案大爆炸，或是為了存取深層的檔案，畫面被一堆點點斜線佔滿\n在完成了以上動作之後，打開瀏覽器預覽一下\n看來我們剛剛完成了一個簡單的基於 Vue 的多頁面網站了！\n嵌套路由 有點經驗的工程師就知道，路由絕對不是這麼簡單的\n當頁面少的時候可以全塞在一支檔案裡面，但當頁面開始多這樣就會顯得很亂，並且無法一眼看出彼此之間的階層關聯\n還好 vue-router 提供了嵌套路由的功能，讓我們可以組織化的管理相關聯的頁面\n在後台頁面中會使用到很多操作的頁面，例如新增、修改商品，下面就藉由嵌套路由的方法來管理這些路由\n在引入的地方加入我們之後要增加的頁面，這邊只是先聲明，之後會一步一步的完成頁面\n// Admin Components import Index from \u0026#39;@/views/admin/Index\u0026#39; import New from \u0026#39;@/views/admin/New\u0026#39; import Products from \u0026#39;@/views/admin/Products\u0026#39; import Edit from \u0026#39;@/views/admin/Edit\u0026#39; 路由常數中加入嵌套路由，會發現 Admin 下有四個組件（component）\n而嵌套路由會為相關連的子路由設置一個入口頁面\n然後把這些頁面都放到 children 定義中的陣列中\n{ path: \u0026#39;/admin\u0026#39;, name: \u0026#39;Admin\u0026#39;, component: Index, children: [ { path: \u0026#39;\u0026#39;, name: \u0026#39;Products\u0026#39;, component: Products, }, { path: \u0026#39;new\u0026#39;, name: \u0026#39;New\u0026#39;, component: New, }, { path: \u0026#39;edit/:id\u0026#39;, name: \u0026#39;Edit\u0026#39;, component: Edit, }, ] }, 接著回到 /src/views/admin 建立\n Index.vue Edit.vue New.vue Products.vue  Index.vue Index 是我們上面提到的入口組件，也就是渲染 path = /admin 的基礎組件\n其餘的組件藉由 children 陣列宣告為嵌套的子路由。在子路由內的路由，前端都必須加上父層的路徑\n而在上方的定義中，我們把 /admin/ 的渲染子組件定義給了 Products\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;admin-new\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-3 col-md-3 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;admin-menu\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin\u0026#34;\u0026gt;View Products\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/admin/new\u0026#34;\u0026gt;New Products\u0026lt;/router-link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 是用來渲染子路由的組件，比如說我們進入了 admin/new\n那麼 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 內部會被替換成 New.vue 組件的內容\n因為我們在上面路由定義中定義 \u0026lsquo;/new\u0026rsquo; 的路由渲染組件是 New.vue\nEdit.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/Edit/{{$route.params.id}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Edit 這個路由在剛剛路由定義的時候有點不一樣，他的路徑是 edit/:id 這種寫法被稱作動態路由\n:id 會接收任意的內容作為一個參數傳入。例如我們進入 /admin/edit/banana 頁面\n那麼就可以在 Edit.vue 這個組件上使用\n{{$route.params.id}} 來呼叫到 :id 接收到的值，在上面的例子中就是「banana」\nNew.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin/New\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Products.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;This is Admin\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 建立完成之後就完成了嵌套路由的應用\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202007-express-vue-build-ecommerce-02-vue-router/"
  },{
    "title": "[Express+Vue 搭建電商網站] 01- 初始設定",
    "date": "",
    "description": "使用 Express + Vue 搭建一個電商網站 - 初始設定",
    "body": "本篇將使用 vue-ui 建立專案，並且安裝 vue-router\n安裝所需要的環境 在這個練習中我們首先需要的是安裝 npm 以及node\n這部分教學太多了，總之就先去裝起來吧！裝好後使用\nnpm -v # 確定安裝結果 node -v 接著要安裝我們前端所要使用的 vue\nnpm install -g vue-cli 安裝完成後在 terminal 確認安裝結果\nvue --version 新建 vue 專案 這次嘗試使用 Vue-cli 新出的 vue ui 來建立專案，在終端機輸入\nvue ui 就可以起動，根據提示我們開啟 vue-ui 的畫面 按下新增之後選擇指定的位置，根據畫面上提示來建立新專案\n接著就是等待他執行完成，在終端機進到剛剛建立專案的資料夾下會發現一個 vue 專案已經被建立\n根據 README 的說明執行以下指令後，可以打開 http://localhost:8080/ 來預覽執行結果\nnpm install npm run serve 安裝 vue-router 接著還要安裝一個我們會用上的東西：vue-router\n可以選擇下指令，或是同樣的使用 vue-ui 來完成，既然剛剛使用 vue-ui 建立專案，這邊繼續使用 vue-ui 安裝 vue-router\n打開 vue-ui 頁面，最上方搜尋欄的左邊看「新增 vue-router」給他按下去就會開始安裝了 安裝好之後可以進入 main.js 查看，友善的自動安裝已經幫我們引入了呢！\n如此就完成了我們前端 vue 專案的初始設定\n 專案範例程式碼 GitHub 網址：ray247k/mini-E-commerce\n",
    "ref": "/blog/202006-express-vue-build-ecommerce-01-basic-settings/"
  },{
    "title": "About",
    "date": "",
    "description": "關於我",
    "body": "對我來說程式是一種具名的創作，同時也是一個工程師態度的表現\n你寫出怎麼樣的程式碼，別人就怎麼評價你\n Your name shall speak for yourself.\n 喜歡進行技術交流，對社群充滿熱情，積極地參與相關聚會吸收他人的經驗\n同時也樂於分享自身故事，在這條路上接受過太多幫助，也樂於伸出援手成為別人的英雄\n相信透過分享可以讓自己成為更好的人\n",
    "ref": "/about/"
  }]
